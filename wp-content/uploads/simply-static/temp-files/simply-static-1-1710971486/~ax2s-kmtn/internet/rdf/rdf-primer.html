<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="ja" xml:lang="ja" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="generator" content="HTML Tidy for Linux/x86 (vers 1st March 2002), see www.w3.org">

    <title>RDF入門</title>
<style type="text/css">
/*<![CDATA[*/
.new { color: #FF0000 }

.example {font-family: monospace; }

.figure {
         font-weight: bold;
         text-align: center; }

.newstuff { }

.primative {
    padding: 1em; 
    margin: 0.1em 3.5em 0.1em 0.1em;
    background-color: #eddddd;
    border: 1px solid #cfcfcf; }

.ptriple {
    padding: 1em; 
    margin: 0.1em 3.5em 0.1em 0.1em;
    background-color: #eedddd;
    border: 1px solid #cfcfcf; }

.caveat {
    padding: 1em; 
    margin: 0.1em 3.5em 0.1em 0.1em;
    border: 1px solid #cfcfcf; }

.principle { background: #f7ebd7; color: black; border: solid black thin; padding: .1em; margin-left: 5%; margin-right: 5%}

div.example {
    padding: 1em; 
    margin: 0.1em 3.5em 0.1em 0.1em;
    background-color: #efeff5;
    border: 1px solid #cfcfcf; }

div.exampleOuter {
/*
   border: 4px double gray;
*/
   margin: 0em;
   padding: 0em;
}

div.exampleInner {
   color: black;
   /* tan */
   /* background-color: #d2b48c; */
   /* cyan */
   /* background-color: #99ffff; */
   /* mauve */
   background-color: #efeff5;
   border-top-style: double;
   border-top-color: #d3d3d3;
   border-bottom-width: 1px; 
   border-bottom-style: double;
   border-bottom-color: #d3d3d3;
   padding: 4px;
   margin: 0em;
}

div.exampleInner pre {
  margin-left: 0em;
  margin-top: 0em;
  margin-bottom: 0em;
  font-family: monospace;
  /* font-size: smaller */
}

 body {
  background-color: #FFFFFF;
 }

 div.c1 {text-align:center}

/*]]>*/
</style>

<style type="text/css" xml:space="preserve">.PrePublicationWarning {
   font-weight: bold;
   margin: 1em 0em;
   border: medium double black;
   background: yellow;
   padding: 1em;
}</style>

    <link rel="stylesheet" type="text/css" href="www.w3.org/StyleSheets/TR/W3C-REC">
  </head>

  <body>

<p><a href="www.asahi-net.or.jp/~ax2s-kmtn/index.html"><img src="www.asahi-net.or.jp/~ax2s-kmtn/images/logo.gif" alt="CyberLibrarian" width="105" height="19"></a></p>

<p>【注意】 このドキュメントは、W3Cの<a href="www.w3.org/TR/2004/REC-rdf-primer-20040210/">RDF Primer W3C Recommendation 10 February 2004</a>の和訳です。<br>
このドキュメントの正式版はW3Cのサイト上にある英語版であり、このドキュメントには翻訳に起因する誤りがありえます。誤訳、誤植などのご指摘は、<a href="www.asahi-net.or.jp/~ax2s-kmtn/mail.html">訳者</a>までお願い致します。</p>

<p>First Update: 2005年9月27日</p>

<hr>

    <div class="head">
      <a href="www.w3.org/"><img height="48" width="72" alt="W3C" src="www.w3.org/Icons/w3c_home"></a>

      <h1 id="title">RDF入門</h1>

      <h2 id="hstatus">W3C 勧告 2004年2月10日</h2>

      <dl>
        <dt>本バージョン:</dt>

        <dd><a href="www.w3.org/TR/2004/REC-rdf-primer-20040210/">http://www.w3.org/TR/2004/REC-rdf-primer-20040210/</a></dd>

        <dt>最新バージョン:</dt>

        <dd><a href="www.w3.org/TR/rdf-primer/">http://www.w3.org/TR/rdf-primer/</a></dd>

        <dt>旧バージョン:</dt>

        <dd><a href="www.w3.org/TR/2003/PR-rdf-primer-20031215/">http://www.w3.org/TR/2003/PR-rdf-primer-20031215/</a></dd>

        <dt>編集者:</dt>

        <dd>Frank Manola, <a href="mailto:fmanola@acm.org">fmanola@acm.org</a>
</dd>

        <dd>Eric Miller, W3C, <a href="mailto:em@w3.org">em@w3.org</a>
</dd>

        <dt>シリーズ編集者:</dt>

        <dd>Brian McBride, Hewlett-Packard Laboratories, <a href="mailto:bwm@hplb.hpl.hp.com">bwm@hplb.hpl.hp.com</a>
</dd>
      </dl>

<p>このドキュメントに対する<a href="www.w3.org/2001/sw/RDFCore/errata#rdf-primer"><strong>正誤表</strong></a>を参照してください。いくつかの規範的な修正が含まれているかもしれません。</p>

<p><a href="www.w3.org/2001/sw/RDFCore/translation/rdf-primer">翻訳版</a>も参照してください。</p>

<p class="copyright"><a href="www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>
      &copy; 2004 <a href="www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>&reg;</sup>
      (<a href="www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>,
      <a href="www.ercim.org/"><acronym title="European Research Consortium for Informatics and Mathematics">
      ERCIM</acronym></a>, <a href="www.keio.ac.jp/">Keio</a>),
      All Rights Reserved. W3C <a href="www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">
      liability</a>, <a href="www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">
      trademark</a>, <a href="www.w3.org/Consortium/Legal/copyright-documents">document
      use</a> and <a href="www.w3.org/Consortium/Legal/copyright-software">software
      licensing</a> rules apply.</p>
      <hr title="Separator for header">
    </div>

    <h2><a id="abstract" name="abstract">要約</a></h2>

    <p>RDF（Resource Description Framework）は、WWW上で資源に関する情報を表現するための言語です。この入門書は、RDFを効果的に利用するために必要な基礎知識を読者に提供するために考案されました。RDFの基本概念を紹介し、XML構文について記述しています。RDF語彙記述言語を用いてRDF語彙を定義する方法を記述し、一部の導入済みRDFアプリケーションの概要を提供します。また、他のRDF仕様ドキュメントの内容と目的について説明します。</p>

<div class="status">

<h2 class="nonum">
<a id="status" name="status">このドキュメントのステータス</a>
</h2>

<!-- Start Status-Of-This-Document Text -->

<p>このドキュメントは、W3Cメンバーおよび他の利害関係者によりレビューされ、<a href="www.w3.org/2003/06/Process-20030618/tr.html#RecsW3C">W3C勧告</a>として管理者の協賛を得ました。勧告の作成におけるW3Cの役割は、仕様に注意を引き付け、広範囲な開発を促進することです。これによってウェブの機能性および相互運用性が増強されます。</p>

<p>本ドキュメントは、以前のRDF仕様、<a href="www.w3.org/TR/1999/REC-rdf-syntax-19990222/">RDFモデルおよび構文（1999年勧告）</a>、<a href="www.w3.org/TR/2000/CR-rdf-schema-20000327/">RDFスキーマ（2000年勧告候補）</a>を同時に置き換えることを目的とする<a href="www.w3.org/TR/2004/REC-rdf-concepts-20040210/#section-Introduction">一連の6つ</a>（<a href="www.w3.org/TR/2004/REC-rdf-primer-20040210/">入門</a>、<a href="www.w3.org/TR/2004/REC-rdf-concepts-20040210/">概念</a>、<a href="www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/">構文</a>、<a href="www.w3.org/TR/2004/REC-rdf-mt-20040210/">セマンティクス</a>、<a href="www.w3.org/TR/2004/REC-rdf-schema-20040210/">語彙</a>、および<a href="www.w3.org/TR/2004/REC-rdf-testcases-20040210/">テストケース</a>）のうちの1つです。これは、2004年2月10日の公開に向けて<a href="www.w3.org/2001/sw/">W3Cセマンティック・ウェブ・アクティビティ</a>（<a href="www.w3.org/2001/sw/Activity">アクティビティ声明</a>、<a href="www.w3.org/2002/11/swv2/charters/RDFCoreWGCharter">グループ憲章</a>）の一部として<a href="www.w3.org/2001/sw/RDFCore/">RDFコア・ワーキンググループ</a>によって開発されてきたものです。</p>

<p><a href="www.w3.org/TR/2003/PR-rdf-primer-20031215/" shape="rect">勧告案草案</a>以後のこのドキュメントに対する変更の詳細は、<a href="#changes" shape="rect">変更履歴</a>に記述されています。</p>

<p>一般の方々はコメントを<a href="mailto:www-rdf-comments@w3.org">www-rdf-comments@w3.org</a>（<a href="lists.w3.org/Archives/Public/www-rdf-comments/">アーカイブ</a>）に送り、<a href="mailto:www-rdf-interest@w3.org" shape="rect">www-rdf-interest@w3.org</a>（<a href="lists.w3.org/Archives/Public/www-rdf-interest/" shape="rect">アーカイブ</a>）における関連技術の一般的な議論に参加してください。</p>

<p><a href="www.w3.org/2001/sw/RDFCore/impls">実装</a>のリストが利用可能です。</p>

<p>W3Cは、<a href="www.w3.org/2001/sw/RDFCore/ipr-statements" rel="disclosure">この事業に関するあらゆる特許の開示</a>のリストを維持します。</p>

<p><em>この項は、このドキュメントの公開時のステータスについて記述しています。他のドキュメントがこのドキュメントに取って代わることがありえます。現行のW3Cの刊行物および技術報告の最新の改訂版のリストは、http://www.w3.org/TR/の<a href="www.w3.org/TR/">W3C技術報告インデックス</a>にあります。</em></p>

<!-- End Status-Of-This-Document Text -->

</div>


    <h2><a id="toc" name="toc">目次</a></h2>

    <p class="toc">&nbsp;&nbsp;1. <a href="#intro">はじめに</a><br>
     &nbsp;&nbsp;2. <a href="#statements">資源に関するステートメントの作成</a><br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.1 <a href="#basicconcepts">基本概念</a><br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.2 <a href="#rdfmodel">RDFモデル</a><br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3 <a href="#structuredproperties">構造化されたプロパティー値と空白ノード</a><br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.4 <a href="#typedliterals">型付きリテラル</a><br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.5 <a href="#conceptsummary">概念の要約</a><br>
     &nbsp;&nbsp;3. <a href="#rdfxml">RDFのXML構文: RDF/XML</a><br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.1 <a href="#basicprinciples">基本原理</a><br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.2 <a href="#newresources">RDF URIrefの省略と組織化</a><br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.3 <a href="#rdfxmlsummary">RDF/XMLの要約</a><br>
     &nbsp;&nbsp;4. <a href="#othercapabilities">その他のRDFの性能</a><br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.1 <a href="#containers">RDFコンテナ</a><br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.2 <a href="#collections">RDFコレクション</a><br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.3 <a href="#reification">RDFの具体化</a><br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.4 <a href="#rdfvalue">構造化された値: rdf:valueに関する詳細</a><br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.5 <a href="#xmlliterals">XMLリテラル</a><br>
     &nbsp;&nbsp;5. <a href="#rdfschema">RDF語彙の定義: RDFスキーマ</a><br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.1 <a href="#schemaclasses">クラスの記述</a><br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2 <a href="#properties">プロパティーの記述</a><br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.3 <a href="#interpretingschema">RDFスキーマ宣言の解釈</a><br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.4 <a href="#otherschema">その他のスキーマ情報</a><br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.5 <a href="#richerschemas">より豊かなスキーマ言語</a><br>
     &nbsp;&nbsp;6. <a href="#applications">RDFアプリケーションの一部: 現在のRDF</a><br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.1 <a href="#dublincore">ダブリン・コア・メタデータ・イニシアティブ</a><br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.2 <a href="#prism">PRISM</a><br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.3 <a href="#xpackage">XPackage</a><br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.4 <a href="#rss">RSS 1.0: RDFサイト・サマリー</a><br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.5 <a href="#cimxml">CIM/XML</a><br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.6 <a href="#geneont">遺伝子オントロジー・コンソーシアム</a><br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6.7 <a href="#devcap">機器性能とユーザ嗜好の記述</a><br>
     &nbsp;&nbsp;7. <a href="#otherparts">RDF仕様のその他の部分</a><br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.1 <a href="#semantics">RDFセマンティクス</a><br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.2 <a href="#testcases">テストケース</a><br>
     &nbsp;&nbsp;8. <a href="#references">参考文献</a><br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.1 <a href="#normative-references">規範的な参考文献</a><br>
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.2 <a href="#informational-references">参考情報の参考文献</a><br>
     &nbsp;&nbsp;9. <a href="#acknowledgements">謝辞</a></p>

    <h3><a id="appendices" name="appendices">付録</a></h3>

    <p class="appendix">&nbsp;&nbsp;A. <a href="#identifiers">URI（Uniform Resource Identifier）に関する詳細</a><br>
     &nbsp;&nbsp;B. <a href="#documents">XML（Extensible Markup Language）に関する詳細</a><br>
     &nbsp;&nbsp;C. <a href="#changes">変更</a><br>
    </p>
    <hr>


    <div class="section">
      <h2 id="introduction">
<a id="intro" name="intro"></a>1. はじめに</h2>

      <p>RDF（Resource Description Framework）は、WWW上で資源に関する情報を表わすための言語です。タイトル、著者、ウェブ・ページの更新日、ウェブ・ドキュメントの著作権およびライセンス情報、ある共有資源に対する利用可能スケジュールなどのような、ウェブ資源に関するメタデータの表現を特に目的としています。しかし、RDFは、「ウェブ資源」の概念を一般化することにより、ウェブでは直接<em>検索</em>できないけれどもウェブで<em>識別</em>できる事物に関する情報を表わすために使用できます。例には、オンライン・ショッピング機能で入手できるアイテムに関する情報（例えば、仕様、価格、および入手可能性に関する情報）や、情報発信に対するウェブ・ユーザの嗜好に関する記述が含まれています。</p>
    
      <p>RDFは、人間に表示するだけではなく、アプリケーションが情報を処理する必要のある状況を目的としています。RDFは、この情報を表現するための共通の枠組みを提供するため、意味を損なわずにアプリケーション間で情報交換が行えます。共通の枠組みであるため、アプリケーションの設計者は共通のRDFパーサや処理ツールを有効利用できます。異なるアプリケーション間で情報交換できるということは、情報が元々作成された以外のアプリケーションでその情報を利用できることを意味します。</p>

      <p>RDFは、ウェブ識別子（<em>Uniform Resource Identifier</em>（<em>URI</em>）と呼ばれる）を使用して事物を識別し、シンプルなプロパティーとプロパティー値で資源を記述するという考えに基づいています。これによって、資源を表わすノードとアークの<em>グラフ</em>や、そのプロパティーと値として、資源に関するシンプルなステートメントを提供できるようになります。できる限り早くこの議論をより具体的にするために、「名前がEric Millerであり、Eメール・アドレスがem@w3.orgであり、博士の称号を持つ、<span class="newstuff"><a name="LCC-007" id="LCC-007"><code>http://www.w3.org/People/EM/contact#me</code></a>で識別される人物</span>」というステートメントのグループは、<a href="#figure1">図1</a>のRDFグラフのように表わすことができます。</p>

      <div class="figure">
        <img src="www.asahi-net.or.jp/~ax2s-kmtn/internet/rdf/fig1dec16.png" alt="Eric Millerを記述したRDFグラフ"><br>
         <a id="figure1" name="figure1">図1: Eric Millerを記述したRDFグラフ</a>
      </div>

      <p><a href="#figure1">図1</a>では、以下を識別するためにRDFがURIを使用していることを示しています。</p>

      <ul>
        <li>個人、例えば、<code>http://www.w3.org/People/EM/contact#me</code>で識別されるEric Miller</li>

        <li>事物の種類、例えば、<code>http://www.w3.org/2000/10/swap/pim/contact#Person</code>で識別される人物</li>

        <li>これらの事物のプロパティー、例えば、<code>http://www.w3.org/2000/10/swap/pim/contact#mailbox</code>で識別されるメールボックス</li>

        <li>これらのプロパティーの値、例えば、メールボックス・プロパティーの値としての<code>mailto:em@w3.org</code>（RDFは、プロパティーの値として、「Eric Miller」などの文字列や、整数や日付などのその他のデータ型の値を使用する）</li>
      </ul>

      <p>RDFは、これらのグラフを記録し、交換するためのXMLベースの構文（<em>RDF/XML</em>と呼ぶ）も提供します。 <a href="#example1">例1</a>は、<a href="#figure1">図1</a>のグラフに対応するRDF/XMLのRDFの小さな一部分です。</p>

      <div class="exampleOuter">
        <div class="c1">
          <a id="example1" name="example1">例1: Eric Millerを記述したRDF/XML</a>
        </div>

        <div class="exampleInner">
<pre>
&lt;?xml version="1.0"?&gt;
&lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
             xmlns:contact="http://www.w3.org/2000/10/swap/pim/contact#"&gt;

  &lt;contact:Person rdf:about="http://www.w3.org/People/EM/contact#me"&gt;
    &lt;contact:fullName&gt;Eric Miller&lt;/contact:fullName&gt;
    &lt;contact:mailbox rdf:resource="mailto:em@w3.org"/&gt;
    &lt;contact:personalTitle&gt;Dr.&lt;/contact:personalTitle&gt; 
  &lt;/contact:Person&gt;

&lt;/rdf:RDF&gt;
</pre>
        </div>
      </div>

      <p><code>mailbox</code>と<code>fullName</code>（省略形の）、そのそれぞれの値<code>em@w3.org</code>、および<code>Eric Miller</code>のようなプロパティーと同様に、このRDF/XMLもURIを含むことに注意してください。</p>

      <p>HTMLと同様に、このRDF/XMLは、機械が処理でき、URIを利用してウェブ中の情報をリンクできます。しかし、従来のハイパーテキストとは異なり、RDFのURIは、ウェブで直接検索できない事物（Eric Millerという人物など）を含む、あらゆる識別可能な事物を参照できます。その結果として、RDFは、ウェブ・ページのような事物の記述に加え、車、ビジネス、人、ニュースなども記述できます。 さらに、RDFプロパティー自体がURIを持っていて、リンク付けされているアイテム間に存在する関係を正確に識別します。</p>

      <p>以下のドキュメントがRDFの仕様を提供しています。</p>
      <ul>
        <li>
<a href="www.w3.org/TR/rdf-concepts/">RDF概念および抽象構文</a> <a href="#ref-rdf-concepts">[RDF-CONCEPTS]</a>
</li>

        <li>
<a href="www.w3.org/TR/rdf-syntax-grammar/">RDF/XML構文仕様</a> <a href="#ref-rdf-syntax">[RDF-SYNTAX]</a>
</li>

        <li>
<a href="www.w3.org/TR/rdf-schema/">RDF語彙記述言語1.0: RDFスキーマ</a> <a href="#ref-rdf-vocabulary">[RDF-VOCABULARY]</a>
</li>

        <li>
<a href="www.w3.org/TR/rdf-mt/">RDFセマンティクス</a> <a href="#ref-rdf-semantics">[RDF-SEMANTICS]</a>
</li>

        <li>
<a href="www.w3.org/TR/rdf-testcases/">RDFテストケース</a> <a href="#ref-rdf-tests">[RDF-TESTS]</a>
</li>

        <li>
<a href="www.w3.org/TR/rdf-primer/">RDF入門</a>（このドキュメント）</li>
      </ul>

      <p>この入門書は、情報システムの設計者とアプリケーション開発者がRDFの機能とその使用法を理解するのに役立つように、RDFへの手引きを提供し、いくつかの既存のRDFアプリケーションについて記述することを目的としています。特に、この入門書は以下のような質問に答えることを目的としています。</p>

      <ul>
        <li>RDFはどのような様相をしているのか？</li>

        <li>RDFはどのような情報を表現できるのか？</li>

        <li>RDFの情報はどのように作成、アクセス、処理されるのか？</li>

        <li>どのようにして既存の情報をRDFと組み合わせられるのか？</li>
      </ul>

      <p>この入門書は<em>非規範</em>ドキュメントです。つまり、RDFの最終的な仕様ではありません。この入門書の例やその他の説明資料は、RDFの理解に役立つように提供されていますが、常に最終的または完全な答えを提供するとは限りません。このような場合には、RDF仕様の関連する規範部分を参考にすべきです。これが容易になるように、この入門書では、議論の適切な場所で、これらの他のドキュメントがRDFの完全な仕様で果たす役割を記述し、規範仕様の関連部分を指し示すリンクを提供しています。</p>

      <p class="newstuff">また、これらのRDFドキュメントが、<a name="LCC-022" id="LCC-022">以前に公開されたRDF仕様</a>である、<a href="www.w3.org/TR/1999/REC-rdf-syntax-19990222/">RDFモデルおよび構文仕様</a><a href="#ref-rdfms">[RDF-MS]</a>、およびRDFスキーマ仕様1.0<a href="#ref-rdf-s">[RDF-S]</a>を更新し、明確化していることにも注意するべきです。その結果、用語、構文、および概念にいくつかの変更がありました。この入門書は、上記で引用したRDFドキュメントの黒丸付きリストで提供されている、より新しいRDF仕様を反映します。したがって、旧仕様およびそれに基づく以前のチュートリアルや紹介記事に慣れ親しんでいた読者は、現行仕様とこれらの旧ドキュメントの間に違いがありえることを承知しているべきです。旧RDF仕様に関して提起された問題のリスト、および現行仕様でのその解決策に関しては、<a href="www.w3.org/2000/03/rdf-tracking/">RDF問題追跡</a>ドキュメント<a href="#ref-rdf-issue">[RDFISSUE]</a>を参考にすることができます。</p>

    </div>

    <div class="section">

      <h2>
<a id="statements" name="statements"></a>2. 資源に関するステートメントの作成</h2>

      <p>RDFは、ウェブ・ページなどの、ウェブ資源に関するステートメントを作成する簡単な方法を提供することを目的としてます。この項では、RDFがこれらの性能を提供する方法の背景となる基本的な考え方について記述します（これらの概念を記述する規範仕様は、<a href="www.w3.org/TR/rdf-concepts/">RDF概念および抽象構文</a><a href="#ref-rdf-concepts">[RDF-CONCEPTS]</a>です）。</p>

      <div class="section">

        <h3>
<a id="basicconcepts" name="basicconcepts"></a>2.1 基本概念</h3>

        <p>John Smithという名前の誰かが特定のウェブ・ページを作成したと述べようとしていると想像してみてください。英語などの自然言語でこれを簡単に述べると、以下のようなシンプルなステートメントの形式になるでしょう。</p>

        <p class="ptriple"><code><strong>http://www.example.org/index.html</strong>
        has a <strong>creator</strong> whose value is <strong>John Smith</strong></code></p>

        <p>事物のプロパティーを記述するためには、以下のようないくつかの事物を命名または識別する方法が必要であることを示すために、ステートメントの一部を強調しています。</p>

        <ul>
          <li>ステートメントが記述している事物（この場合、ウェブ・ページ）</li>

          <li>ステートメントが記述している事物の特定のプロパティー（この場合、creator（作者））</li>

          <li>ステートメントが述べている事物は、ステートメントが記述している事物に対するこのプロパティーの値（だれが作者か）である</li>
        </ul>

        <p>このステートメントでは、ウェブ・ページを識別するためにURL（Uniform Resource Locator）を使用しています。さらに、プロパティーを識別するために「creator」という単語を、事物（人）を識別するために「John Smith」という2つの単語を使用しています。</p>

        <p>このウェブ・ページの他のプロパティーは、ページを識別するためにはURLを、プロパティーとその値を識別するためには単語（または、他の表現）を使用し、同じ一般形式の英語のステートメントを追記することによって記述できます。例えば、ページが作成された日付（creation-date）とページが書かれた言語（language）は、ステートメントを追加して以下のように記述できます。</p>

        <p class="ptriple"><code><strong>http://www.example.org/index.html</strong>
        has a <strong>creation-date</strong> whose value is <strong>August 16,
        1999</strong></code><br>
         <code><strong>http://www.example.org/index.html</strong> has a
        <strong>language</strong> whose value is <strong>English</strong></code></p>

        <p>RDFは、記述されている事物には値を持つ<a href="www.w3.org/TR/rdf-concepts/#dfn-property">プロパティー</a>があり、上記と同様に、これらのプロパティーと値を指定するステートメントを作成することによって資源を記述できるという考えに基づいています。RDFでは、ステートメントの様々な部分に関して述べるために特別な用語を使用します。特に、ステートメントが述べている事物を識別する部分（この例では、ウェブ・ページ）を<a href="www.w3.org/TR/rdf-concepts/#dfn-subject">主語</a>と呼びます。ステートメントが指定する主語（これらの例では、作者や作成日、言語）のプロパティーや特性を識別する部分を<a href="www.w3.org/TR/rdf-concepts/#dfn-predicate">述語</a>と呼び、そのプロパティーの値を識別する部分を<a href="www.w3.org/TR/rdf-concepts/#dfn-object">目的語</a>と呼びます。したがって、英語のステートメントは以下のようになります。</p>

        <p class="ptriple"><code><strong>http://www.example.org/index.html</strong>
        has a <strong>creator</strong> whose value is <strong>John Smith</strong></code></p>

        <p>このステートメントの各部分のRDF用語は以下の通りです。</p>

        <ul>
          <li>
<dfn>主語</dfn>は<code>http://www.example.org/index.html</code>というURL</li>

          <li>
<dfn>述語</dfn>は「creator」という単語</li>

          <li>
<dfn>目的語</dfn>は「John Smith」という語句</li>
        </ul>

        <p>しかし、英語は（英語を話す）人の間でコミュニケーションをとるのには有効ですが、RDFは機械が処理できるステートメントを作成しようとしているのです。この種のステートメントを機械が処理するのに適したものにするためには、以下の2つが必要です。</p>

        <ul>
          <li>ウェブで他の誰かが使用しているかもしれない同じような識別子と少しも混同することなく、ステートメント内の主語や述語、目的語を識別するための、機械が処理できる識別子の仕組み。</li>

          <li>これらのステートメントを表現し、機械間で交換するための、機械が処理できる言語。</li>
        </ul>

        <p>幸い、既存のウェブ・アーキテクチャは、これらの必要な機能を両方とも提供してくれます。</p>

        <p>先に示したように、ウェブは、既にURL（Uniform Resource Locator）という、識別子の1つの形式を提供しています。最初の例では、John Smithが作成したウェブ・ページを識別するためにURLを使用しました。URLは、主要なアクセスのメカニズム（基本的に、そのネットワーク上の「位置」）を表現することによってウェブ資源を識別する文字列です。しかし、ウェブ・ページとは異なる、ネットワーク上の位置やURLを持たない様々な事物に関する情報を記録できるということも重要です。</p>

        <p>これらの目的のために、ウェブは、<a href="www.isi.edu/in-notes/rfc2396.txt">URI</a>（Uniform Resource Identifier）と呼ばれるより一般的な形式の識別子を提供します。URLは、URIの特定の1つの種類です。すべてのURIは、異なる人や組織が事物を識別するために別個に作成し使用できるプロパティーを共有します。しかし、URIは、ネットワーク上の位置を持っていたり、他のコンピュータのアクセス・メカニズムを使用したりする事物を識別することにのみ制限されてはいません。実際、URIは、ステートメントで参照する必要があるあらゆるものを参照するために作成できます。これには以下が含まれます。</p>
        <ul>
          <li>電子文書や画像、サービス（例えば、「ロサンゼルスの今日の天気予報」）、他の資源群などの、ネットワークでアクセスできるもの。</li>

          <li>人間や、企業、図書館の製本などの、ネットワークではアクセスできないもの。</li>

          <li>「作者」の概念などの、物理的に存在しない抽象概念。</li>
        </ul>

        <p>この一般性のために、RDFは、ステートメント内の主語、述語、および目的語を識別するためのメカニズムの基礎としてURIを使用します。より正確に言うと、RDFは<a href="www.w3.org/TR/rdf-concepts/#dfn-URI-reference">URI参照</a><a href="#ref-uri">[URIS]</a>を使用します。末尾にオプションで付く<em>フラグメント識別子</em>と合わせて、URI参照（<em>URIref</em>）はURIです。例えば、<code>http://www.example.org/index.html#section2</code>というURI参照は、<code>http://www.example.org/index.html</code>というURIと、<code>Section2</code>という（「#」という文字で区切られた）フラグメント識別子で構成されています。RDFのURIrefは、ユニコード<a href="#ref-unicode">[UNICODE]</a>の文字を含むことができ（<a href="#ref-rdf-concepts">[RDF-CONCEPTS]</a>を参照）、これによって多くの言語をURIrefに反映できます。RDFは<em>資源</em>をURI参照で識別できるものと定義しているため、URIrefを使用するとRDFは実際に何でも記述でき、そのような事物の間の関係を述べることができます。URIrefとフラグメント別子に関しては、<a href="#identifiers">付録A</a>と<a href="#ref-rdf-concepts">[RDF-CONCEPTS]</a>で、より詳細に論じます。</p>

        <p>機械が処理できる方法でRDFステートメントを表現するために、RDFは<a href="www.w3.org/TR/2000/REC-xml-20001006">XML</a>（Extensible Markup Language）<a href="#ref-xml">[XML]</a>を使用します。XMLは、誰もが自身のドキュメント形式を設計し、その形式でドキュメントを書くことができるようにするために設計されました。RDF情報を表現する際に使用し、それを機械間で交換するために、RDFは、RDF/XMLと呼ばれる特定のXMLマークアップ言語を定義しています。RDF/XMLの例は、<a href="#intro">第1項</a>で示しました。その例（<a href="#example1">例1</a>）では、それぞれ<code>Eric Miller</code>や<code>Dr.</code>というテキスト・コンテンツを区切るために、<code>&lt;contact:fullName&gt;</code>や<code>&lt;contact:personalTitle&gt;</code>などのタグを使用しました。このようなタグによって、タグの意味を理解して書かれたプログラムがそのコンテンツを適切に解釈できるようになります。XMLコンテンツと（いくらかの例外があるが）タグの両方は、ユニコード<a href="#ref-unicode">[UNICODE]</a>の文字を含むことができ、これによって多くの言語による情報を直接表現できるようになります。<a href="#documents">付録B</a>では、一般的なXMLの背景の詳細を提供しています。RDFに使用される特定のRDF/XML構文の詳細は<a href="#rdfxml">第3項</a>で記述されており、<a href="#ref-rdf-syntax">[RDF-SYNTAX]</a>で規範的に定義されています。</p>
      </div>

      <div class="section">

        <h3>
<a id="rdfmodel" name="rdfmodel"></a>2.2 RDFモデル</h3>

        <p><a href="#basicconcepts">2.1項</a>では、RDFのステートメントの基本概念、RDFステートメントで参照された事物を識別するためにURI参照を使用するという考え、および、RDFステートメントを表現するために機械が処理できる方法としてのRDF/XMLを紹介しました。このような背景のもと、この項では、RDFがどのようにURIを使用して資源に関するステートメントを作成するかを述べます。「はじめに」では、RDFは資源に関するシンプルなステートメントを表現するという考えに基づいており、各ステートメントは主語、述語、目的語で構成される、と述べました。RDFでは、以下の英語のステートメント</p>
        <p class="ptriple"><code><strong>http://www.example.org/index.html</strong>
        has a <strong>creator</strong> whose value is <strong>John Smith</strong></code></p>

        <p>は、以下を有するRDFステートメントで表わすことができます。</p>

        <ul>
          <li>主語 <code>http://www.example.org/index.html</code>
</li>

          <li>述語 <code>http://purl.org/dc/elements/1.1/creator</code>
</li>

          <li>目的語 <code>http://www.example.org/staffid/85740</code>
</li>
        </ul>

        <p>最初のステートメントの主語だけではなく述語や目的語を識別するために、それぞれ「creator」や「John Smith」という語を使用する代わりに、どのようにURIrefを使用するかに注意してください（この方法でURIrefを使用した場合の効果の一部に関しては、この項の後部で論じます）。</p>

        <p>RDFは、ステートメントをグラフ内のノードとアークとしてモデル化します。RDFの<a href="www.w3.org/TR/rdf-concepts/#section-data-model">グラフのモデル</a>は、<a href="#ref-rdf-concepts">[RDF-CONCEPTS]</a>で定義されています。その表記では、ステートメントは以下のもので表現されます。</p>

        <ul>
          <li>主語を表わすノード</li>

          <li>目的語を表わすノード</li>

          <li>主語のノードから目的のノードへ向けられた、述部のアーク。</li>
        </ul>

        <p>したがって、上記のRDFステートメントは、<a href="#figure2">図2</a>で示すグラフで表されます。</p>

        <div class="figure">
          <img src="www.asahi-net.or.jp/~ax2s-kmtn/internet/rdf/fig2dec16.png" alt="シンプルなRDFステートメント"><br>
           <a id="figure2" name="figure2">図2: シンプルなRDFステートメント</a>
        </div>

        <p>ステートメントのグループは、対応するノードとアークのグループによって表現されます。そのため、以下の英語ステートメントをさらにRDFグラフに反映させるには、</p>

        <p class="ptriple"><code><strong>http://www.example.org/index.html</strong>
        has a <strong>creation-date</strong> whose value is <strong>August 16,
        1999</strong></code><br>
         <code><strong>http://www.example.org/index.html</strong> has a
        <strong>language</strong> whose value is <strong>English</strong></code></p>

        <p><a href="#figure3">図3</a>で示されたグラフを使用できます（適切なURIrefを使用して「creation-date」（作成日）や「language」（言語）のプロパティーを命名)。</p>

        <div class="figure">
          <img src="www.asahi-net.or.jp/~ax2s-kmtn/internet/rdf/fig3nov19.png" alt="同じ資源に関する数個のステートメント"><br>
           <a id="figure3" name="figure3">図3: 同じ資源に関する数個のステートメント</a>
        </div>

        <p><a href="#figure3">図3</a>では、ある種のプロパティー値を表現するためには、RDFステートメント内の目的語が、URIrefか、文字列によって表現される定数値（<a href="www.w3.org/TR/rdf-concepts/#section-Literals">リテラル</a>と呼ばれる）かのどちらかでありえることを示しています。（<code>http://purl.org/dc/elements/1.1/language</code>という述語の場合、リテラルは2文字の英語の国際標準コードです。）RDFステートメントでは、リテラルを主語や述語として使用できません。RDFグラフを描く時には、URIrefであるノードは楕円で表示され、リテラルであるノードは四角で表示されます。（これらの例で使用されているシンプルな文字列のリテラルは、<a href="#typedliterals">2.4項</a>で紹介する<a href="www.w3.org/TR/rdf-concepts/#dfn-typed-literal">型付きリテラル</a>と区別するために、<a href="www.w3.org/TR/rdf-concepts/#dfn-plain-literal">プレーン・リテラル</a>と呼びます。RDFステートメントで使用できる様々な種類のリテラルは<a href="#ref-rdf-concepts">[RDF-CONCEPTS]</a>で定義されています。プレーン・リテラルと型付きリテラルは両方ともユニコード<a href="#ref-unicode">[UNICODE]</a>の文字を含むことができ、これによって多くの言語による情報を直接表現できるようになります。）</p>

        <p>これらを議論する際にグラフを描くのが便利でないことがあるため、<a href="www.w3.org/TR/rdf-concepts/#dfn-rdf-triple">トリプル</a>と呼ばれる、ステートメントを記述する別の方法も使用されます。トリプルの表記では、グラフの各ステートメントは、主語、述語、目的語の順序のシンプルなトリプルで記述されます。例えば、<a href="#figure3">図3</a>で示されている3つのステートメントは、以下のようなトリプルの表記で記述されます。</p>

        <div class="exampleOuter exampleInner">
<pre>
&lt;http://www.example.org/index.html&gt; &lt;http://purl.org/dc/elements/1.1/creator&gt; &lt;http://www.example.org/staffid/85740&gt; .

&lt;http://www.example.org/index.html&gt; &lt;http://www.example.org/terms/creation-date&gt; "August 16, 1999" .

&lt;http://www.example.org/index.html&gt; &lt;http://purl.org/dc/elements/1.1/language&gt; "en" .
</pre>
        </div>

        <p>各トリプルは、グラフ内の1つのアークに対応し、アークの最初と最後のノード（ステートメント内の主語と目的語）を完備しています。描かれたグラフとは異なり（しかし、最初のステートメントと同様に）、トリプルの表記では、ノードは、それが表示されるステートメントごとに別々に識別される必要があります。そのため、例えば、<code>http://www.example.org/index.html</code>は、グラフのトリプル表現では3度（各トリプルで1度）表示されますが、描かれたグラフでは1度しか表示されません。しかし、トリプルは、描かれたグラフと同じ情報を表します。この点が重要で、RDFの基本は、ステートメントの<em>グラフ・モデル</em>であり、グラフを表したり描いたりするために使用される表記は、二次的なものです。</p>

        <p>完全なトリプル表記では、URI参照をアングルブラケット内に完て書き出す必要があり、上例が示すように、非常に長い行になりえます。便宜上、この入門書ではトリプルの記述に省略形を使用します（他のRDF仕様でも同じ省略形が使用される）。この省略形では、アングルブラケットなしのXMLの<em>修飾名</em>（または、<em>QName</em>）を完全なURI参照の省略形として代用します（QNameに関する詳細は、付録Bで論じます）。QNameには、名前空間URIに割り当てられた<em>接頭辞</em>が含まれ、その後にコロン、そして<em>ローカル名</em>が続きます。完全なURIrefは、接頭辞に割り当てられた名前空間URIにローカル名を加えたQNameで形成されます。そのため、例えば、QNameの接頭辞<code>foo</code>が名前空間URI <code>http://example.org/somewhere/</code>に割り当てられている場合、QName <code>foo:bar</code>がURIref <code>http://example.org/somewhere/bar</code>の省略形ということになります。入門書の例では、以下に定める、いくつかの「よく知られている」（well-known）QName接頭辞も（毎回、明示的に指定せずに）使用されます。<br>
        <br>
         接頭辞 <code>rdf:</code>、名前空間 URI:
        <code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code><br>
         接頭辞 <code>rdfs:</code>、名前空間 URI:
        <code>http://www.w3.org/2000/01/rdf-schema#</code><br>
         接頭辞 <code>dc:</code>、名前空間 URI:
        <code>http://purl.org/dc/elements/1.1/</code><br>
         接頭辞 <code>owl:</code>、名前空間 URI:
        <code>http://www.w3.org/2002/07/owl#</code><br>
         接頭辞 <code>ex:</code>、名前空間 URI:
        <code>http://www.example.org/</code>（または、
        <code>http://www.example.com/</code>）<br>
         接頭辞 <code>xsd:</code>、名前空間 URI:
        <code>http://www.w3.org/2001/XMLSchema#</code></p>

        <p>必要に応じて、「例」の接頭辞<code>ex:</code>を明らかに変形したものを、例で使用します。例えば、<br>
        <br>
         接頭辞 <code>exterms:</code>、名前空間 URI:
        <code>http://www.example.org/terms/</code>（例示した組織が使用している用語用）、<br>
         接頭辞 <code>exstaff:</code>、名前空間 URI:
        <code>http://www.example.org/staffid/</code>（例示した組織のスタッフの識別子用）、<br>
         接頭辞 <code>ex2:</code>、名前空間 URI:
        <code>http://www.domain2.example.org/</code>（二番目に例示した組織用）、など。</p>

        <p>前述のトリプルの集合は、この新しい省略形を使用して以下のように書くこともできます。</p>

        <div class="exampleOuter exampleInner">
<pre>
ex:index.html  dc:creator             exstaff:85740 .

ex:index.html  exterms:creation-date  "August 16, 1999" .

ex:index.html  dc:language            "en" .
</pre>
        </div>

<div class="newstuff">

<p>RDFは、ステートメントで事物を命名するための単語の代わりにURIrefを使用する<a name="LCC-012b" id="LCC-012b">ため</a>、RDFでは1組のURIref（特に、特定の目的用の1組）を<em>語彙</em>と呼びます。しばしば、このような語彙のURIrefは、共通の接頭辞を使用する1組のQNameとして表現できるように組織化されています。すなわち、語彙のすべての用語に対して1つの共通の名前空間URIrefが選択されます（通常は、語彙を定義している人の管理下にあるURIref）。語彙に含まれているURIrefは、個々のローカル名を共通のURIrefの末端に追加することによって形成されます。このように、共通の接頭辞を持つ1組のURIrefを形成します。例えば、前の例で示したように、example.orgなどの組織は、「creation-date」や「product」（製品）などの、事業で使用する用語に対して接頭辞<code>http://www.example.org/terms/</code>で始まるURIrefで構成される語彙を定義できますし、従業員を識別するために接頭辞<code>http://www.example.org/staffid/</code>で始まるURIrefの別の語彙を定義できます。RDFは、これと同じアプローチを使用して、RDFで特別な意味を持つ独自の用語を定義します。このRDF語彙内のURIrefは、すべて<code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code>で始まります（慣習的にQName接頭辞<code>rdf:</code>に関連づけられている）。RDF語彙記述言語（<a href="#rdfschema">5項</a>で述べる）は、<code>http://www.w3.org/2000/01/rdf-schema#</code>で始まるURIrefを持つ1組の用語を追加定義します（慣習的にQName接頭辞<code>rdfs:</code>に関連づけられている）。（ここでは、特定のQName接頭辞は、このような方法で、ある1組の用語と関連して共通的に使用され、時にはQName接頭辞自体が語彙の名前として使用されることがあります。例えば、誰かが「<code>rdfs:</code>語彙」を参照できます。</p> 

<p>共通のURI接頭辞を使用すると、関連する一連の用語に対してURIrefを便利に組織化できます。しかし、これは単なる慣習にすぎません。RDFモデルは、完全なURIrefを認識するだけで、URIrefの「内部を見たり」、構造に関する知識を使用したりはしません。特にRDFでは、URIrefの先頭に共通の接頭辞があるというだけでは、URIref間に関係があるとは仮定しません（さらなる議論に関しては<a href="#identifiers">付録A</a>を参照）。さらに、先頭の接頭辞が異なっているURIrefは同じ語彙の一部であると見なせないとも言えません。特定の組織、プロセス、ツールなどでは、他の語彙のURIrefを自身の語彙の一部として好きなだけ使用して、自身にとって有効な語彙を定義できます。</p>

<p>さらに、ある組織では、その語彙に関する追加情報を提供してくれるウェブ資源のURLとして語彙の名前空間URIrefを使用することもあるでしょう。例えば、以前に指摘したように、QName接頭辞<code>dc:</code>は、入門書の例では、名前空間URI<code>http://purl.org/dc/elements/1.1/</code>に関連づけられて使用されるでしょう。実際には、これは<a href="#dublincore">6.1項</a>で述べるダブリン・コアの語彙を指します。ウェブ・ブラウザでこの名前空間URIrefにアクセスすると、ダブリン・コアの語彙に関する追加情報が検索されるでしょう（具体的には、RDFスキーマ）。しかし、これも単なる慣習にすぎません。RDFでは、名前空間URIが検索可能なウェブ資源を識別することを前提としていません（さらなる議論に関しては<a href="#documents">付録B</a>を参照）。</p>

<p>入門書の残りの部分では、RDF自体で使用するために定義された一連のURIrefや、従業員を識別するためにexample.orgが定義した一連のURIrefなどのような、ある特定の目的のために定義された一連のURIrefを参照する時に、<em>語彙</em>（vocabulary）という用語を使用します。<em>名前空間</em>（namespace）という用語は、XML名前空間の構文上の概念を特別に参照する時にのみ（あるいは、QNameの接頭辞に割り当てられたURIを記述する時に）、使用します。</p>

<p>RDFグラフには、様々な語彙のURIrefを自由に混ぜ入れることができます。例えば、<a href="#figure3">図3</a>のグラフでは、<code>exterms:</code>や、<code>exstaff:</code>、<code>dc:</code>語彙のURIrefを使用しています。また、RDFでは、同じ資源を記述するために、あるURIrefを述語として使用したステートメントをグラフにいくつ出現させることができるかに全く制限がありません。例えば、<code>ex:index.html</code>という資源が、John Smithと数人のスタッフの協力で作成されている場合、example.orgは以下のステートメントを作成するでしょう。</p>

        <div class="exampleOuter exampleInner">
<pre>
ex:index.html  dc:creator  exstaff:85740 .

ex:index.html  dc:creator  exstaff:27354 .

ex:index.html  dc:creator  exstaff:00816 .
</pre>
        </div>

</div>

        <p>RDFステートメントに関するこれらの例では、RDFが事物を識別する基本的な手段としてURIrefを使用するいくつかの利点を示しています。例えば、最初のステートメントの場合、「John Smith」という文字列でウェブ・ページの作者を識別する代わりに、（彼の従業員番号に基づくURIrefを使用して）<code>http://www.example.org/staffid/85740</code>というURIrefを彼に割り当てていまあう。この場合のURIrefを使用する利点は、ステートメントの主語をより正確に識別できるということです。すなわち、ページの作者は、「John Smith」という文字列でも、何千人もいるJohn Smithという名前の誰かでもなく、そのURIrefに関連づけられている特定のJohn Smithだということです（URIrefを作成した人は誰でもこの関係を定義する）。そのうえ、John Smithを参照するURIrefがあるため、彼は完全な資源であり、JohnのURIrefを主語として持つRDFステートメントを追加するだけで、彼に関する追加情報を記録できます。例えば、<a href="#figure4">図4</a>では、Johnの名前と年令を示すいくつかの追加ステートメントを示しています。</p>

        <div class="figure">
          <img src="www.asahi-net.or.jp/~ax2s-kmtn/internet/rdf/fig4dec16.png" alt="John Smithに関する追加情報"><br>
           <a id="figure4" name="figure4">図4: John Smithに関する追加情報</a>
        </div>

        <p>この例では、RDFステートメントにおいてRDFがURIrefを<em>述語</em>（predicates）として使用するということも示しています。 すなわち、プロパティーを識別するために、RDFでは「creator」や「name」（名前）などの文字列（または、単語）を使用するのではなく、URIrefを使用します。プロパティーを識別するためにURIrefを使用することは、様々な理由で重要です。第一に、自分が使用するプロパティーと、URIrefを使用しなければ同じ文字列で識別されてしまう他の誰かが使用するプロパティーとを区別できす。例えば、<a href="#figure4">図4</a>の例では、example.orgは、文字列リテラルとしてすべて書き出した誰かのフルネーム（例えば、「John Smith」）を意味するために「name」を使用していますが、他の誰かが何か別のもの（例えば、プログラム・テキストの断片の変数名）を意味するために「name」を使用することもできます。プロパティー識別子としての「name」にウェブ上で遭遇した（あるいは、複数の情報源のデータを統合した）プログラムは、必ずしもこれらの用途を区別できるわけではないでしょう。しかし、example.orgが「name」プロパティーに<code>http://www.example.org/terms/name</code>を使用し、他の人が自分の「name」プロパティーに<code>http://www.domain2.example.org/genealogy/terms/name</code>を使用した場合、（プログラムが自動的に別々の意味であると判断できなくても）別々のプロパティーが関係していることは明らかです。また、プロパティーを識別するためにURIrefを使用することにより、プロパティーを資源自体として扱うことができるようになります。プロパティーは資源であるため、プロパティーのURIrefを主語として持ったRDFステートメントを追加するだけで、そのプロパティーに関する追加情報を記録できます（例えば、example.orgでは「name」が何を意味するかの英語の記述）。</p>

        <p>RDFステートメントでURIrefを主語や述語、目的語として使用すれば、ウェブ上の共通語彙を開発し使用できます。なぜならば、他の人が既に使用している語彙を発見して使用することで、その概念の共通認識を反映した事物を記述できるからです。例えば、以下のトリプル</p>

        <div class="exampleOuter exampleInner">
<pre>
ex:index.html   dc:creator   exstaff:85740 .
</pre>
        </div>

        <p>では、<code>dc:creator</code>という述語は、URIrefとして完全に展開すれば、ダブリン・コア・メタデータ属性セット（詳細は<a href="#dublincore">6.1項</a>で論じる）内の「creator」属性を一意に参照します。ダブリン・コア・メタデータ属性セットとは、あらゆる種類の情報を記述するために広く用いられている属性（プロパティー）の集合のことです。このトリプルの作者は、ウェブ・ページ（<code>http://www.example.org/index.html</code>で識別される）とページの作者（<code>http://www.example.org/staffid/85740</code>で識別される別個の人物）との関係は、まさに<code>http://purl.org/dc/elements/1.1/creator</code>で識別される概念であるということを効果的に述べています。<span class="newstuff"><a name="LCC-010" id="LCC-010">ダブリン・コア</a>の語彙をよく知っている人や、<code>dc:creator</code>が何を意味するかを見つけた人は（例えば、ウェブ上でその定義を調べることによって）、この関係が何を意味するかが分かるでしょう。さらに、この理解に基づいて、<code>dc:creator</code>という述語を含むトリプルを処理する際には、その意味に従って動作するようにプログラムを書くことができます。</span></p>

<p><span class="newstuff"><a name="LCC-009" id="LCC-009">もちろん、</a>そのためには、リテラルを使用するのではなく、もっとURIrefを一般的に使用して事物を参照する必要があります。例えば、<code>John Smith</code>や<code>creator</code>のような文字列リテラルではなく、<code>exstaff:85740</code>や<code>dc:creator</code>のようにURIrefを使用します。</span>そのような場合でも、RDFがURIrefを使用すれば識別の問題がすべて解決されるわけではありません。なぜならば、例えば、同じ事物を参照するのに別のURIrefを使用することが依然として可能であるからです。このような理由で、他の語彙と重複するかもしれない新しい用語を作るよりも、可能であれば、既存の語彙（ダブリン・コアのような）の用語を使用する方が良いでしょう。<a href="#applications">6項</a>で述べるアプリケーションで示しているように、特定のアプリケーション領域での使用に適した語彙が絶えず開発されています。しかし、同義語が作成されても、これらの別々のURIrefは共通にアクセスできる「ウェブ・スペース」で使用されるため、これらの別々の参照間の同等性を識別するだけでなく、共通の参照を使用する方向に移行することも可能です。</p>

<div class="newstuff">
<p>さらに、<em>RDF自体</em>がRDFステートメントで使用される用語（前例の<code>dc:creator</code>のような）に関連づけている意味と、人（または、これらの人が書いたプログラム）がそれらの用語に関連づけているかもしれない付加的な、<em>外部で定義された</em>意味とを区別することが重要です。RDFは、言語として、主語、述語、目的語のトリプルのグラフ構文、<code>rdf:</code>語彙内のURIrefに関連づけられた特定の意味、および後述する特定のその他の概念、のみを直接定義します。これらは、<a href="#ref-rdf-concepts">[RDF-CONCEPTS]</a>および<a href="#ref-rdf-semantics">[RDF-SEMANTICS]</a>で規範的に定義されています。しかし、RDFでは、<code>dc:creator</code>のような、RDFステートメントで使用できる他の語彙の用語の意味は定義していません。特定の語彙は、その語彙内で定義されているURIrefに特定の意味を割り当てて、RDFの外部で作成されるでしょう。この語彙のURIrefを使用したRDFステートメントは、これらの用語に関連づけられている特定の意味を、その語彙を処理するように特別に書かれて<em>いない</em>任意のRDFアプリケーションには伝えずに、この語彙に慣れている人々や、この語彙を処理するように書かれているRDFアプリケーションに伝えることができます。</p>

        <p>例えば、人は意味を以下のようなトリプルと関連付けることができます。</p>

        <div class="exampleOuter exampleInner">
<pre>
ex:index.html  dc:creator  exstaff:85740 .
</pre>
        </div>

        <p>これは、人がURIref <code>dc:creator</code>の一部として「creator」という単語の出現と関連づけた意味に基くか、ダブリン・コア語彙の<code>dc:creator</code>の特定の定義に関する人の理解に基いています。しかし、任意のRDFアプリケーションに関する限り、また、組み込み済みの意味に関する限り、トリプルは以下のようになる方が良いでしょう。</p>

        <div class="exampleOuter exampleInner">
<pre>
fy:joefy.iunm  ed:dsfbups  fytubgg:85740 .
</pre>
        </div>

         <p>同様に、ウェブ上にある<code>dc:creator</code>の意味を記述した自然言語テキストは、任意のRDFアプリケーションが直接使用できる付加的な意味を全く提供しません。</p>
<p>もちろん、特定のアプリケーションが特別な意味を少しもURIrefに関連付けることができなくても、RDFステートメントでは特定の語彙のURIrefを使用できます。例えば、一般的なRDFソフトウェアは、上記の表現がRDFステートメントであり、<code>ed:dsfbups</code>は述語であるといったことを認識するでしょう。このRDFソフトウェアは、語彙の開発者が<code>ed:dsfbups</code>のようなURIrefに関連付けることができたかもしれない特別な意味を全くトリプルに関連づけないでしょう。そのうえ、たとえそのように書かれていないRDFアプリケーションではその意味にアクセスしづらいとしても、人は、特定の語彙に関する理解に基づいて、その語彙のURIrefに割り当てられた特別な意味に従って動作するようにRDFにアプリケーションを書くことができます。</p> 

</div>

        <p>以上をまとめると、RDFは、アプリケーションをより簡単に処理できるステートメントを作成する方法を提供するということです。既に指摘したように、<span class="newstuff"><code>SELECT NAME FROM EMPLOYEE WHERE SALARY &gt; 35000</code>（3万5千ドル以上の給与の従業員の中から名前を選択せよ）のようなクエリーを処理する際に「従業員」や「給料」のような用語をデータベース・システムが「理解」できないのと同じように、アプリケーションはこのようなステートメントを実際には「理解」できません。</span>しかし、アプリケーションが適切に作成されていれば、<span class="newstuff">データベース・システムとそのアプリケーションが「従業員」と「給料」を理解せずに従業員と給料の情報を処理しても効果的に作業ができるのとちょうど同じように、これらを理解しているかのような方法でRDFステートメントを処理できます。</span>例えば、あるユーザがすべての書評をウェブで検索し、それぞれの本に対する平均格付けを作成できれば、そのユーザは、その情報をまたウェブに掲載できます。別のウェブサイトでは、この本の格付け平均のリストを取って来て、「トップ10にランクインした本」のページを作成できます。ここでは、格付けに関する共通語彙の有用性と利用方法、そして格付けを適用する本を識別するURIrefの共有グループにより、各個人が相互理解を持ち、ますます強力な（さらなる貢献がなされるため）、本に関するウェブ上の「情報ベース」を構築できるようになります。何千もの主題に関してウェブ上で日々作成されている膨大な情報に対しても同じ原理を適用できます。</p>

        <p>RDFステートメントは、以下のような、情報を記録するための他の多くの形式に似ています。</p>

        <ul>
          <li>簡単な記録のエントリーやデータ処理システムの資源を記述しているカタログ・リスト。</li>

          <li>簡単なリレーショナル・データベースの列。</li>

          <li>形式論理における簡単な言明</li>
        </ul>

        <p>そして、これらの形式の情報をRDFステートメントとして扱うことができ、これによって、多くの情報源のデータをRDFを使用して統合できるようになります。</p>

      </div>

      <div class="section">

        <h3>
<a id="structuredproperties" name="structuredproperties"></a>2.3 構造化されたプロパティー値と空白ノード</h3>

        <p>記録すべき事物に関する情報の種類が、今までに示したシンプルなRDFステートメント形式でしかありえないのならば、話はとても簡単でしょう。しかし、実際の世界では、少なくとも表面的には、ほとんどのデータがそれより複雑な構造を伴っています。例えば、最初の例では、ウェブ・ページが作成された日付は、その値としてプレーン・リテラルを持つ、1つの<code>exterms:creation-date</code>プロパティーとして記録されています。しかし、<code>exterms:creation-date</code>プロパティーの値の月や日、年を別々の情報として記録する必要があると仮定してください。あるいは、John Smithの個人情報の事例に、Johnの住所が記述されていたと仮定してください。この場合、以下のトリプルのように、住所全体をプレーン・リテラルとしてすべて書き出すことができます。</p>

        <div class="exampleOuter exampleInner">
<pre>
exstaff:85740   exterms:address   "1501 Grant Avenue, Bedford, Massachusetts 01730" .
</pre>
        </div>

        <p>しかし、Johnの住所を、通りや市、州、郵便番号という別々の値から成る<em>構造体</em>として記録する必要があると仮定してください。RDFでは、これをどのように行えれば良いでしょうか?</p>

        <p>RDFでは、このような構造化された情報を、記述する事物の集合を資源と見なして（John Smithの住所のように）、この新しい資源に関するステートメントを作成することによって表現します。そのため、RDFグラフでは、John Smithの住所を構成要素に分解するために、新しいノードを作成してJohn Smithの住所の概念を表現し、例えば<code>http://www.example.org/addressid/85740</code>（<code>exaddressid:85740</code>と略される）のように、この概念を新しいURIrefで識別します。その後、このノードを主語にしたRDFステートメント（追加アークおよびノード）を作成して追加情報を表現でき、<a href="#figure5">図5</a>で示すグラフを作成します。</p>

        <div class="figure">
          <img src="www.asahi-net.or.jp/~ax2s-kmtn/internet/rdf/fig5may19.png" alt="Johnの住所の分解"><br>
           <a id="figure5" name="figure5">図5: Johnの住所の分解</a>
        </div>

        <p>あるいは、トリプルでは以下のようになります。</p>

        <div class="exampleOuter exampleInner">
<pre>
exstaff:85740       exterms:address        exaddressid:85740 .
exaddressid:85740   exterms:street         "1501 Grant Avenue" .
exaddressid:85740   exterms:city           "Bedford" .
exaddressid:85740   exterms:state          "Massachusetts" .
exaddressid:85740   exterms:postalCode     "01730" .</pre>
        </div>

        <p>このような方法で、構造化された情報をRDFで表現すると、Johnの住所などの集合概念を表現するために、<code>exaddressid:85740</code>などの多数の「中間の」URIrefが発生します。このような概念を特定のグラフ外から直接参照する必要はなく、したがって、「ユニバーサルな」識別子は必要ないかもしれません。さらに、<a href="#figure5">図5</a>のステートメント群を表現するグラフを<em>描く</em>時には、<a href="#figure6">図6</a>のグラフのように簡単に描くことができるため、「John Smithの住所」を識別するために割り当てたURIrefは、実際には必要ではありません。</p>

        <div class="figure">
          <img src="www.asahi-net.or.jp/~ax2s-kmtn/internet/rdf/fig6may19.png" alt="空白ノードの使用"><br>
           <a id="figure6" name="figure6">図6: 空白ノードの使用</a>
        </div>

        <p>完璧なRDFグラフである<a href="#figure6">図6</a>では、「John Smithの住所」の概念を表わすためにURIrefがないノードを使用しています。ノード自体がグラフの別々の部分の間に必要な接続性を提供するため、この<a href="www.w3.org/TR/rdf-concepts/#dfn-blank-node">空白ノード</a>は、URIrefを使用せずに描くという目的を果たします。（<a href="#ref-rdfms">[RDF-MS]</a>では空白ノードを<em>匿名資源</em>（anonymous resource）と呼びます。） しかし、このグラフをトリプルとして表現するためには、このノードに対する明示的な識別子の形式が必要です。これを理解するために、<a href="#figure6">図6</a>で示した内容に対応したトリプルを書いてみると、以下のようになるでしょう。</p>

        <div class="exampleOuter exampleInner">
<pre>
exstaff:85740   exterms:address         ??? .
???             exterms:street          "1501 Grant Avenue" .
???             exterms:city            "Bedford" .
???             exterms:state           "Massachusetts" .
???             exterms:postalCode      "01730" .
</pre>
        </div>

        <p>ここでは、???は空白ノードの存在を意味します。複雑なグラフには1つ以上の空白ノードを含むことができるため、グラフのトリプル表現では、これらの異なる空白ノードを区別する方法も必要になります。その結果、トリプルでは、<code>_:name</code>の形式を持つ<a href="www.w3.org/TR/rdf-concepts/#dfn-blank-node-id">空白ノード識別子</a>を使用して空白ノードの存在を示します。例えば、この例では<code>_:johnaddress</code>という空白ノード識別子を使用して空白ノードを参照でき、その結果、トリプルは以下の通りになります。</p>

        <div class="exampleOuter exampleInner">
<pre>
exstaff:85740   exterms:address         _:johnaddress .
_:johnaddress   exterms:street          "1501 Grant Avenue" .
_:johnaddress   exterms:city            "Bedford" .
_:johnaddress   exterms:state           "Massachusetts" .
_:johnaddress   exterms:postalCode      "01730" .
</pre>
        </div>

        <p>グラフのトリプル表現では、グラフ中のそれぞれ別個の空白ノードには別個の空白ノード識別子が与えられます。URIrefやリテラルとは異なり、空白ノード識別子はRDFグラフの実際の部分とは考えられません（これは、<a href="#figure6">図6</a>のグラフを見たり、空白ノードには空白ノード識別子がないということに注意すれば理解できます）。 空白ノード識別子は、グラフがトリプル形式で書かれている場合は、グラフで空白ノードを表現する（そして、1つの空白ノードを別の空白ノードと区別する）方法の1つにすぎません。また、空白ノード識別子は、<em>1つの</em>グラフを表現しているトリプル内でのみ意味を持ちます（同じ数の空白ノードを持つ2つの別個のグラフでは、独自に同じ空白ノード識別子を使用して区別し、同じ空白ノード識別子を持つ別々のグラフに属する空白ノードが同じであると見なすのは間違いでしょう）。グラフ外からグラフのノードを参照する必要がありえる場合には、グラフを識別するためにURIrefを割り当てるべきです。最後に、空白ノード識別子は、RDFグラフのトリプル形式は、アークではなく（空白）<em>ノード</em>を表現するので、空白ノード識別子はトリプルでは主語または目的語としてのみ現れます。つまり、トリプルでは、空白ノード識別子を述語として使用してはなりません。</p>

        <p>この項の冒頭では、John Smithの住所のように、記述する事物の集合を1つの別個の資源と見なし、この新しい資源に関するステートメントを作成することによって、集合構造を表現すことができると指摘しました。この例では、RDFの重要な側面を示します。それは、RDFは、例えばJohn Smithと彼の住所を表現しているリテラルとの関係などの、<em>2項</em>関係のみを直接表現するということです。Johnとこの住所の別々の<em>構成要素</em>のグループとの関係を表現する場合には、Johnと通りや市、州、郵便番号の構成要素とのn項（n方向）関係（この場合、n=5）を扱う必要があります。このような構造をRDFで直接表現するためには（例えば、住所が、通り、市、州、郵便番号の構成要素のグループであると見なして）、このn方向関係を別々の2項関係のグループに分解しなければなりません。空白ノードは、これを行う方法を提供します。それぞれのn項関係に対して、関係しているものの1つをその関係の主語として選び（この場合、John）、空白ノードを作成して残りの関係（この場合、Johnの住所）を表現します。そして、関係の残り（この例では、都市など）を、空白ノードで表現されている新しい資源の別々のプロパティーとして表現します。</p>

        <p>空白ノードは、URIを持たない資源に関するステートメントをより正確に作成する方法も提供しますが、これはURIを<em>持つ</em>他の資源との関係で記述されます。例えば、人に関するステートメントを作成する場合（例えばJane Smith）、この人の電子メール・アドレスに基づくURI（例えば、<code>mailto:jane@example.org</code>）を彼女のURIとして使用するのが自然でしょう。しかし、この方法は問題を引き起こしかねません。例えば、<em>Janeジェーン自身</em>に関する情報（例えば、彼女の物理的な現住所）だけでなく、<em>Janeのメールボックス</em>（例えば、それが置かれているサーバ）に関する情報も記録する必要があって、彼女の電子メール・アドレスに基づいてJaneにURIrefを使用すると、それがJaneなのか記述されている彼女のメールボックスなのかを区別するのが難しくなります。会社のウェブ・ページのURL（例えば、<code>http://www.example.com/</code>）を会社自体のURIとして使用している場合にも、同じ問題が存在しています。この場合も、会社に関する情報だけでなく、ウェブ・ページ自体に関する情報（例えば、誰がいつ作成した）も記録する必要があって、この両者に対する識別子として<code>http://www.example.com/</code>を使用すると、これらのどちらが実際の主語であるかを区別するのが難しくなります。</p>

        <p>根本的な問題は、<em>Jane</em>の代わりにJaneの<em>メールボックス</em>を使用するのはあまり正確でないということです。つまり、Janeと彼女のメールボックスは同じものではないため、別々に識別されるべきです。Jane自身がURIを持っていない場合には、空白ノードを使ってこの状況をより正確にモデル化できます。Janeを空白ノードで表現し、値としてURIref <code>mailto:jane@example.org</code>を持っている<code>exterms:mailbox</code>プロパティーを持つステートメントの主語としてその空白ノードを使用できます。以下のトリプルで示しているように、空白ノードは、<code>exterms:Person</code>という値を持つ<code>rdf:type</code>プロパティー（型の詳細については、次項で論じる）や、<code>「Jane Smith」</code>という値を持つ<code>exterms:name</code>プロパティー、その他の有用な記述情報を用いても記述できます。</p>

        <div class="exampleOuter exampleInner">
<pre>
_:jane   exterms:mailbox   &lt;mailto:jane@example.org&gt; .
_:jane   rdf:type          exterms:Person .
_:jane   exterms:name      "Jane Smith" .
_:jane   exterms:empID     "23748"  .
_:jane   exterms:age       "26" .
</pre>
        </div>

        <p>（最初のトリプルでは<code>mailto:jane@example.org</code>がアングルブラケット内に記述されていることに注意してください。これは、<code>mailto:jane@example.org</code>が、QNameの省略形ではなく、<code>mailto</code> URLスキームにおける完全なURIrefであり、完全なURIrefはトリプル表記法ではアングルブラケットで囲み込まなければならないからです。）</p>

        <p>これは、実際には、「型<code>exterms:Person</code>の資源があり、その電子メールボックスが<code>mailto:jane@example.org</code>で、その名前が<code>Jane Smith</code>で識別される、など」ということを示しています。つまり、この空白ノードは「資源がある」と読むことができます。その空白ノードを主語として持つステートメントは、その資源の特性に関する情報を提供します。</p>

        <p>実際には、これらの事例でURIrefではなく空白ノードを使用したとしても、この種の情報を処理する方法はあまり変わりません。例えば、ある電子メールアドレスがexample.orgに属している人物を一意に識別すると分かっている場合（特に、アドレスが再利用される可能性がない場合）、その電子メールアドレスがその人のURIでなかったとしても、複数の情報源からその人に関する情報を関連付けるためにこの事実を使用できます。この場合、ある本について記述したRDFがウェブ上にあり、その著者の問い合わせ先を<code>mailto:jane@example.org</code>として提供している場合、この新しい情報を前のトリプルの集合と組み合わせて、その著者の名前はJane Smithであると結論づけることは合理的でしょう。ポイントは、「本の著者は、<code>mailto:jane@example.org</code>です」のように述べることは、通常、「本の著者は、メールボックスが<code>mailto:jane@example.org</code>である人物です」の省略形であるということです。空白ノードを使用してこの「人物」を表現することは、現実世界の状況をより正確に表現する方法です。（偶然にも、いくつかのRDFベースのスキーマ言語によって、あるプロパティーはそのプロパティーが記述する資源の<em>一意の識別子</em>であると指定できます。これに関する詳細は、<a href="#richerschemas">5.5項</a>で論じます。）</p>

        <div class="newstuff">
        <p>このような方法で空白ノードを使用すれば、不適切な状況でリテラルを使用することを避けることもできます。例えば、Janeの本について記述する際に、著者を識別するURIrefがなければ、出版社は以下のように書くことができます（出版社自身のex2t<code>ex2terms:</code>語彙を使用して）。</p>

        <div class="exampleOuter exampleInner">
<pre>
ex2terms:book78354   rdf:type          ex2terms:Book .
ex2terms:book78354   ex2terms:author   "Jane Smith" .
</pre>
        </div>

        <p>しかし、この本の著者は、実際には「Jane Smith」という文字列ではなく、<em>名前</em>がJane Smithである人物です。出版社は、以下のように、これと同じ情報を空白ノードを使用してより正確に示すことができます。</p>

        <div class="exampleOuter exampleInner">
<pre>
ex2terms:book78354   rdf:type          ex2terms:Book .
ex2terms:book78354   ex2terms:author   _:author78354 .
_:author78354        rdf:type          ex2terms:Person .
_:author78354        ex2terms:name     "Jane Smith" .
</pre>
        </div>

        <p>これは、本質的に「資源<code>ex2terms:book78354</code>は、型<code>ex2terms:Book</code>に関するものであり、その著者は型<code>ex2terms:Person</code>の資源で、その名前は<code>Jane Smith</code>です。」と述べています。もちろん、このような特殊な事例では、出版社は、その著者を外部で参照してもらえるように、空白ノードを使用して著者を識別する代わりに、出版社自身のURIrefを著者に割り当てることができます。</p>

<p>最後に、Janeの年齢を26としている上の例では、プロパティーの値はシンプルに見えることがあるけれども、実際にはより複雑であるという事実を示しています。この場合、Janeの年令は実際に26<em>歳</em>ですが、単位情報（歳）が明示されていません。このような情報は、プロパティーの値にアクセスする誰もが使用されている単位を理解していると確実に見なせる状況では、しばしば省略されます。しかし、ウェブというより幅広い環境においては、このように想定することは概して安全では<em>ありません</em>。例えば、米国のサイトでは、重さの値をポンドで示しますが、米国以外からそのデータにアクセスする人は、重さがキログラムで示されていると思うかもしれません。一般的に、単位やこれと類似した情報を明確に表現するには、慎重な検討が必要です。この問題の詳細は、構造化された値のような情報を表現するための他のいくつかのテクニックに加えて、そのような情報を表現するためのRDFの機能を記述している<a href="#rdfvalue">4.4項</a>で議論じます。</p>

      </div>

      </div>
      <div class="section">
        <h3>
<a id="typedliterals" name="typedliterals"></a>2.4 型付きリテラル</h3>

        <p>前の項では、プレーン・リテラルで表現されたプロパティーの値を、それらのリテラルの個々の部分を表現するために、構造化された値に分解しなくてはならない状況を扱う方法について述べました。例えば、ウェブ・ページを作成した日付を、値として1つのプレーン・リテラルを持つ1つの<code>exterms:creation-date</code>プロパティーとして記録するのではなく、この方法を使用して、同じ値を表現するために別々のプレーン・リテラルを使用して、月、日、年という別々の部分の情報から成る構造体としてその値を表現します。しかし、プロパティーの値を数（例えば、<code>year</code>や<code>age</code>プロパティーの値）やその他の種類の特殊な値などにするつもりであっても、今までは、RDFステートメントで目的語としての役割を果たすすべての定数を、これらのプレーンな（型付きでない）リテラルで表現してきました。</p>

        <p>例えば、<a href="#figure4">図4</a>では、John Smithに関する情報を記録しているRDFグラフを示しました。このグラフは、<a href="#figure7">図7</a>で示しているように、John Smithの<code>exterms:age</code>プロパティーの値をプレーン・リテラル「27」として記録しました。</p>

        <div class="figure">
          <img src="www.asahi-net.or.jp/~ax2s-kmtn/internet/rdf/fig7dec16.png" alt="Smithの年齢の表現"><br>
           <a id="figure7" name="figure7">図7: Smithの年齢の表現</a>
        </div>

        <p>この場合、仮想の組織、example.orgは、「27」が、「2」とそれに続く「7」の文字から構成される文字列としてではなく、恐らく1つの数字として解釈されることを意図しています<span class="newstuff">（このリテラルが「age」プロパティーの値を表わすため）。しかし、図7のグラフには、「27」が数として解釈されるべきであると明示している情報は全くありません。同様に、example.orgは、「27」が、例えば<em>8進数</em>の数、つまり<em>twenty three</em>（23）という値としてではなく、<em>10進数</em>の数、つまり<em>twenty seven</em>（27）という値として解釈されることも恐らく意図しています。しかし、繰り返しになりますが、図7のグラフにはこれを明示する情報が全くありません。特定のアプリケーションは、<code>exterms:age</code>プロパティーの値を10進数として解釈するはずだという理解のもとに書かれているかもしれませんが、これは、このRDFの適切な解釈はRDFグラフでは明らかに示されていない情報に依存しており、したがって、このRDFを解釈する必要がある他のアプリケーションで必ずしも利用できるわけではない情報に依存しているということを意味するでしょう。</span></p>

        <p>プログラミング言語やデータベース・システムに共通する習慣は、<em>データ型</em>とリテラルを関連付けることによって、リテラルを解釈する方法に関するこの追加情報を提供することです（この事例では<code>decimal</code>（十進数）や<code>integer</code>（整数）のようなデータ型）。例えば、データ型を理解するアプリケーションは、指定されたデータ型が<code>integer</code>（整数）なのか、<code>binary</code>（2進数）なのか、<code>string</code>（文字列）なのかによって、例えば、リテラル「10」が数字<em>ten</em>（10）を表わすつもりなのか、数字<em>two</em>（2）なのか、「1」の後に「0」が続く文字で構成される文字列なのかを知るようになります。（<a href="#structuredproperties">2.3項</a>の末尾で言及した単位情報を含むために、例えば、データ型<code>integerYears</code>のような、より特化したデータ型を使用することもできます。しかし、この入門書ではこの概念について詳述していません。）RDFでは、<a href="www.w3.org/TR/rdf-concepts/#dfn-typed-literal">型付きリテラル</a>を使用してこの種の情報を提供します。</p>
        
        <p><span class="newstuff">RDFの型付きリテラルは、文字列と特定のデータ型を識別するURIrefとを対にすることによって作られます。これによって、対になったリテラルを持つ1つのリテラルのノードがRDFグラフで作られます。型付きリテラルで表現された値は、指定されたデータ型を指定された文字列に関連づけている値です。</span>例えば、型付きトリプルを使用すれば、以下のトリプルを使用して、John Smithの年齢が整数<em>27</em>であると記述できます。</p>

        <div class="exampleOuter exampleInner">
<pre>
&lt;http://www.example.org/staffid/85740&gt;  &lt;http://www.example.org/terms/age&gt; "27"^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt; .
</pre>
        </div>

        <p>または、長いURIを書く代わりにQNameの簡略化を使用すると以下のようになります。</p>

        <div class="exampleOuter exampleInner">
<pre>
exstaff:85740  exterms:age  "27"^^xsd:integer .
</pre>
        </div>
        <p>または、<a href="#figure8">図8</a>で示しているようになります。</p>

        <div class="figure">
          <img src="www.asahi-net.or.jp/~ax2s-kmtn/internet/rdf/fig8jul23.png" alt="John Smithの年齢の型付きリテラル"><br>
           <a id="figure8" name="figure8">図8: John Smithの年齢の型付きリテラル</a>
        </div>

        <p>同様に、ウェブ・ページに関する情報を記述している<a href="#figure3">図3</a>で示したグラフでは、こそのページの<code>exterms:creation-date</code>プロパティーの値は、「August 16, 1999」（1999年8月16日）というプレーン・リテラルとして書かれていました。しかし、型付きリテラルを使用すれば、ウェブ・ページの作成日は、以下のトリプルを使用して、<em>August 16, 1999</em>という日付であると明確に記述できます。</p>

        <div class="exampleOuter exampleInner">
<pre>
ex:index.html  exterms:creation-date  "1999-08-16"^^xsd:date .
</pre>
        </div>

        <p>または、<a href="#figure9">図9</a>で示しているようになります。</p>

        <div class="figure">
          <img src="www.asahi-net.or.jp/~ax2s-kmtn/internet/rdf/fig9jul23.png" alt="ウェブ・ページの作成日の型付きリテラル"><br>
           <a id="figure9" name="figure9">図9: ウェブ・ページの作成日の型付きリテラル</a>
        </div>

        <p>一般的なプログラミング言語やデータベース・システムとは異なり、RDFには、整数や実数、文字列、日付に対するデータ型のような、自身のデータ型の集合が全く組み込まれていません。<span class="newstuff">その代わりに、RDFの型付きリテラルは、解釈するためにどのようなデータ型を使用すべきかを特定のリテラルに対して明示する方法を提供するだけです。型付きリテラルで使用されるデータ型は、RDFの外部で定義され、それらの<a href="www.w3.org/TR/rdf-concepts/#dfn-datatype-URI">データ型URI</a>で識別されます。（例外が1つあります。RDFは、XMLコンテンツをリテラルの値として表現するために、<code>rdf:XMLLiteral</code>というURIrefを使用して組み込みデータ型を定義します。このデータ型は、<a href="#ref-rdf-concepts">[RDF-CONCEPTS]</a>で定義されており、使用法は<a href="#xmlliterals">4.5項</a>で記述されています。）</span>例えば、<a href="#figure8">図8</a>と<a href="#figure9">図9</a>の例では、<a href="www.w3.org/TR/xmlschema-2/">XMLスキーマ パート2:データ型</a> <a href="#ref-xmlschema2">[XML-SCHEMA2]</a>で定義されているXMLスキーマ・データ型に属するデータ型、<code>integer</code>と<code>date</code>を使用します。この方法の利点は、これによって、異なる情報源からの情報を、その情報源と元々のRDFデータ型の集合の間で型の変換を行わずに、直接表現する柔軟性をRDFが得るということです。（型の変換は、異なるデータ型を持つシステム間で情報を移動させる際に必要ですが、RDFでは、元のRDFデータ型の集合に変換を加える必要はありません。）</p>

        <div class="newstuff">

        <p>RDFデータ型の概念は、<a href="www.w3.org/TR/rdf-concepts/">RDF概念および抽象構文</a> <a href="#ref-rdf-concepts">[RDF-CONCEPTS]</a>で記述しているように、XMLスキーマ・データ型<a href="#ref-xmlschema2">[XML-SCHEMA2]</a>の<a name="LCC-025" id="LCC-025">概念の枠組み</a>に基づいています。この概念の枠組みは、データ型が以下から構成されていると定義しています。</p>

      <ul>
        <li>データ型のリテラルを表現すること目的とした、<em>値空間</em>（value space）と呼ばれる一連の値。例えば、XMLスキーマ・データ型<code>xsd:date</code>の場合、この値の集合は一連の日付です。</li>

        <li>データ型がその値を表現するために使用する、<em>字句空間</em>（lexical space）と呼ばれる一連の文字列。この一連の文字列は、このデータ型のリテラルを表現するためにどの文字列を正当に使用できるかを決定します。例えば、データ型<code>xsd:date</code>は、<code>1999-08-16</code>をこの種のリテラルを書く正当な方法であると定義しています（例えば、<code>August 16, 1999</code>ではなく）。<a href="#ref-rdf-concepts">[RDF-CONCEPTS]</a>で定義されているように、データ型の字句空間は、ユニコード<a href="#ref-unicode">[UNICODE]</a>の文字列セットで、これによって多くの言語による情報を直接表現できるようになります。</li>

        <li>字句空間から値空間への<em>字句－値マッピング</em>（lexical-to-value mapping）。これは、字句空間の特定の文字列がこの特定のデータ型に対して表現する値を決定します。例えば、データ型式<code>xsd:date</code>に対する字句－値マッピングは、このデータ型では、<code>1999-08-16</code>という文字列は<em>1999年8月16日</em>という日付を表現するということを決定します。同じ文字列が異なるデータ型に対し異なる値を表現できるため、字句－値マッピングは因数です。</li>
      </ul>
 
        <p>すべてのデータ型がRDFでの使用に適しているわけではありません。データ型をRDFで適切に使用するためには、今しがた記述した概念の枠組みに従わなければなりません。これが基本的に意味するのは、文字列が与えられれば、データ型は、その文字列が字句空間にあるかどうかと、その文字列が値空間でどのような値を表現するかを、明確に定義しなければならないということです。例えば、<code>xsd:string</code>、<code>xsd:boolean</code>、<code>xsd:date</code>などのような基本的なXMLスキーマ・データ型は、RDFでの使用に適しています。しかし、組み込みXMLスキーマ・データ型の一部かは、RDFでの使用に適していません。例えば、<code>xsd:duration</code>は明確に定義された（well-defined）値空間を持っておらず、<code>xsd:QName</code>はXMLドキュメントのコンテキストを含んでいる必要があります。RDFでの使用に適当／不適当であると現在考えられているXMLスキーマ・データ型のリストを<a href="#ref-rdf-semantics">[RDF-SEMANTICS]</a>で提供しています。</p> 
</div>

        <p><span class="newstuff">特定の型付きリテラルが意味する値は型付きリテラルのデータ型で定義されており、<code>rdf:XMLLiteral</code>を除き、RDFはいかなるデータ型も定義しないため、RDFグラフで表示されている型付きリテラルの実際の解釈（例えば、それが意味する値を決定する）は、RDFだけでなく型付きリテラルのデータ型も正しく処理するように書かれたソフトウェアで行わなければなりません。事実上、このソフトウェアは、RDFだけではなくデータ型も含んだ拡張言語を組み込み語彙の一部として処理するように書かれていなければなりません。これは、どのデータ型をRDFソフトウェアで一般的に使用できるのかという問題を引き起こします。一般的に、RDFでの使用に適していると<a href="#ref-rdf-semantics">[RDF-SEMANTICS]</a>に記載されているXMLスキーマ・データ型は、</span>RDFでは「最優先」（first among equals）というステータスを持っています。既に指摘したように、<a href="#figure8">図8</a>と<a href="#figure9">図9</a>の例では、これらのXMLスキーマ・データ型の一部を使用しました。そして、この入門書でも、他の大部分の型付きリテラルの例でこれらのデータ型を使用します（一例をあげると、XMLスキーマ・データ型では、データ型を参照するために使用できるURIrefを既に割り当てています。この仕様は<a href="#ref-xmlschema2">[XML-SCHEMA2]</a>で定めています）。これらのXMLスキーマ・データ型は、他のデータ型式と全く同じように処理されますが、最も広く使用されることが予期されており、したがって、異なるソフトウェア間で相互利用される可能性が最もあります。その結果、多くのRDFソフトウェアがこれらのデータ型も処理するように書かれるでしょう。しかし、既に記述したように、RDFでの使用に適していると判断されたという前提で、他の一連のデータ型を処理するためにもRDFソフトウェアを書くことができます。</p>

        <p>一般的に、RDFソフトウェアは、ソフトウェアが処理するように書かれていないデータ型に対する参照を含んでいるRDFデータの処理を要求されることがあり、その場合、ソフトウェアが処理できないこともあります。<span class="newstuff">一例をあげると、<code>rdf:XMLLiteral</code>を除いて、RDF自体は、データ型を識別するURIrefを定義していません。その結果、特定のURIrefを認識するように書かれていなければ、RDFソフトウェアは、型付きリテラルで書かれているURIrefが実際にデータ型を識別するかどうかを判断できないでしょう。そのうえ、URIrefがデータ型を識別したとしても、RDF自体はそのデータ型と特定のリテラルとを対にすることの妥当性を定義しません。</span>この妥当性は、その特定のデータ型を正しく処理するように書かれたソフトウェアのみが決定できます。</p>

        <p>例えば、型付きリテラルは、トリプルで以下のように書くことができます。</p>

        <div class="exampleOuter exampleInner">
<pre>
exstaff:85740  exterms:age  "pumpkin"^^xsd:integer .
</pre>
        </div>

        <p>または、<a href="#figure10">図10</a>で示すグラフは以下のようになります。</p>

        <div class="figure">
          <img src="www.asahi-net.or.jp/~ax2s-kmtn/internet/rdf/fig10jul23.png" alt="John Smithの年齢の不正な型付きリテラル"><br>
           <a id="figure10" name="figure10">図10: John Smithの年齢の不正な型付きリテラル</a>
        </div>

        <p>これは、正当なRDFですが、<code>"pumpkin"</code>（かぼちゃ）は<code>xsd:integer</code>の字句空間に存在すると定義されていないため、<code>xsd:integer</code>のデータ型に関する限り、明らかに誤りです。<code>xsd:integer</code>データ型を処理するように書かれていないRDFソフトウェアは、<span class="newstuff">この誤り</span>を認識できないでしょう。</p>

        <p class="newstuff">しかし、RDFの型付きリテラルを適切に使用すれば、リテラルの値が意図する解釈に関する情報をより多く得ることができ、ゆえに、RDFステートメントはアプリケーション間の情報交換により適した手段になります。</p>

      </div>

      <div class="section">
        <h3><a name="conceptsummary" id="conceptsummary">2.5 概念の要約</a></h3>

        <p>全体として見ると、RDFは基本的にシンプルです。つまり、URIrefで識別された事物に関するステートメントとして解釈されたノードとアークの図式です。この項では、これらの概念に関する概論を提供しています。以前に指摘したように、これらの概念を記述している規範的な（すなわち、最終的な）RDFの仕様は、<a href="www.w3.org/TR/rdf-concepts/">RDF概念および抽象構文</a> <a href="#ref-rdf-concepts">[RDF-CONCEPTS]</a>であり、詳細はこれを参考にするべきです。これらの概念の形式意味論（意味）は、<a href="www.w3.org/TR/rdf-mt/">RDFセマンティクス</a>（規範） <a href="#ref-rdf-semantics">[RDF-SEMANTICS]</a>ドキュメントで定義されています。</p>

        <p>しかし、これまで論じてきた、RDFステートメントを使用して事物を記述するための基本技術に加え、人や組織は、これらのステートメントで使用しようとする<em>語彙</em>（用語）を記述する方法も必要であることは明らかです。特に、以下のような語彙が必要です。</p>

        <ul>
          <li>事物の型を定義する語彙（例えば、<code>exterms:Person</code>）。</li>

          <li>プロパティーを記述する語彙（例えば、<code>exterms:age</code>や<code>exterms:creation-date</code>）。そして、</li>
          <li>これらのプロパティーを含む、ステートメントの主語や目的語としての役割を果たすことができる事物の型を記述する語彙（<code>exterms:age</code>プロパティーの値が、常に<code>xsd:integer</code>であるように指定するなど）。</li>
        </ul>

        <p>RDFでこのような語彙を記述するための基礎は<a href="www.w3.org/TR/rdf-schema/">RDF語彙記述言語1.0</a> <a href="#ref-rdf-vocabulary">[RDF-VOCABULARY]</a>であり、これは<a href="#rdfschema">5項</a>で記述しています。</p>

        <p>RDFの基礎をなす基本概念に関する別の背景と、ウェブ情報を記述するための一般言語を提供する上でのその役割に関しては<a href="#ref-webdata">[WEBDATA]</a>で参照できます。RDFは、概念グラフや論理ベースの知識表現、フレーム、リレーショナル・データベースを含む、知識表現や人工知能、データ管理の概念を利用します。これらの主題に関する背景情報になりうる情報源には、<a href="#ref-sowa">[SOWA]</a>や<a href="#ref-cg">[CG]</a>、<a href="#ref-kif">[KIF]</a>、<a href="#ref-hayes">[HAYES]</a>、<a href="#ref-luger">[LUGER]</a>、<a href="#ref-gray">[GRAY]</a>が含まれています。</p>
      </div>
    </div>

    <div class="section">

      <h2>
<a id="rdfxml" name="rdfxml"></a>3. RDFのXML構文: RDF/XML</h2>

      <p>2項で記述したように、RDFの概念モデルはグラフです。RDFは、<em>RDF/XML</em>と呼ばれるRDFグラフを作成し、交換するためのXML構文を提供します。省略表記用のトリプルとは異なり、RDF/XMLは、RDFを書くための規範構文です。RDF/XMLは、<a href="www.w3.org/TR/rdf-syntax-grammar/">RDF/XML構文仕様</a> <a href="#ref-rdf-syntax">[RDF-SYNTAX]</a>で定義されてます。この項では、このRDF/XML構文について記述しています。</p>

      <div class="section">

        <h3><a name="basicprinciples" id="basicprinciples">3.1 基本原理</a></h3>

        <p>既に提示したいくつかの例を使用してRDF/XML構文の背景にある基本概念を示すことができます。例として、以下の英語のステートメントを見てください。</p>
        <p class="ptriple"><code><strong>http://www.example.org/index.html</strong>
        has a <strong>creation-date</strong> whose value is <strong>August 16,
        1999</strong></code></p>
        <p>URIrefを<code>creation-date</code>プロパティーに割り当てた後の、この1つのステートメントのRDFグラフを<a href="#figure11">図11</a>で示します。</p>

        <div class="figure">
          <img src="www.asahi-net.or.jp/~ax2s-kmtn/internet/rdf/fig11dec16.png" alt="ウェブ・ページの作成日の記述"><br>
           <a id="figure11" name="figure11">図11: ウェブ・ページの作成日の記述</a>
        </div>

        <p>トリプル表現では以下のようになります。</p>

        <div class="exampleOuter exampleInner">
<pre>
ex:index.html   exterms:creation-date   "August 16, 1999" .
</pre>
        </div>

        <p class="newstuff">（この例では、日付の値に型付きリテラルが使用されていないことに注意してください。RDF/XMLでの型付きリテラルの表現に関しては、この項の後半で記述します。）</p>

        <p><a href="#example2">例2</a>では、<a href="#figure11">図11</a>のグラフに対応するRDF/XML構文を示しています。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example2" name="example2">例2: ウェブ・ページの作成日のRDF/XML</a>
          </div>

          <div class="exampleInner">
<pre>1. &lt;?xml version="1.0"?&gt;
2. &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
3.             xmlns:exterms="http://www.example.org/terms/"&gt;

4.   &lt;rdf:Description rdf:about="http://www.example.org/index.html"&gt;
5.       &lt;exterms:creation-date&gt;August 16, 1999&lt;/exterms:creation-date&gt;
6.   &lt;/rdf:Description&gt;

7. &lt;/rdf:RDF&gt;
</pre>
          </div>
        </div>

        <p>（例の説明に役立つように行番号を付記しています。）</p>

        <p>これは、非常に手間がかかるように見えます。このXMLの各部分を順に検討すれば、何が起こっているかを理解することはずっと簡単です（XMLは<a href="#documents">付録B</a>で簡潔に紹介しています）。</p>

        <p>1行目の<code>&lt;?xml version="1.0"?&gt;</code>は、<em>XML宣言</em>で、以下のコンテンツがXMLであることと、どのバージョンのXMLなのかを示しています。</p>

        <p>2行目では、<code>rdf:RDF</code>要素を開始しています。これは、以下のXMLコンテンツ（ここから始まり、7行目の<code>&lt;/rdf:RDF&gt;</code>で終わる）がRDFを表現しようとしていることを示しています。同じ行の<code>rdf:RDF</code>の後に、XML名前空間宣言が<code>rdf:RDF</code>開始タグの<code>xmlns</code>属性として表現されます。<a name="LCC-012a" id="LCC-012a">この宣言</a>では、このコンテンツ内の接頭辞<code>rdf:</code>が付いているタグはすべてURIref <code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code>によって識別される名前空間の一部であると明記しています。<span class="newstuff">文字列<code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code>で始まるURIrefは、RDF語彙の用語に対して使用されています。</span></p>

        <p>3行目では、別のXML名前空間宣言を明記しており、今回は接頭辞<code>exterms:</code>です。これは、<code>rdf:RDF</code>要素の別の<code>xmlns</code>属性として表され、名前空間URIref <code>http://www.example.org/terms/</code>が<code>exterms:</code>接頭辞と関連づけられることを明記しています。<span class="newstuff">文字列<code>http://www.example.org/terms/</code>で始まるURIrefは、例としてあげた組織、example.orgが定義している語彙の用語に対して使用されます。</span>3行目の末尾の「&gt;」は、<code>rdf:RDF</code>開始タグの終わりを示しています。1～3行目は、これがRDF/XMLコンテンツであることを示し、RDF/XMLコンテンツ内で使用される名前空間を識別するために必要な一般的な「管埋」情報です。</p>

        <p>4～6行目では、<a href="#figure11">図11</a>で示した特定のステートメントのRDF/XMLを提供しています。RDFステートメントについて述べる明確な方法は、これが<em>記述</em>であり、ステートメントの主題に<em>関するもの</em>であり（この場合、http://www.example.org/index.htmlに関するもの)、これはRDF/XMLがステートメントを表現する方法であると述べることです。 4行目の<code>rdf:Description</code>開始タグは資源の<em>記述</em>の始まりを示し、続いて<code>rdf:about</code>属性を使用して主語資源のURIrefを指定し、ステートメントが<em>何に関する</em>資源なのか（ステートメントの主語）を識別するようになります。<span class="newstuff">5行目では、QName <code>exterms:creation-date</code>をタグとして使用して<em>プロパティー要素</em>を提供し、ステートメントの述語と目的語を表現しています。QName <code>exterms:creation-date</code>を選択しているので、<code>exterms:</code>接頭辞のURIrefにローカール名<code>creation-date</code>を追加すると、ステートメントの述語<code>http://www.example.org/terms/creation-date</code>が得られます。このプロパティー要素のコンテンツは、ステートメントの目的語である<code>August 19, 1999</code>というプレーン・リテラル（主語資源の作成日プロパティーの値）です。</span>プロパティーの要素は、これを包含する<code>rdf:Description</code>要素内に入れ子にされ、このプロパティーが、<code>rdf:Description</code>要素の<code>rdf:about</code>属性で指定されている資源に適用されていることを示します。6行目は、この特定の<code>rdf:Description</code>要素の終わりを示しています。</p>

        <p>最後に、7行目は、2行目で開始した<code>rdf:RDF</code>要素の終わりを示しています。<code>rdf:RDF</code>要素を使用してRDF/XMLコンテンツを含むことは、XMLがコンテキストによってRDF/XMLとして識別できるような状況におけるオプションです。これに関する詳細は、<a href="#ref-rdf-syntax">[RDF-SYNTAX]</a>で論じます。しかし、どのような場合でも、<code>rdf:RDF</code>要素を提供しても問題はなく、入門書の例では、通常は（常にではないが）提供しています。</p>
        <p><a href="#example2">例2</a>では、RDFグラフをXMLの要素、属性、要素コンテンツ、属性値としてコード化するためにRDF/XMLで使用されている基本概念を示しています。<a href="#documents">付録B</a>で述べているように、述語のURIref（一部のノードも同様に）は、名前空間修飾付き（namespace-qualified）要素や属性を示す<em>ローカル名</em>と共に、名前空間URIを示す短い<em>接頭辞</em>で構成されているXML <em>QName</em>として書かれています。対（名前空間URIref、ローカル名）が選択されるので、これらを連結すると最初のノードや述語のURIrefを作成できます。主語ノードのURIrefは、XML属性値として書かれます（目的語ノードのURIrefが属性値として書かれることもある）。リテラルのノード（常に目的語ノードである）は、要素テキスト・コンテンツや属性値になります。（これらのオプションの多くは、この入門書の後半で記述しており、これらのオプションはすべて<a href="#ref-rdf-syntax">[RDF-SYNTAX]</a>で記述されています。）</p>

        <p><a href="#example2">例2</a>の4～6行目と同じRDF/XMLを使用して各ステートメントを別々に表現することによって、複数のステートメントで構成されたRDFグラフをRDF/XMLで表現できます。例えば、以下の2つのステートメントを書く場合、</p>

        <div class="exampleOuter exampleInner">
<pre>
ex:index.html   exterms:creation-date   "August 16, 1999" .
ex:index.html   dc:language             "en" .
</pre>
        </div>

        <p><a href="#example3">例3</a>のRDF/XMLを使用できます。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example3" name="example3">例3: 2つのステートメントのRDF/XML</a>
          </div>

          <div class="exampleInner">
<pre>
1.  &lt;?xml version="1.0"?&gt;
2.  &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
3.              xmlns:dc="http://purl.org/dc/elements/1.1/"
4.              xmlns:exterms="http://www.example.org/terms/"&gt;

5.    &lt;rdf:Description rdf:about="http://www.example.org/index.html"&gt;
6.        &lt;exterms:creation-date&gt;August 16, 1999&lt;/exterms:creation-date&gt;
7.    &lt;/rdf:Description&gt;

8.    &lt;rdf:Description rdf:about="http://www.example.org/index.html"&gt;
9.        &lt;dc:language&gt;en&lt;/dc:language&gt;
10.   &lt;/rdf:Description&gt;

11. &lt;/rdf:RDF&gt;
</pre>
          </div>
        </div>

        <p><a href="#example3">例3</a>は、2番目のステートメントを表現するために2番目の<code>rdf:Description</code>要素（8～10行目に）を追加しただけで、あとは<a href="#example2">例2</a>と同じです。（また、このステートメントで追加されている名前空間を識別するために、3行目に名前空間宣言を追加しています。）追加した各ステートメントに対して別々の<code>rdf:Description</code>要素を使用して、追加した任意の数のステートメントを同じ方法で書くことができます。<a href="#example3">例3</a>で示しているように、いったんXMLと名前空間宣言を書く手間に対処すると、RDF/XMLでそれぞれのRDFステートメントを追記することは容易かつそれほど複雑ではありません。</p>

        <p>RDF/XML構文では、多くの略語を提供し、共通した用法をより簡単に記述できるようにしています。例えば、<a href="#example3">例3</a>のように、普通は同じ資源を複数のプロパティーや値で同時に記述します。この事例では、資源<code>ex:index.html</code>は、複数のステートメントの主語です。このような事例に対処するため、RDF/XMLでは、これらのプロパティーを表現する複数のプロパティー要素を主語資源を識別する<code>rdf:Description</code>要素内で入れ子にできます。例えば、<code>http://www.example.org/index.html</code>に関する以下のステートメントのグループを表現する場合、</p>
        <div class="exampleOuter exampleInner">
<pre>
ex:index.html   dc:creator              exstaff:85740 .
ex:index.html   exterms:creation-date   "August 16, 1999" .
ex:index.html   dc:language             "en" .
</pre>
        </div>

        <p>このグラフ（<a href="#figure3">図3</a>と同じ）は、<a href="#figure12">図12</a>で示しているようになり、</p>

        <div class="figure">
          <img src="www.asahi-net.or.jp/~ax2s-kmtn/internet/rdf/fig3nov19.png" alt="同じ資源に関する複数のステートメント"><br>
           <a id="figure12" name="figure12">図12: 同じ資源に関する複数のステートメント</a>
        </div>

        <p><a href="#example4">例4</a>で示しているようにRDF/XMLを書くことができます。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example4" name="example4">例4: 複数のプロパティーの省略形</a>
          </div>

          <div class="exampleInner">
<pre>
1.  &lt;?xml version="1.0"?&gt;
2.  &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
3.              xmlns:dc="http://purl.org/dc/elements/1.1/"
4.              xmlns:exterms="http://www.example.org/terms/"&gt;

5.    &lt;rdf:Description rdf:about="http://www.example.org/index.html"&gt;
6.         &lt;exterms:creation-date&gt;August 16, 1999&lt;/exterms:creation-date&gt;
7.         &lt;dc:language&gt;en&lt;/dc:language&gt;
8.         &lt;dc:creator rdf:resource="http://www.example.org/staffid/85740"/&gt;
9.    &lt;/rdf:Description&gt;

10. &lt;/rdf:RDF&gt;
</pre>
          </div>
        </div>

        <p>以前の2つの例と比べて、<a href="#example4">例4</a>では、<code>dc:creator</code>プロパティー要素を（8行目に）追加しています。さらに、主語が<code>http://www.example.org/index.html</code>である3つのプロパティーに対するプロパティー要素を、各ステートメントに対して別々の<code>rdf:Description</code>要素を書くのではなく、その主語を識別する1つの<code>rdf:Description</code>要素内に入れ子にしています。</p>

        <p>8行目では、新しい形式のプロパティー要素も導入しています。7行目の<code>dc:language</code>要素は、<a href="#example2">例2</a>で使用している<code>exterms:creation-date</code>要素に似ています。これら2つの要素は、プレーン・リテラルを用いてプロパティーをプロパティー値として表現し、プロパティー名に対応する開始タグと終了タグでリテラルを囲み込んで書いています。しかし、8行目の<code>dc:creator</code>要素は、リテラルではなく<em>別の資源</em>を値を持つプロパティーを表現しています。他の要素のリテラルの値と同じ方法で、この資源のURIrefを開始タグと終了タグ内にプレーン・リテラルで書いた場合、<code>dc:creator</code>要素の値は、URIrefとして解釈されているリテラルで識別された資源ではなく、<em>文字列</em><code>http://www.example.org/staffid/85740</code>であるということを述べていることになります。この違いを示すために、XMLで<em>空要素タグ</em>（別個の終了タグを持たない）と呼んでいるものを使用して<code>dc:creator</code>要素を書き、この空要素内で<code>rdf:resource</code>属性を使用してプロパティー値を書いています。<code>rdf:resource</code>属性は、プロパティー要素の値が別の資源であり、そのURIrefで識別されるということを示します。URIrefは属性<em>値</em>として使用されるため、RDF/XMLでは、要素や属性<em>名</em>を書く際に行ったようにQNameで省略するのではなく、URIrefをすべて書き出す（絶対URIrefや相対URIrefとして）必要があります（絶対URIrefと相対URIrefに関しては<a href="#identifiers">付録A</a>で論じます）。</p>

        <p><a href="#example4">例4</a>のRDF/XMLが<em>略語形</em>であるということを理解していることが重要です。各ステートメントが別々に書かれている<a href="#example5">例5</a>のRDF/XMLは、全く同じRDFグラフ（<a href="#figure12">図12</a>のグラフ）を記述しています。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example5" name="example5">例5: 別々のステートメントとして例4を記述</a>
          </div>
          <div class="exampleInner">

<pre>
 &lt;?xml version="1.0"?&gt;
 &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
             xmlns:dc="http://purl.org/dc/elements/1.1/"
             xmlns:exterms="http://www.example.org/terms/"&gt;

   &lt;rdf:Description rdf:about="http://www.example.org/index.html"&gt;
       &lt;exterms:creation-date&gt;August 16, 1999&lt;/exterms:creation-date&gt;
   &lt;/rdf:Description&gt;

   &lt;rdf:Description rdf:about="http://www.example.org/index.html"&gt;
       &lt;dc:language&gt;en&lt;/dc:language&gt;
   &lt;/rdf:Description&gt;

   &lt;rdf:Description rdf:about="http://www.example.org/index.html"&gt;
       &lt;dc:creator rdf:resource="http://www.example.org/staffid/85740"/&gt;
   &lt;/rdf:Description&gt;

 &lt;/rdf:RDF&gt;
</pre>
          </div>
        </div>

        <p>以下の項では、いくつかのRDF/XML省略形を追記しています。利用できる省略形に関する詳細は、<a href="#ref-rdf-syntax">[RDF-SYNTAX]</a>で記述しています。</p>

        <p>RDF/XMLでは、URIrefがないノード、すなわち、<a href="#structuredproperties">2.3項</a>で記述した<em>空白ノード</em>を含んでいるグラフも表現できます。例えば、<a href="#figure13">図13</a>（<a href="#ref-rdf-syntax">[RDF-SYNTAX]</a>に掲載）は、「ドキュメント'http://www.w3.org/TR/rdf-syntax-grammar'のタイトルは'RDF/XML Syntax Specification (Revised)'で、編集者が存在し、その編集者の名前は'Dave Beckett'で、'http://purl.org/net/dajobe/'というホームページを持っている」と述べているグラフを示します。</p>

        <div class="figure">
          <img src="www.asahi-net.or.jp/~ax2s-kmtn/internet/rdf/fig13dec16.png" alt="空白ノードを含んでいるグラフ"><br>
           <a id="figure13" name="figure13">図13: 空白ノードを含んでいるグラフ</a>
        </div>

        <p>これは、<a href="#structuredproperties">2.3項</a>で論じた概念を示しています。つまり、URIrefがなくても他の情報に関して記述できるものを表現するために空白ノードを使用します。この場合、空白ノードは、ドキュメントの編集者である、人を表現しており、その人を彼の名前とホームページによって記述しています。</p>

        <p>RDF/XMLでは、空白ノードを含む、グラフを表現する方法をいくつか提供します。これらは、すべて<a href="#ref-rdf-syntax">[RDF-SYNTAX]</a>で記述されています。ここで示しているのは最も直接的な方法で、各空白ノードに<em>空白ノード識別子</em>を割り当てるというものです。空白ノード識別子は、特定のRDF/XMLドキュメント内の空白ノードを識別する役割を果たしますが、URIrefと異なり、割り当てられているドキュメントの外部では不明です。空白ノードは、空白ノード識別子を値として持つ<code>rdf:nodeID</code>属性を、本来ならば資源のURIrefが表示される場所に使用することでRDF/XMLで参照できます。特に、<code>rdf:about</code>属性ではなく<code>rdf:nodeID</code>属性を持つ<code>rdf:Description</code>要素を使用して、空白ノードを主語として持つステートメントをRDF/XMLで書くことができます。同様に、<code>rdf:resource</code>属性ではなく<code>rdf:nodeID</code>属性を持つプロパティー要素を使用して、空白のノードを<em>目的語</em>として持つステートメント書くことができます。<code>rdf:nodeID</code>を使用して、<a href="#example6">例6</a>では、<a href="#figure13">図13</a>に対応するRDF/XMLを示しています。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example6" name="example6">例6: 空白ノードを記述したRDF/XML
</a>
          </div>

          <div class="exampleInner">
<pre>
1.  &lt;?xml version="1.0"?&gt;
2.  &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
3.              xmlns:dc="http://purl.org/dc/elements/1.1/"
4.              xmlns:exterms="http://example.org/stuff/1.0/"&gt;

5.     &lt;rdf:Description rdf:about="http://www.w3.org/TR/rdf-syntax-grammar"&gt;
6.       &lt;dc:title&gt;RDF/XML Syntax Specification (Revised)&lt;/dc:title&gt;
7.       &lt;exterms:editor rdf:nodeID="abc"/&gt;
8.     &lt;/rdf:Description&gt;

9.     &lt;rdf:Description rdf:nodeID="abc"&gt;
10.        &lt;exterms:fullName&gt;Dave Beckett&lt;/exterms:fullName&gt;
11.        &lt;exterms:homePage rdf:resource="http://purl.org/net/dajobe/"/&gt;
12.    &lt;/rdf:Description&gt;

13. &lt;/rdf:RDF&gt;
</pre>
          </div>
        </div>
        <p><a href="#example6">例6</a>の9行目では、空白ノード識別子<code>abc</code>がいくつかのステートメントの主語として空白ノードを識別するために使用され、7行目では、空白ノードが資源の<code>exterms:editor</code>プロパティーの値であると示すために使用されています。<a href="#ref-rdf-syntax">[RDF-SYNTAX]</a>で記述されている他のいくつかの方法と比べて、空白ノード識別子を使用することの利点は、空白ノード識別子を使用すると、同じRDF/XMLドキュメントの複数の場所で同じ空白ノードを参照できるということです。</p>

        <p>最後に、<a href="#typedliterals">2.4項</a>で記述した<em>型付きリテラル</em>は、これまでの例で使用したプレーン・リテラルの代りに、プロパティー値として使用できます。型付きリテラルは、そのリテラルを含んでいるプロパティー要素にデータ型URIrefを指定している<code>rdf:datatype</code>属性を加えることにより、RDF/XMLで表現されます。</p>

        <p>例えば、<a href="#example2">例2</a>のステートメントを変更して、<code>exterms:creation-date</code>プロパティーに対するプレーン・リテラルではなく型付きリテラルを使用すると、トリプル表現は以下のようになります。</p>

        <div class="exampleOuter exampleInner">
<pre>
ex:index.html   exterms:creation-date   "1999-08-16"^^xsd:date .
</pre>
        </div>

        <p>これに対応するRDF/XML構文は、<a href="#example7">例7</a>で示しているようになります。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example7" name="example7">例7: 型付きリテラルを使用したRDF/XML</a>
          </div>

          <div class="exampleInner">
<pre>
1. &lt;?xml version="1.0"?&gt;
2. &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
3.             xmlns:exterms="http://www.example.org/terms/"&gt;

4.   &lt;rdf:Description rdf:about="http://www.example.org/index.html"&gt;
5.     &lt;exterms:creation-date rdf:datatype=
         "http://www.w3.org/2001/XMLSchema#date"&gt;1999-08-16
       &lt;/exterms:creation-date&gt;
6.   &lt;/rdf:Description&gt;

7. &lt;/rdf:RDF&gt;
</pre>
          </div>
        </div>

        <p><a href="#example7">例7</a>の5行目では、<code>rdf:datatype</code>属性を要素の開始タグに加えてデータ型を指定することにより、型付きリテラルが<code>exterms:creation-date</code>プロパティー要素の値として提供されています。この属性の値は、データ型のURIrefで、この事例ではXMLスキーマの<code>date</code>データ型のURIrefです。これが属性値であるため、トリプルで使用されるQNameの省略形<code>xsd:date</code>を使用するのではなく、URIrefをすべて書き出さなければなりません。その後、このデータ型に適したリテラルが要素のコンテンツとして書かれ（この事例では、<code>1999-08-16</code>というリテラル）、これはXMLスキーマの<code>date</code>データ型の1999年8月16日をリテラルで表現したものです。</p>

<div class="newstuff">
        <p>この<a name="LCC-013" id="LCC-013">入門書の残り</a>の例では、リテラルの値が意図する解釈に関してより多い情報を伝える際に型付きリテラルの値を強調するために、プレーンな（型付きでない）リテラルではなく適切なデータ型の型付きリテラルを使用するでしょう。（例外は、型付きリテラルを現在使用していない実際のアプリケーションの例では、これらのアプリケーションの用法を正確に反映するために、プレーン・リテラルが使用され続けるということでしょう。）RDF/XMLでは、プレーン・リテラルと型付きリテラルの両方（そして、若干の例外があるが、タグ）は、ユニコード<a href="#ref-unicode">[UNICODE]</a>の文字を含むことができ、これによって多くの言語による情報を直接表現できます。</p>

        <p><a href="#example7">例7</a>は、型付きリテラルを使用するためには、型付きリテラルを値として持つ要素ごとにデータ型を識別するURIrefを持つ<code>rdf:datatype</code>属性を書く必要があるということを示しています。以前に指摘したように、RDF/XMLでは、QNameとして省略するのではなく、属性値として使用されるURIrefをすべて書き出す必要があります。このような場合には、RDF/XMLでは、URIrefに省略機能を追加提供することによって、XML<em>エンティティー</em>を使用して読み易さを改善できます。本質的に、XMLエンティティー宣言は、名前を文字列に関連づけます。エンティティー名がXMLドキュメント内の他の場所で参照されていれば、XMLプロセッサはその参照を対応する文字列に置き換えます。例えば、以下のような<code>ENTITY</code>宣言（RDF/XMLドキュメントの冒頭で<code>DOCTYPE</code>宣言の一部として指定される）</p> 

        <div class="exampleOuter exampleInner">
<pre>
&lt;!DOCTYPE rdf:RDF [&lt;!ENTITY xsd "http://www.w3.org/2001/XMLSchema#"&gt;]&gt; 
</pre>
        </div>

        <p>は、エンティティー<code>xsd</code>が、XMLスキーマ・データ型に対する名前空間URIrefを表現している文字列であると定義しています。この宣言によって、XMLドキュメントの他の場所で完全な名前空間URIrefをエンティティー参照 <code>&amp;xsd;</code>で省略形にできます。この省略形を使用すれば、<a href="#example7">例7</a>は<a href="#example8">例8</a>で示されているように書くことができます。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example8" name="example8">例8: 型付きリテラルとXMLエンティティーを使用するRDF/XML</a>
          </div>

          <div class="exampleInner">
<pre>
1. &lt;?xml version="1.0"?&gt;2. &lt;!DOCTYPE rdf:RDF [&lt;!ENTITY xsd "http://www.w3.org/2001/XMLSchema#"&gt;]&gt;
3. &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
4.             xmlns:exterms="http://www.example.org/terms/"&gt;

5.   &lt;rdf:Description rdf:about="http://www.example.org/index.html"&gt;
6.     &lt;exterms:creation-date rdf:datatype="&amp;xsd;date"&gt;1999-08-16
       &lt;/exterms:creation-date&gt;
7.   &lt;/rdf:Description&gt;

8. &lt;/rdf:RDF&gt;
</pre>
          </div>
        </div>

        <p>2行目の<code>DOCTYPE</code>宣言では、6行目で使用されているエンティティー<code>xsd</code>を定義しています。</p>

        <p>RDF/XMLでは、省略の手段としてXMLエンティティーを使用することはオプションであり、したがって、XMLの<code>DOCTYPE</code>宣言の使用もRDF/XMLではオプションです。（XMLに慣れている読者にとっては、RDF/XMLは「整形式の」XMLである必要があるだけです。RDF/XMLは、XML検証プロセッサによってDTDに対する妥当性を検証するように設計されていません。これに関しては、<a href="#documents">付録B</a>でより全面的に論じ、XMLに関する追加情報を提供します。</p> 

        <p>読み易さを考慮して、入門書の残りの例では、今しがた記述したようにXMLエンティティー<code>xsd</code>を使用します。XMLエンティティーに関する詳細は、<a href="#documents">付録B</a>で論じます。<a href="#documents">付録B</a>で示しているように、他のURIref（そして、より一般的に言えば、他の文字列）もXMLエンティティーを使用して省略できます。しかし、この入門書の例の中でこの方法で省略されるのは、XMLスキーマ・データ型に対するURIrefのみです。</p> 
</div>
        <p>RDF/XMLを省略形で書く方法は他にもありますが、今までに示した機能は、RDF/XMLでグラフを表現するための簡単だが一般的な方法を提供します。これらの機能を使用して、RDFグラフを以下のようなRDF/XMLで書くことができます。</p>

        <ul>
          <li>すべての空白ノードは、空白ノード識別子に割り当てられます。</li>

          <li>各ノードは、入れ子にされていない<code>rdf:Description</code>要素の主語として順にリストアップされ、ノードがURIrefを持つ場合には<code>rdf:about</code>属性を、ノードが空白である場合には<code>rdf:nodeID</code>を使用します。<br>
このノードを主語として持つ各トリプルに対し、リテラルのコンテンツ（恐らく、空）か、トリプルの目的語を指定する<code>rdf:resource</code>属性（目的語ノードにURIrefがある場合）か、トリプルの目的語を指定する<code>rdf:nodeID</code>属性（目的語ノードが空白である場合）のいずれかを使用して適切なプロパティー要素が作成されます。</li>
        </ul>

        <p><a href="#ref-rdf-syntax">[RDF-SYNTAX]</a>で記述した一部のさらに省略化した方法に比べ、このシンプルなアプローチは、実際のグラフ構造を最も直接的に表現し、出力されたRDF/XMLを以後のRDF処理に使用するアプリケーションに対して特に推奨されます。</p>
      </div>

      <div class="section">
        <h3><a name="newresources" id="newresources">3.2 RDF URIrefの省略と組織化</a></h3>

        <p>今までの例では、既に記述した資源にはURIrefが付与されていると見なしてきました。例えば、最初の例では、URIrefが<code>http://www.example.org/index.html</code>であるexample.orgのウェブ・ページに関する記述情報を提供しました。完全なURIrefを引用している<code>rdf:about</code>属性を使用してこの資源をRDF/XMLで識別しました。RDFは、URIrefを資源に割り当てる方法を指定したり制御したりしませんが、組織化された資源のグループの一部にURIrefを割り当てて効果を得るのが望ましい時もあります。例えば、スポーツ用品の会社（example.com）が、テントやハイキング用ブーツなどの自社製品のRDFベースのカタログを、<code>http://www.example.com/2002/04/products</code>で識別されるRDF/XMLドキュメントとして提供したいと思っていると仮定します。この資源では、各製品には別々のRDF記述が与えられます。この記述の1つと一緒に、このカタログ（「Overnighter」という型のテントのカタログの項目）は、<a href="#example9">例9</a>で示しているようにRDF/XMLで書くことができます。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example9" name="example9">例9: example.comのCatalogのRDF/XML</a>
          </div>

          <div class="exampleInner">
<pre>
1.   &lt;?xml version="1.0"?&gt;
2.   &lt;!DOCTYPE rdf:RDF [&lt;!ENTITY xsd "http://www.w3.org/2001/XMLSchema#"&gt;]&gt;
3.   &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
4.               xmlns:exterms="http://www.example.com/terms/"&gt;

5.     &lt;rdf:Description rdf:ID="item10245"&gt;
6.          &lt;exterms:model rdf:datatype="&amp;xsd;string"&gt;Overnighter&lt;/exterms:model&gt;
7.          &lt;exterms:sleeps rdf:datatype="&amp;xsd;integer"&gt;2&lt;/exterms:sleeps&gt;
8.          &lt;exterms:weight rdf:datatype="&amp;xsd;decimal"&gt;2.4&lt;/exterms:weight&gt;
9.          &lt;exterms:packedSize rdf:datatype="&amp;xsd;integer"&gt;784&lt;/exterms:packedSize&gt;
10.    &lt;/rdf:Description&gt;

  ...other product descriptions...

11.  &lt;/rdf:RDF&gt;
</pre>
          </div>
        </div>

        <p><a href="#example9">例9</a>では、記述されている資源（テント）のプロパティー（型（model）、収容人数（sleeping capacity）、重さ（weight））を表現する方法が、前の例と似ています。（これらを取り囲んで、xml、DOCTYPE、RDF、および名前空間情報が、1行目から4行目と11行目に含まれていますが、この情報はカタログ全体に対して1度提示すれば良く、カタログの項目ごとに繰り返す必要はありません。様々なプロパティー値に関連している<em>データ型</em>が明示されていても、これらのプロパティー値の一部に関連している<em>単位</em>は、その値を適切に解釈するためにはこの情報が必要であるにもかかわらず、示されていないということにも注意してください。プロパティーの値に関連している単位やこれに類似した情報の表現に関しては、<a href="#rdfvalue">4.4項</a>で論じます。この例では、<code>exterms:sleeps</code>の値は、テントで寝ることができる人数で、<code>exterms:weight</code>の値はキログラムで示され、バックパックに占めるテントの面積である<code>exterms:packedSize</code>の値は平方センチメートルで示されています。）
</p>

        <p>前例との大きな<em>違い</em>は、5行目の<code>rdf:Description</code>要素が、<code>rdf:about</code>属性ではなく<code>rdf:ID</code>属性を持っているという点です。<code>rdf:ID</code>を使用すると、<code>rdf:ID</code>属性の値で示された<em>フラグメント識別子</em>を、記述されている資源の完全なURIrefの省略形として指定できます（この事例では、<code>item10245</code>で、example.comが割り当てているカタログ番号です）。フラグメント識別子<code>item10245</code>は、<em>基底URI</em>（この事例では、含んでいるカタログ・ドキュメントのURI）と関連して解釈されます。テントに対する完全なURIrefは、（カタログの）基底URIに文字「<code>#</code>」を追加し（フラグメント識別子が後続することを示すために）、その後に<code>item10245</code>を追加して作成されます（絶対URIref <code>http://www.example.com/2002/04/products#item10245</code>になる）。</p>

        <p><code>rdf:ID</code>属性は、現在の基底URI（この例では、カタログの）に対して一意でなければならない名前を定義するという点において、XMLやHTMLの<code>ID</code>属性に多少似ています。この事例では、<code>rdf:ID</code>属性は、名前（<code>item10245</code>）をこの特定の種類のテントに割り当てているように見えます。このカタログ内の他のRDF/XMLでは、絶対URIref <code>http://www.example.com/2002/04/products#item10245</code>か<em>相対URIref</em> <code>#item10245</code>のどちらかを使用して、このテントを参照できます。この相対URIrefは、カタログの基底URIrefと関連して定義されたURIrefであると認識されます。同じ省略形を使用して、カタログの項目に<code>rdf:ID="item10245"</code>ではなく<code>rdf:about="#item10245"</code>を指定することにより（すなわち、相対URIrefを直接指定して）、テントのURIrefを示すこともできます。短縮の方法としては、この2つの形式は基本的に同義です。つまり、RDF/XMLによって作成される完全なURIrefは、どちらの場合でも同じ<code>http://www.example.com/2002/04/products#item10245</code>です。しかし、<code>rdf:ID</code>属性の特定の値は同じ基底URI（この事例では、カタログ・ドキュメント）に対して一度だけしか出現できないため、<code>rdf:ID</code>を使用すると、一連の別々の名前を割り当てる際に追加確認できます。どちらの形式を使用しても、example.comは、2段階の過程でテントに対するURIrefを付与することになります。最初にカタログ全体にURIrefを割り当て、次に、カタログ内のテントの記述に相対URIrefを使用して、この特定の種類のテントに割り当てられたURIrefを示します。そのうえ、この相対URIrefの使用法は、RDFから独立してテントに割り当てられた完全なURIrefの省略形か、カタログ内のテントへのURIrefの割り当てかのどちらかであると考えられます。</p>

        <p>カタログの<em>外部</em>にあるRDFは、完全なURIrefを使用することによって、すなわち、カタログの基底URIにテントの相対URIref <code>#item10245</code>を連結することによって（絶対URIref <code>http://www.example.com/2002/04/products#item10245</code>になる）、このテントを参照できます。例えば、exampleRatings.comというアウトドア・スポーツのウェブサイトでは、RDFを使用して様々なテントの格付けを提供できます。したがって、<a href="#example9">例9</a>で記述したテントに対する（5つ星の）格付けは、exampleRatings.comのウェブサイトでは、<a href="#example10">例10</a>のように表わすことができます。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example10" name="example10">例10: exampleRatings.comのテントの格付け
</a>
          </div>

          <div class="exampleInner">
<pre>
1.  &lt;?xml version="1.0"?&gt;
2.  &lt;!DOCTYPE rdf:RDF [&lt;!ENTITY xsd "http://www.w3.org/2001/XMLSchema#"&gt;]&gt;
3.  &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
4.              xmlns:sportex="http://www.exampleRatings.com/terms/"&gt;

5.    &lt;rdf:Description rdf:about="http://www.example.com/2002/04/products#item10245"&gt;
6.         &lt;sportex:ratingBy rdf:datatype="&amp;xsd;string"&gt;Richard Roe&lt;/sportex:ratingBy&gt;
7.         &lt;sportex:numberStars rdf:datatype="&amp;xsd;integer"&gt;5&lt;/sportex:numberStars&gt;
8.    &lt;/rdf:Description&gt;
9.  &lt;/rdf:RDF&gt;</pre>
          </div>
        </div>

        <p><a href="#example10">例10</a>の5行目では、<code>rdf:Description</code>要素と、テントの完全なURIrefを値として持つ<code>rdf:about</code>属性とを一緒に使用しています。このURIrefの使用すると、格付けで参照するテントを正確に識別できます。</p>

        <p>これらの例では、いくつかのポイントを示しています。まず最初に、RDFは、URIrefを資源（この場合、カタログの様々なテントやその他の項目）に割り当てる方法を指定したり制御したりしなくても、1つのドキュメント（この場合、カタログ）をこれらの資源の記述の情報源として識別するプロセス（RDFの外部での）と、そのドキュメント内のこれらの資源の記述における相対URIrefの使用とを組み合わせることによって、RDFでURIrefの資源に割り当てるという<em>効果</em>を得ることができます。例えば、example.comは、このカタログを、製品の商品番号がこのカタログの項目になければexample.comが知らないものであるという理解のもとに、自社製品を記述している主要な情報源として使用できます。（RDFでは、2つの資源のURIrefが同じベースを持っているとか似ているとかいう理由だけでは、これらの資源の間に特殊な関係が存在すると仮定しないことに注意してください。example.comがこの関係について知っているかもしれませんが、RDFでは直接定義されません。）</p>

        <p>これらの例では、ウェブの基本構造原理の1つも示しています。<span class="newstuff">これは、<a name="LCC-019" id="LCC-019">だれでも</a>が好きな語彙を使用して既存の資源に関する情報を自由に加えることができるというものです</span><a href="#ref-berners-lee98">[BERNERS-LEE98]</a>。さらに、これらの例では、特定の資源を記述しているRDFをすべて1か所に置く必要はなく、ウェブ全体に分散できることを示しています。これは、ある組織が、別の組織が定義した資源を格付けしたりコメントしたりするような状況にのみ当てはまるのではなく、資源を最初に定義した人（または、他の誰か）が、その資源に関する情報を追加して資源の記述を拡充したい状況にも当てはまります。これは、資源を最初に記述したRDFドキュメントを変更し、情報を追記するために必要なプロパティーと値を追加することで行えます。あるいは、この例で示しているように、別のドキュメントを作成し、<code>rdf:about</code>を使用してURIrefを通じて最初の資源を参照する<code>rdf:Description</code>要素にプロパティーと値を追加することもできます。</p>

        <p>上の議論では、<code>#item10245</code>のような相対URIrefが<em>基底URI</em>と関連して解釈されるということを示しました。デフォルトでは、この基底URIは、相対URIrefが使用されている資源のURIです。しかし、この基底URIを明示的に指定できる方が良い場合もあります。例えば、example.orgが<code>http://www.example.com/2002/04/products</code>にあるカタログに加え、ミラーサイト、例えば<code>http://mirror.example.com/2002/04/products</code>でカタログの複製を提供したいと考えていると仮定してください。これは問題を引き起こします。なぜならば、ミラーサイトからカタログにアクセスした場合、例であげたテントに対するURIrefは、掲載されているドキュメントのURIから作成されるため、<code>http://www.example.com/2002/04/products#item10245</code>ではなく<code>http://mirror.example.com/2002/04/products#item10245</code>が作成され、したがって、明らかに意図した資源とは異なる資源を示すことになるからです。そうではなく、example.orgは、そのロケーションが基底を定義する1つのソース・ドキュメントを作成<em>せずに</em>、製品のURIrefの集合に基底URIrefを割り当てたい考えるかもしれませんと。</p>

        <p>このようなケースに対応するために、RDF/XMLでは、XMLドキュメントが自身のURI以外の基底URIを指定できる<a href="www.w3.org/TR/2001/REC-xmlbase-20010627/">XMLベース</a> <a href="#ref-xml-base">[XML-BASE]</a>をサポートしています。<a href="#example11">例11</a>では、XMLベースを使用してカタログを記述する方法を示しています。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example11" name="example11">例11: example.comのカタログにおけるXMLベースの使用</a>
          </div>

          <div class="exampleInner">
<pre>
1.   &lt;?xml version="1.0"?&gt;
2.   &lt;!DOCTYPE rdf:RDF [&lt;!ENTITY xsd "http://www.w3.org/2001/XMLSchema#"&gt;]&gt;
3.   &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
4.               xmlns:exterms="http://www.example.com/terms/"
5.               xml:base="http://www.example.com/2002/04/products"&gt;

6.     &lt;rdf:Description rdf:ID="item10245"&gt;
7.          &lt;exterms:model rdf:datatype="&amp;xsd;string"&gt;Overnighter&lt;/exterms:model&gt;
8.          &lt;exterms:sleeps rdf:datatype="&amp;xsd;integer"&gt;2&lt;/exterms:sleeps&gt;
9.          &lt;exterms:weight rdf:datatype="&amp;xsd;decimal"&gt;2.4&lt;/exterms:weight&gt;
10.         &lt;exterms:packedSize rdf:datatype="&amp;xsd;integer"&gt;784&lt;/exterms:packedSize&gt;
11.    &lt;/rdf:Description&gt;

  ...other product descriptions...

12.  &lt;/rdf:RDF&gt;
</pre>
          </div>
        </div>

        <p><a href="#example11">例11</a>の5行目の<code>xml:base</code>宣言では、<code>rdf:RDF</code>要素内のコンテンツに対する基底URIが<code>http://www.example.com/2002/04/products</code>であり（別の<code>xml:base</code>属性が指定されるまでは）、このコンテンツ内で引用されているすべての相対URIrefが、含んでいるドキュメントのURIがどのようなものであっても、そのベースに関連していると解釈されるということを明示しています。その結果、テントの相対URIrefである<code>#item10245</code>は、カタログ・ドキュメントの実際のURIがどのようなものであっても、または、基底URIrefが実際に特定のドキュメントを識別してもしなくても、同じ絶対URIref <code>http://www.example.com/2002/04/products#item10245</code>として解釈されます。</p>

        <p>今までの例では、example.comのカタログのテントの特定の型という1つの製品の記述を使用してきました。しかし、example.comでは、恐らくいくつかの異なる型のテントを提供するでしょうし、それに加えて、バックパックやハイキング・ブーツなどのような他の製品カテゴリーの複数のインスタンスも提供するでしょう。事物を異なる<em>種類</em>や<em>カテゴリー</em>に分類するというこの考えは、オブジェクトが異る<em>型</em>や<em>クラス</em>を持つというプログラミング言語の概念に似ています。RDFでは、<code>rdf:type</code>という定義済みプロパティーを提供することによってこの概念をサポートします。RDF資源を<code>rdf:type</code>プロパティーで記述すると、そのプロパティーの値は事物のカテゴリーや<em>クラス</em>を表現する資源であると見なされ、そのプロパティーの主語はそのカテゴリーやクラスの<em>インスタンス</em>であると考えられます。<a href="#example12">例12</a>では、製品の記述がテントに関するものであることを、example.comが<code>rdf:type</code>を使用してどのように示せるのかを表しています。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example12" name="example12">例12: <code>rdf:type</code>を使用したテントの記述</a>
</div>

          <div class="exampleInner">
<pre>1.   &lt;?xml version="1.0"?&gt;
2.   &lt;!DOCTYPE rdf:RDF [&lt;!ENTITY xsd "http://www.w3.org/2001/XMLSchema#"&gt;]&gt;
3.   &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
4.               xmlns:exterms="http://www.example.com/terms/"
5.               xml:base="http://www.example.com/2002/04/products"&gt;

6.     &lt;rdf:Description rdf:ID="item10245"&gt;
7.          &lt;rdf:type rdf:resource="http://www.example.com/terms/Tent"/&gt;
8.          &lt;exterms:model rdf:datatype="&amp;xsd;string"&gt;Overnighter&lt;/exterms:model&gt;
9.          &lt;exterms:sleeps rdf:datatype="&amp;xsd;integer"&gt;2&lt;/exterms:sleeps&gt;
10.         &lt;exterms:weight rdf:datatype="&amp;xsd;decimal"&gt;2.4&lt;/exterms:weight&gt;
11.         &lt;exterms:packedSize rdf:datatype="&amp;xsd;integer"&gt;784&lt;/exterms:packedSize&gt;
12.    &lt;/rdf:Description&gt;

  ...other product descriptions...

13.  &lt;/rdf:RDF&gt;</pre>
          </div>
        </div>

        <p><a href="#example12">例12</a>では、7行目の<code>rdf:type</code>のプロパティーは、記述されている資源がURIref <code>http://www.example.com/terms/Tent</code>で識別されるクラスのインスタンスであることを示しています。ここでは、example.comは、自社の他の用語（プロパティー<code>exterms:weight</code>のような）の記述に使用するのと同じ語彙の一部としてこのクラスを記述していたと仮定しており、そのため、このクラスの絶対URIrefを使用してこれを参照しています。example.comが製品カタログ自体の一部としてこれらのクラスを記述していたならば、相対URIref <code>#Tent</code>を使用してこれを参照できたでしょう。</p>

        <p>RDF自身は、この例の<code>Tent</code>のような事物や、そのプロパティーである<code>exterms:weight</code>のような事物をアプリケーション固有のクラスで定義する機能を提供しません。その代りに、そのようなクラスは、<a href="#rdfschema">5項</a>で論じたRDFスキーマ言語を使用して<em>RDFスキーマ</em>で記述します。<a href="#richerschemas">5.5項</a>で述べた<em>DAML+OIL</em>言語や<em>OWL</em>言語のような、クラスを記述するための他の機能も定義できます。</p>


        <p>RDFでは、資源がその資源を特定の型やクラスのインスタンスとして記述する<code>rdf:type</code>プロパティーを持っていることは、極めて普通のことです。このような資源を、グラフでは<em>型付きノード</em>（typed node）と呼び、一方、RDF/XMLでは<em>型付きノード要素</em>（typed node element）と呼びます。RDF/XMLでは、この型付きノードを記述するための特別な省略形を提供しています。この省略形では、<code>rdf:type</code>プロパティーとその値が削除され、ノードに対する<code>rdf:Description</code>要素は、この削除された<code>rdf:type</code>プロパティー（クラスを命名するURIref）の値に対応するQNameという名前を持つ要素に置き換えられます。この省略形を使用すると、<a href="#example12">例12</a>のexample.comのテントは<a href="#example13">例13</a>で示しているように記述することも可能です。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example13" name="example13">例13: テントの種類の省略形</a>
</div>

          <div class="exampleInner">
<pre>1.   &lt;?xml version="1.0"?&gt;
2.   &lt;!DOCTYPE rdf:RDF [&lt;!ENTITY xsd "http://www.w3.org/2001/XMLSchema#"&gt;]&gt;
3.   &lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
4.               xmlns:exterms="http://www.example.com/terms/"
5.               xml:base="http://www.example.com/2002/04/products"&gt;

6.     &lt;exterms:Tent rdf:ID="item10245"&gt;
7.          &lt;exterms:model rdf:datatype="&amp;xsd;string"&gt;Overnighter&lt;/exterms:model&gt;
8.          &lt;exterms:sleeps rdf:datatype="&amp;xsd;integer"&gt;2&lt;/exterms:sleeps&gt;
9.          &lt;exterms:weight rdf:datatype="&amp;xsd;decimal"&gt;2.4&lt;/exterms:weight&gt;
10.         &lt;exterms:packedSize rdf:datatype="&amp;xsd;integer"&gt;784&lt;/exterms:packedSize&gt;
11.    &lt;/exterms:Tent&gt;

  ...other product descriptions...

12.  &lt;/rdf:RDF&gt;
</pre>
          </div>
        </div>

<div class="newstuff">

        <p>資源は、複数のクラスのインスタンスとして記述できるため、複数の<code>rdf:type</code>プロパティーを持つことができます。しかし、この方法ではこれらの<code>rdf:type</code>プロパティーの1つしか省略形にできません。他のものは、<a href="#example12">例12</a>の<code>rdf:type</code>プロパティーで示した方法で、<code>rdf:type</code>を使用してすべて書き出さなければなりません。</p>
        
        <p><code>exterms:Tent</code>などのユーザ定義クラスのインスタンスを記述する際の使用に加え、<a href="#othercapabilities">4項</a>で述べた組み込みRDFのクラス（<code>rdf:Bag</code>のような）や、<a href="#rdfschema">5項</a>で述べた組み込みRDFスキーマ・クラス（<code>rdfs:Class</code>のような）のインスタンスを記述する場合に、RDF/XMLでは型付きノード省略も一般的に使用されます。</p>
</div>

        <p><a href="#example12">例12</a>と<a href="#example13">例13</a>はどちらも、（RDFではなく）XMLで直接書くのと極めて似た方法で、RDF/XMLでRDFステートメントを記述できるということを示しています。これは、情報の構造化方法に大きな変更を要さずにアプリケーションでRDFを使用できるということを意味するため、あらゆる種類のアプリケーションでXMLの使用が増加していることを考慮すると、重要な検討材料となります。</p>

      </div>

      <div class="section">
        <h3><a name="rdfxmlsummary" id="rdfxmlsummary">3.3 RDF/XMLの要約</a></h3>

        <p>上例では、RDF/XML構文の背景にある基本概念の一部について説明しました。これらの例では、有用なRDF/XMLを書き始めるのに十分な情報を提供しています。XMLでのRDFステートメントのモデリングの背景にある原理（<em>ストライピング</em>として知られている）に関するさらに徹底的な議論は、利用可能なその他のRDF/XML省略形や、XMLによるRDFの記述に関する詳細や例とともに、<a href="www.w3.org/TR/rdf-syntax-grammar/">RDF/XML構文仕様</a>（規範）<a href="#ref-rdf-syntax">[RDF-SYNTAX]</a>で提供します。</p>
      </div>
    </div>

    <div class="section">
      <h2>
<a id="othercapabilities" name="othercapabilities"></a>4. その他のRDFの性能</h2>

      <p>RDFでは、<span class="newstuff">一連の資源やRDFステートメントを表現するための組み込み型やプロパティー、プロパティー値としてXMLフラグメント（XML fragment）を表現する性能のような、</span>さらに多くの性能を提供しています。以下の項ではこれらの付加的な性能に関して記述しています。</p>

      <div class="section">
        <h3><a name="containers" id="containers">4.1 RDFコンテナ</a></h3>

        <p>事物の<em>グループ</em>を記述する必要がしばしばあります。例えば、数人の作者がある本を書いたと述べたり、あるコースの受講生やパッケージ内のソフトウェア・モジュールをリストアップする場合がこれに当たります。RDFでは、このようなグループを記述するために使用できる、いくつかの定義済みの（組み込み）型とプロパティーを提供しています。</p>

        <p>最初に、RDFでは、3つの定義済みの型（いくつかの定義済みプロパティーと一緒に）で構成される<em>コンテナ語彙</em>を提供しています。<em>コンテナ</em>は、事物を含んでいる資源です。含まれている事物を<em>メンバー</em>と呼びます。コンテナのメンバーは、資源（空白ノードを含む）あるいはリテラルであることができます。 RDFでは、以下の3種類のコンテナを定義しています。</p>

        <ul>
          <li><code>rdf:Bag</code></li>

          <li><code>rdf:Seq</code></li>

          <li><code>rdf:Alt</code></li>
        </ul>

        <p><em>Bag</em>（型<code>rdf:Bag</code>を持つ資源）は、資源やリテラルのグループを<span class="newstuff">表し</span>、複製のメンバーを恐らく含んでいますが、メンバーの順序は重要ではありません。例えば、Bagは、部品番号の項目の順序や処理が重要でない部品番号のグループを記述するために使用できます。</p>

        <p><em>順序</em>（Sequence）を意味する<em>Seq</em>（型<code>rdf:Seq</code>を持つ資源）は、資源やリテラルのグループを<span class="newstuff">表し</span>、複製のメンバーを恐らく含んでおり、メンバーの順序が重要です。例えば、Sequenceは、アルファベット順に維持しなければならないグループを記述するために使用できます。</p>

        <p><em>代替</em>（Alternative）を意味する<em>Alt</em>（型<code>rdf:Alt</code>を持つ資源）は、（通常は、プロパティーの1つの値に対する）<em>代替</em>である資源やリテラルのグループを<span class="newstuff">表し</span>ます。例えば、Altは、本のタイトルの別言語訳を記述したり、資源が掲載されている代替インターネット・サイトのリストを記述するために使用できます。Altコンテナを値として持つプロパティーを使用するアプリケーションは、グループのメンバーのどれか1つを適切であるとして選択できるということを認識する必要があります。</p>

        <p>これらのコンテナの型の1つとして資源を記述するために、資源には、定義済み資源である<code>rdf:Bag</code>、<code>rdf:Seq</code>、<code>rdf:Alt</code>のうちの1つ（適切なものであればどれでもよい）を値として持つ<code>rdf:type</code>プロパティーが付与されています。コンテナ資源（空白ノードまたはURIrefを持つ資源のどちらか）は、グループを全体として表します。コンテナの<em>メンバー</em>は、コンテナ資源を主語として、そして、そのメンバーを目的語として持つメンバーごとに<em>コンテナ・メンバーシップ・プロパティー</em>を定義することによって記述できます。これらのコンテナ・メンバーシップ・プロパティーは、<code>rdf:_<em>n</em></code>という形式名を持っており、<em>n</em>は、<code>rdf:_1</code>、<code>rdf:_2</code>、<code>rdf:_3</code>などのような、0が先行しない0以上の10進整数であり、特別にコンテナのメンバーを記述するために使用されます。コンテナ・メンバーシップ・プロパティーと<code>rdf:type</code>プロパティーに加え、コンテナ資源にはコンテナを記述するプロパティーは他にもあります。</p>

        <p>これらのコンテナの型が定義済みのRDF型やプロパティーを使用して記述される一方で、Altコンテナのメンバーは代替値であるなどの、これらのコンテナに関連している特別な意味は、<em>意図した</em>意味のみであるということを理解していることが重要です。これらの特別なコンテナ型とその定義は、事物のグループを記述する必要がある人々の間に共有の慣習を定める目的で提供されています。RDFが行うのは、RDFグラフを作成するために使用できる型とプロパティーを提供し、各型のコンテナを記述することのみです。RDFは、（<a href="#newresources">3.2項</a>で論じた）型<code>ex:Tent</code>の資源が何であるかを理解しないのと同じように、型<code>rdf:Bag</code>の資源が何であるかを理解するように作られていません。その都度、各型に伴う特別な意味に従って動作するようにアプリケーションを書かなければなりません。この点に関しては、以下の例で詳しく述べます。</p>

        <p>一般的に、プロパティーの値が事物のグループであるということを示すためにコンテナを使用します。例えば、「6.001のコースには、Amy、Mohamed、Johann、Maria、Phuongという生徒がいる」という文章を表現する場合、型<code>rdf:Bag</code>のコンテナを値として持つ（学生のグループを<span class="newstuff">意味</span>する）<code>s:students</code>プロパティーを（適切な語彙から）付与することによって記述できます。次に、コンテナ・メンバーシップ・プロパティーを使用しすれば、<a href="#figure14">図14</a>で示すRDFグラフのように、個々の学生がそのグループのメンバーであると識別できます。</p>

<div class="newstuff">
        <div class="figure">
          <img src="www.asahi-net.or.jp/~ax2s-kmtn/internet/rdf/fig14july12.png" alt="Bagコンテナのシンプルな記述"><br>
           <a id="figure14" name="figure14">図14: Bagコンテナのシンプルな記述</a>
        </div>

</div>

        <p>この例の<code>s:students</code>プロパティーの値がBagと記述されているため、グラフのメンバーシップ・プロパティーの名前に整数が含まれていても、学生のURIrefに付与されている順序は重要ではありません。メンバーシップ・プロパティーの名前の（明らかな）順番を無視するかどうかは、<code>rdf:Bag</code>コンテナを含んだグラフを作成、処理するアプリケーション次第です。</p>

        <p>RDF/XMLでは、このようなコンテナをより簡単に記述するために、いくつかの特別な構文と省略形を提供しています。例えば、<a href="#example14">例14</a>では、<a href="#figure14">図14</a>で示したグラフを記述しています。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example14" name="example14">例14: 学生のBagのRDF/XML</a>
          </div>

          <div class="exampleInner">
<pre>
&lt;?xml version="1.0"?&gt;
&lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
         xmlns:s="http://example.org/students/vocab#"&gt;

   &lt;rdf:Description rdf:about="http://example.org/courses/6.001"&gt;
      &lt;s:students&gt;
         &lt;rdf:Bag&gt;
            &lt;rdf:li rdf:resource="http://example.org/students/Amy"/&gt;
            &lt;rdf:li rdf:resource="http://example.org/students/Mohamed"/&gt;
            &lt;rdf:li rdf:resource="http://example.org/students/Johann"/&gt;
            &lt;rdf:li rdf:resource="http://example.org/students/Maria"/&gt;
            &lt;rdf:li rdf:resource="http://example.org/students/Phuong"/&gt;
         &lt;/rdf:Bag&gt;
      &lt;/s:students&gt;
   &lt;/rdf:Description&gt;
&lt;/rdf:RDF&gt;
</pre>
          </div>
        </div>

        <p><a href="#example14">例14</a>では、RDF/XMLは各メンバーシップ・プロパティーを明示的に番号付けする必要性を避けるための便宜的な要素として<code>rdf:li</code>を提供するということを示しています。<code>rdf:_1</code>、<code>rdf:_2</code>などの番号付けされたプロパティーは、対応するグラフを形成する時にこの<code>rdf:li</code>要素から生成されます。<code>rdf:li</code>という要素名は、HTMLの「リスト項目」（list item）という用語と調和するように選ばれました。また、<code>&lt;s:students&gt;</code>プロパティー要素内に入れ子にされている<code>&lt;rdf:Bag&gt;</code>要素の使用にも注意してください。<code>&lt;rdf:Bag&gt;</code>要素は、型のインスタンス（この場合、<code>rdf:Bag</code>のインスタンス）を記述する際に、<code>rdf:Description</code>要素と<code>rdf:type</code>要素の2つを1つの要素に置き換える、<a href="#example13">例13</a>で使用した省略形の別の例です。URIrefが指定されていないため、Bagは空白ノードです。<code>&lt;s:students&gt;</code>プロパティー要素内にBagを入れ子にすることは、空白ノードがこのプロパティーの値であることを省略形で示すための方法です。これらの省略形の詳細については、<a href="#ref-rdf-syntax">[RDF-SYNTAX]</a>で記述しています。</p>

        <p><code>rdf:Seq</code>コンテナのグラフ構造と、対応するRDF/XMLは<code>rdf:Bag</code>のものと似ています（唯一の違いは、<code>rdf:Seq</code>という型だけです）。繰り返しになりますが、<code>rdf:Seq</code>コンテナは順序を記述するためのものですが、整数値のプロパティー名の順序を適切に解釈するかどうかは、グラフを作成、処理するアプリケーション次第です。</p>

        <p>Altコンテナの例をあげると、「X11のソースコードは、ftp.example.orgや、ftp1.example.org、ftp2.example.orgに掲載されている」という文章は、<a href="#figure15">図15</a>のRDFグラフで表現できます。</p>

<div class="newstuff">
        <div class="figure">
          <img src="www.asahi-net.or.jp/~ax2s-kmtn/internet/rdf/fig15july12.png" alt="Altコンテナのシンプルな記述"><br>
           <a id="figure15" name="figure15">図15: Altコンテナのシンプルな記述</a>
        </div>
</div>

        <p><a href="#example15">例15</a>は、<a href="#figure15">図15</a>のグラフをどのようにRDF/XMLで記述できるかを示しています。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example15" name="example15">例15: AltコンテナのRDF/XML</a>
          </div>

          <div class="exampleInner">
<pre>
&lt;?xml version="1.0"?&gt;
&lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
         xmlns:s="http://example.org/packages/vocab#"&gt;

   &lt;rdf:Description rdf:about="http://example.org/packages/X11"&gt;
      &lt;s:DistributionSite&gt;
         &lt;rdf:Alt&gt;
            &lt;rdf:li rdf:resource="ftp://ftp.example.org"/&gt;
            &lt;rdf:li rdf:resource="ftp://ftp1.example.org"/&gt;
            &lt;rdf:li rdf:resource="ftp://ftp2.example.org"/&gt;
         &lt;/rdf:Alt&gt;
      &lt;/s:DistributionSite&gt;
   &lt;/rdf:Description&gt;
&lt;/rdf:RDF&gt;
</pre>
          </div>
        </div>

        <p>Altコンテナは、プロパティー<code>rdf:_1</code>で識別される少なくとも1つのメンバーを持つように作られています。このメンバーは、デフォルト値、または優先値とみなされるようになっています。<code>rdf:_1</code>で識別されるメンバー以外の要素の順序は重要ではありません。</p>

        <p><a href="#figure15">図15</a>のRDFは、<em>書いてあるとおり</em>、<code>s:DistributionSite</code>というサイト・プロパティーの値はAltコンテナ資源自身であると単に述べています。Altコンテナの<em>メンバー</em>の1つは<code>s:DistributionSite</code>サイト・プロパティーの値とみなされるとか、<code>ftp://ftp.example.org</code>はデフォルト値、または優先値であるといった、このグラフから読み取られる別の意味は、アプリケーションが理解できるAltコンテナの意味として組み込まれていなければならず、そして／または、特定のプロパティー（この場合、<code>s:DistributionSite</code>）に対して定義されている意味に組み込まれていなければならず、アプリケーションはこれも理解しなければなりません。</p>

        <p>Altコンテナは言語のタグ付けとの連結で頻繁に使用されます。（RDF/XMLでは、<a href="#ref-xml">[XML]</a>で定義されている<code>xml:lang</code>属性を使用して、要素コンテンツが特定の言語であることを示すことができます。<code>xml:lang</code>の使用に関しては、<a href="#ref-rdf-syntax">[RDF-SYNTAX]</a>で説明し、<a href="#prism">6.2項</a>で例示しています。）例えば、ある著作のタイトルが複数の言語に翻訳されている場合、各言語で表されたタイトルを表現するリテラルを持ったAltコンテナを指す<code>title</code>プロパティーを持つことができます。</p>

        <p>BagとAltが意図する意味の違いに関しては、「ハックルベリー・フィンの冒険」という本の原作者を検討することによって詳細に示すことができます。この本の著者は1人だけですが、この著者は2つの名前（Mark TwainとSamuel Clemens）を持っています。この著者を指定するためには、どちらの名前でも十分です。したがって、著者名にAltコンテナを使用すると、Bagを使用するよりも（2人の<em>別々の</em>著者がいることを意味しうる）正確に関係を表現できます。</p>

        <p>ユーザは、RDFコンテナ語彙を使用せずに、資源のグループを記述する方法を自由に選択できます。このRDFコンテナは、一般的に使用されている場合には、資源のグループを含むデータをより相互運用可能にしてくれる共通の定義として提供されているだけです。</p>

        <p>このRDFコンテナ型を使用するよりも明確な代替手段が存在することもあります。例えば、特定の資源と他の資源のグループとの関係は、同じプロパティーを使用して最初の資源を複数のステートメントの主語にすることによって示すことができます。これは、複数のメンバーを含んだコンテナを目的語として持つ1つのステートメントの主語である資源とは構造的に異なります。これらの2つの構造は同じ意味を持っている場合もあれば、そうでない場合もあります。ある状況においてどちらを使用するかは、この点を念頭に置いて選択する必要があります。</p>

        <p>一例として、以下の文章のような、作家とその出版物との関係を考えてみてください。</p>

        <blockquote>
          <p>Sueは、「Anthology of Time」と「Zoological Reasoning」「Gravitational Reflections」を著しました。</p>
        </blockquote>

        <p>この場合、同じ作家が別々に書いた3つの資源があります。これは、プロパティーを繰り返し使用して、以下のように表現できます。</p>

        <div class="exampleOuter exampleInner">
<pre>
exstaff:Sue   exterms:publication   ex:AnthologyOfTime .
exstaff:Sue   exterms:publication   ex:ZoologicalReasoning .
exstaff:Sue   exterms:publication   ex:GravitationalReflections .
</pre>
        </div>

        <p>この例では、同じ人物が書いたということ以外、これらの出版物間の関係は何も述べられていません。各ステートメントは独立した事実であるため、プロパティーを繰り返し使用することは合理的な選択といえます。しかし、これは、以下のように、Sueが書いた資源のグループのステートメントでも全く同じく合理的に表現できます。</p>

        <div class="exampleOuter exampleInner">
<pre>
exstaff:Sue   exterms:publication   _:z .
_:z           rdf:type              rdf:Bag .
_:z           rdf:_1                ex:AnthologyOfTime .
_:z           rdf:_2                ex:ZoologicalReasoning .
_:z           rdf:_3                ex:GravitationalReflections .
</pre>
        </div>

        <p>その一方で、以下の文章</p>

        <blockquote>
          <p>Fred、Wilma、Dinoというメンバーの議事運営委員会によって決議案が承認されました。</p>
        </blockquote>

        <p>は、委員会が<em>全体で</em>決議案を承認したと述べていますが、各委員が<em>個別に</em>決議案に賛成票を投じたとは必ずしも述べていません。この場合、この文章を以下のように3つの別々の<code>exterms:approvedBy</code>（委員ごとに1つの）ステートメントとしてモデル化すると、誤解を招く恐れがあります。</p>

        <div class="exampleOuter exampleInner">
<pre>
ex:resolution   exterms:approvedBy   ex:Fred .
ex:resolution   exterms:approvedBy   ex:Wilma .
ex:resolution   exterms:approvedBy   ex:Dino .
</pre>
        </div>

        <p>なぜならば、これらのステートメントは、各委員が個別に決議案を承認したと述べているからです。</p>

        <p>この場合、主語が決議案で、目的語が委員会自体である、1つの<code>exterms:approvedBy</code>ステートメントとして文章をモデル化する方が良いでしょう。以下のトリプルのように、委員会の委員をメンバーとするBagとして委員会の資源を記述できます。</p>

        <div class="exampleOuter exampleInner">
<pre>
ex:resolution       exterms:approvedBy   ex:rulesCommittee .
ex:rulesCommittee   rdf:type             rdf:Bag .
ex:rulesCommittee   rdf:_1               ex:Fred .
ex:rulesCommittee   rdf:_2               ex:Wilma .
ex:rulesCommittee   rdf:_3               ex:Dino .
</pre>
        </div>

        <p>RDFコンテナを使用する際には、ステートメントは、プログラミング言語のデータ構造のように、コンテナを<em>構築</em>していないということを理解することが重要です。その代わりに、ステートメントは、存在していると推定されるコンテナ（事物のグループ）を<em>記述</em>しています。例えば、上記の議事運営委員会の例では、RDFでそのように記述しているか否かに関係なく、議事運営委員会は順不同のグループです。例えば、資源<code>ex:rulesCommittee</code>は型<code>rdf:Bag</code>を持っていると述べることは、議事運営委員会がデータ構造であると述べているのでも、グループの委員を保持するための特定のデータ構造を構築しているのでもありません（委員を全く記述せずに議事運営委員会をBagとして記述できます）。そうではなく、議事運営委員会はBagコンテナに関連しているものに対応した特性を持っている、すなわち委員を持っており、その記述の順序は重要ではないと記述しています。同様に、コンテナ・メンバーシップ・プロパティーを使用すると、コンテナ資源は、ある事物をメンバーとして持つと単に記述していることになります。これは、メンバーとして記述されている事物<em>のみ</em>が、存在しているメンバーであると必ずしも述べているわけではありません。例えば、議事運営委員会を記述するために上で示したトリプルは、Fred、Wilma、Dinoが委員会のメンバーであると述べているだけで、彼ら<em>のみ</em>が委員会のメンバーであるとは述べていません。</p>

<div class="newstuff">
        <p>また、<a href="#example14">例14</a>と<a href="#example15">例15</a>では、関連するコンテナの型とは無関係に、コンテナを記述する際の共通の「パターン」を示しました（例えば、コンテナ自体を表現するために適切な<code>rdf:type</code>プロパティーで空白ノードを使用したり、連番付けされたコンテナ・メンバーシップ・プロパティーを生成するために<code>rdf:li</code>を使用した）。しかし、RDFでは、RDFコンテナ語彙を使用するこの特別な方法を<em>強制</em>しないため、この語彙を他の方法で使用できるということを理解することが重要です。例えば、空白ノードを使用するのではなく、URIrefを持っているコンテナ資源を使用する方が適切な場合もあります。<a name="LCC-026b" id="LCC-026b">さらに、</a>前の例で示した「整形式」（well-formed）の構造を持つグラフを記述せずに、コンテナ語彙を使用できます。例えば、<a href="#example16">例16</a>では、<a href="#figure15">例15</a>で示したAltコンテナに似たグラフのRDF/XMLを示していますが、<code>rdf:li</code>を使用してコンテナ・メンバーシップ・プロパティーを生成するのではなく、それを明示的に書きます。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example16" name="example16">例16: 「非整形式」（ill-formed）のAltコンテナのRDF/XML</a>
          </div>

          <div class="exampleInner">
<pre>
&lt;?xml version="1.0"?&gt;
&lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
         xmlns:s="http://example.org/packages/vocab#"&gt; 
 
 &lt;rdf:Description rdf:about="http://example.org/packages/X11"&gt;
    &lt;s:DistributionSite&gt;
       &lt;rdf:Alt&gt;
          &lt;rdf:type rdf:resource="http://www.w3.org/1999/02/22-rdf-syntax-ns#Bag"/&gt; 
          &lt;rdf:_2 rdf:resource="ftp://ftp.example.org"/&gt;
          &lt;rdf:_2 rdf:resource="ftp://ftp1.example.org"/&gt;
          &lt;rdf:_5 rdf:resource="ftp://ftp2.example.org"/&gt;
      &lt;/rdf:Alt&gt;
    &lt;/s:DistributionSite&gt;
 &lt;/rdf:Description&gt;
&lt;/rdf:RDF&gt;
</pre>
          </div>
        </div> 

        <p><a href="#ref-rdf-semantics">[RDF-SEMANTICS]</a>で指摘しているように、RDFではコンテナ語彙の使用に「整形式性」（well-formedness）の条件を課さないため、BagとAltの<em>両方</em>としてコンテナを記述しているにも関わらず、<a href="#example16">例16</a>は完全に正当で、このコンテナには、<code>rdf:_2</code>プロパティーの2つの異なる値があり、<code>rdf:_1</code>、<code>rdf:_3</code>、<code>rdf:_4</code>プロパティーがないと記述されています。</p>

        <p>その結果、コンテナが「整形式」であることを要するRDFアプリケーションが完全に強力であるためには、コンテナ語彙が適切に使用されていることを検証できるように書かれている必要があります。</p>
</div>

      </div>

      <div class="section">

        <h3><a name="collections" id="collections">4.2 RDFコレクション</a></h3>

        <p><a href="#containers">4.1項</a>で述べたコンテナの限界は、<em>閉じる</em>方法がない、すなわち「これらがコンテナのすべてのメンバーです」と述べる方法がないということです。<a href="#containers">4.1項</a>で指摘したように、コンテナは、識別された特定の資源がメンバーであると述べるだけで、他のメンバーが存在しないとは述べません。また、1つのグラフはメンバの一部を記述できますが、別のメンバーを記述する別のグラフがどこかに存在する可能性を排除できません。RDFでは、指定されたメンバーのみを含むグループをRDF<em>コレクション</em>の形式で記述する方法をサポートしています。RDFコレクションは、RDFグラフでリスト構造として表現した事物のグループです。このリスト構造は、定義済み型<code>rdf:List</code>、定義済みプロパティー<code>rdf:first</code>と<code>rdf:rest</code>、定義済み資源<code>rdf:nil</code>で構成される定義済みの<em>コレクション語彙</em>を使用して構成されています。</p>

        <p>これを例示すると、<a href="#figure16">図16</a>で示したグラフを使用して「コース6.001の生徒は、Amy、Mohamed、Johannです」という文章は、表現できます。</p>

<div class="newstuff">
        <div class="figure">
          <img src="www.asahi-net.or.jp/~ax2s-kmtn/internet/rdf/fig16bjuly12.png" alt="RDFコレクション（リスト構造）"><br>
           <a id="figure16" name="figure16">図16: RDFコレクション（リスト構造）</a>
        </div>

        <p>このグラフでは、<code>s:Amy</code>などのコレクションの各メンバーは、リストを表現する資源（この例では、空白ノード）を主語として持つ<code>rdf:first</code>プロパティーの目的語です。このリスト資源は、<code>rdf:rest</code>プロパティーによってリストの残りにリンクされています。リストの終わりは、資源<code>rdf:nil</code>を目的語として持っている<code>rdf:rest</code>プロパティーで示されます（資源<code>rdf:nil</code>は空のリストを表現し、型<code>rdf:List</code>であると定義されています）。この構造は、Lispプログラミング言語を知っている人には馴染みがあるでしょう。Lispと同様に、<code>rdf:first</code>プロパティーと<code>rdf:rest</code>プロパティーによってアプリケーションが構造をトラバースできます。このリスト構造を形成する各空白ノードは、グラフには明示されませんが、暗黙的に型<code>rdf:List</code>に属しています（すなわち、これらのノードはそれぞれ、定義済み型<code>rdf:List</code>を値として持つ<code>rdf:type</code>プロパティーを暗黙的に持っています）。RDFスキーマ言語<a href="#ref-rdf-vocabulary">[RDF-VOCABULARY]</a>は、プロパティー<code>rdf:first</code>と<code>rdf:rest</code>が型<code>rdf:List</code>に属する主語を持っていると定義するため、対応する<code>rdf:type</code>トリプルを何度も書き出さなくても、リストであるこれらのノードに関する情報は一般的に推論できます。</p>
</div>

        <p>RDF/XMLでは、この形式のグラフを使用してコレクションの記述が簡単になる特別な表記法を提供しています。RDF/XMLでは、コレクションは属性<code>rdf:parseType="Collection"</code>を持ち、コレクションのメンバーを表現する入れ子になった要素のグループを含むプロパティー要素で記述できます。<span class="newstuff">RDF/XMLでは、要素の内容が特別な方法で解釈されるということを示すために<code>rdf:parseType</code>属性を提供しています。この場合、<code>rdf:parseType="Collection"</code>属性は、囲み込まれた要素を使用して、対応するリスト構造をRDFグラフで作成しているということを示しています（<code>rdf:parseType</code>属性のその他の値に関しては、この入門書の後の項で述べます）。</span></p>

        <p><code>rdf:parseType="Collection"</code>がどのように作用するかを例示すると、<a href="#example17">例17</a>のRDF/XMLは、<a href="#figure16">図16</a>で示したRDFグラフになります。</p>

<div class="newstuff">

        <div class="exampleOuter">
          <div class="c1">
            <a id="example17" name="example17">例17: 学生のコレクションのRDF/XML</a>
          </div>
          <div class="exampleInner">
<pre>
&lt;?xml version="1.0"?&gt;
&lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
         xmlns:s="http://example.org/students/vocab#"&gt;

   &lt;rdf:Description rdf:about="http://example.org/courses/6.001"&gt;
      &lt;s:students rdf:parseType="Collection"&gt;
            &lt;rdf:Description rdf:about="http://example.org/students/Amy"/&gt;
            &lt;rdf:Description rdf:about="http://example.org/students/Mohamed"/&gt;
            &lt;rdf:Description rdf:about="http://example.org/students/Johann"/&gt;
      &lt;/s:students&gt;
   &lt;/rdf:Description&gt;
&lt;/rdf:RDF&gt;
</pre>
          </div>
        </div>

        <p>RDF/XMLで<code>rdf:parseType="Collection"</code>を使用すると、<a href="#figure16">図16</a>で示したようなリスト構造を常に定義します。すなわち、一定の長さがある固定された有限の項目リストで、<code>rdf:nil</code>で終了し、リスト構造自体に一意な「新しい」空白ノードを使用します。しかし、RDFは、RDFコレクション語彙を使用するこの特定の方法を<em>強制</em>しないため、他の方法でこの語彙を使用でき、その中には、リストや閉じたコレクションを記述しないものもあります。この理由を理解するためには、<a href="#figure16">図16</a>で示したグラフは、<a href="#example18">例18</a>のようにコレクション語彙を使用して、同じトリプルを「通常の表記法で」（<code>rdf:parseType="Collection"</code>を使用せずに）書き出すことによって、RDF/XMLでも書くことができるということに注意する必要があります。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example18" name="example18">例18: 「通常の表記法」による学生のコレクションのRDF/XML</a>
          </div>

          <div class="exampleInner">
<pre>
&lt;?xml version="1.0"?&gt;
&lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
         xmlns:s="http://example.org/students/vocab#"&gt; 

&lt;rdf:Description rdf:about="http://example.org/courses/6.001"&gt; 
   &lt;s:students rdf:nodeID="sch1"/&gt;
&lt;/rdf:Description&gt;
 
&lt;rdf:Description rdf:nodeID="sch1"&gt; 
   &lt;rdf:first rdf:resource="http://example.org/students/Amy"/&gt;
   &lt;rdf:rest rdf:nodeID="sch2"/&gt; 
&lt;/rdf:Description&gt;
 
&lt;rdf:Description rdf:nodeID="sch2"&gt; 
   &lt;rdf:first rdf:resource="http://example.org/students/Mohamed"/&gt;
   &lt;rdf:rest rdf:nodeID="sch3"/&gt; &lt;/rdf:Description&gt; 
&lt;rdf:Description rdf:nodeID="sch3"&gt; 
   &lt;rdf:first rdf:resource="http://example.org/students/Johann"/&gt;
   &lt;rdf:rest rdf:resource="http://www.w3.org/1999/02/22-rdf-syntax-ns#nil"/&gt; 
&lt;/rdf:Description&gt;
&lt;/rdf:RDF&gt;
</pre>
          </div>
        </div> 

        <p><a href="#ref-rdf-semantics">[RDF-SEMANTICS]</a>で指摘したように（そして、<a href="#containers">4.1項</a>で述べたコンテナ語彙の場合と同様に）、<a name="LCC-026a" id="LCC-026a">RDFはコレクション語彙の使用に「整形式性」の条件を課さない</a>ため、通常の表記法でトリプルを書く際に、<code>rdf:parseType="Collection"</code>を使用して自動的に生成される明確な構造の（well-structured）グラフ以外の構造を持つRDFグラフを定義できます。例えば、特定のノードが2つの異なる<code>rdf:first</code>プロパティーの値を持つと言明したり、末尾が分岐したりリストではない構造を作成したり、単にコレクションの記述の一部を省略することは、不正ではありません。また、通常の表記法でコレクション語彙を使用して定義したグラフは、リスト構造に一意な空白ノードではなく、リストの構成要素を識別するためにURIrefを使用できます。その場合には、コレクションが閉じないように、効果的に要素をコレクションに追加した他のグラフでトリプルを作成できるでしょう。</p>

        <p>その結果、コレクションが整形式であることを要するRDFアプリケーションが完全に強力であるためには、コレクション語彙が適切に使用されていることを検証できるように書かれている必要があります。さらに、RDFグラフの構造に制約を追加定義できる<a href="www.w3.org/TR/owl-ref/">OWL</a> <a href="#ref-owl">[OWL]</a>のような言語では、これらのケースの一部を除外できます。</p>
</div>

      </div>

      <div class="section">

        <h3><a name="reification" id="reification">4.3 RDFの具体化</a></h3>

<div class="newstuff">

        <p>RDFアプリケーションは、RDFを使用して他のRDFステートメントに関して記述する必要がある場合もあります。例えば、ステートメントをいつ作成したのかや、その他の類似の情報を記録する場合などです（これを「来歴」情報と呼ぶことがあります）。例えば、<a href="#newresources">3.2項</a>の<a href="#example9">例9</a>では、example.comが販売用に提供している、URIref <code>exproducts:item10245</code>を持つ特定のテントを記述しました。この記述で示したトリプルの1つは、以下の通り、テントの重さを記述したものでした。</p>

        <div class="exampleOuter exampleInner">
<pre>
exproducts:item10245   exterms:weight   "2.4"^^xsd:decimal .
</pre>
        </div>

<p>そして、誰がこの特定の情報を提供しているのかをexample.comが記録していると便利です。</p>

        <p>RDFでは、RDFステートメントを記述するための組み込み語彙を提供しています。この語彙を使用したステートメントの記述を、ステートメントの<em>具体化</em>（reification）と呼びます。RDF具体化語彙は、型<code>rdf:Statement</code>、プロパティー<code>rdf:subject</code>、<code>rdf:predicate</code>、<code>rdf:object</code>から成ります。しかし、RDFではこの具体化語彙を提供していますが、使用には注意が必要です。なぜならば、実際には定義されていない事物を語彙が定義していると推測しがちだからです。この点の詳細に関しては、この項の後半で論じます。</p>

        <p>具体化語彙を使用して、<code>exproducts:triple12345</code>のようなURIrefをステートメントに割り当て（したがって、テントの重さを記述したステートメントを書くことができる）、以下のように、ステートメントを使用してステートメントを記述することによって、テントの重さに関するステートメントを<em>具体化</em>できます。</p>

        <div class="exampleOuter exampleInner">
<pre>
exproducts:triple12345   rdf:type        rdf:Statement .
exproducts:triple12345   rdf:subject     exproducts:item10245 .
exproducts:triple12345   rdf:predicate   exterms:weight . 
exproducts:triple12345   rdf:object      "2.4"^^xsd:decimal .
</pre>
        </div>

        <p>これらのステートメントでは、URIref <code>exproducts:triple12345</code>で識別される資源はRDFステートメントであり、ステートメントの主語は<code>exproducts:item10245</code>で識別される資源を示し、ステートメントの述語は<code>exterms:weight</code>で識別される資源を示し、ステートメントの目的語は型付きリテラル<code>"2.4"^^xsd:decimal</code>で識別される十進数の値を示すと述べています。最初のステートメントが実際に<code>exproducts:triple12345</code>で識別されていると仮定すると、この最初のステートメントと具体化を比較することで、具体化が本当にそれを記述していることが明らかにならなければなりません。RDF具体化語彙を使用すると、通常は、常にこのパターンの4つのステートメントを使用してステートメントを記述することになり、そのため、この4つのステートメントを「具体化の四つ組み（reification quad）」と呼ぶことがあります。</p>

        <p>この規定に準じた具体化を使用して、example.comでは、まず、最初のステートメントをURIref（前と同じ、<code>exproducts:triple12345</code>など）に割り当てて先ほど説明した具体化を使用してステートメントを記述し、次に、John Smithが<code>exproducts:triple12345</code>を書いたという追加ステートメントを加えることによって（どのJohn Smithなのかを識別するためにURIrefを使用して）、John Smithがテントの重さに関する最初のステートメントを作成したという事実を記録できます。その結果、以下のようなステートメントになります。</p>

        <div class="exampleOuter exampleInner">
<pre>
exproducts:triple12345   rdf:type        rdf:Statement .
exproducts:triple12345   rdf:subject     exproducts:item10245 . 
exproducts:triple12345   rdf:predicate   exterms:weight . 
exproducts:triple12345   rdf:object      "2.4"^^xsd:decimal .
exproducts:triple12345   dc:creator      exstaff:85740 . 
</pre>
        </div>

       <p>最初のステートメントは、この具体化とJohn Smithに対するステートメントの属性と合わせると、<a href="#figure17">図17</a>で示すグラフになります。</p>

      <div class="figure">
        <img src="www.asahi-net.or.jp/~ax2s-kmtn/internet/rdf/reificationFigJul22.png" alt="ステートメントと具体化、その属性"><br>
         <a id="figure17" name="figure17">図17: ステートメントと具体化、その属性</a>
      </div>

       <p>このグラフは、<a href="#example19">例19</a>で示しているようなRDF/XMLで書くことができます。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example19" name="example19">例19: 具体化のRDF/XMLの例</a>
          </div>

          <div class="exampleInner">
<pre>
&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE rdf:RDF [&lt;!ENTITY xsd "http://www.w3.org/2001/XMLSchema#"&gt;]&gt;
&lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
            xmlns:dc="http://purl.org/dc/elements/1.1/"
            xmlns:exterms="http://www.example.com/terms/"
            xml:base="http://www.example.com/2002/04/products"&gt;

  &lt;rdf:Description rdf:ID="item10245"&gt;
     &lt;exterms:weight rdf:datatype="&amp;xsd;decimal"&gt;2.4&lt;/exterms:weight&gt;
  &lt;/rdf:Description&gt;

  &lt;rdf:Statement rdf:about="#triple12345"&gt;
     &lt;rdf:subject rdf:resource="http://www.example.com/2002/04/products#item10245"/&gt;
     &lt;rdf:predicate rdf:resource="http://www.example.com/terms/weight"/&gt;
     &lt;rdf:object rdf:datatype="&amp;xsd;decimal"&gt;2.4&lt;/rdf:object&gt;

     &lt;dc:creator rdf:resource="http://www.example.com/staffid/85740"/&gt;
  &lt;/rdf:Statement&gt;

&lt;/rdf:RDF&gt;
</pre>          </div>
        </div>

       <p><a href="#newresources">3.2項</a>では、<code>rdf:Description</code>要素でRDF/XMLの<code>rdf:ID</code>属性を使用してステートメントの主語のURIrefを省略する方法を紹介しました。プロパティー要素で<code>rdf:ID</code>を使用して、プロパティー要素が生成するトリプルの具体化を自動的に作成することもできます。<a href="#example20">例20</a>では、どのように<code>rdf:ID</code>を使用して<a href="#example19">例19</a>と同じグラフを作成できるかを示しています。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example20" name="example20">例20: <code>rdf:ID</code>を使用した具体化の生成</a>
</div>

          <div class="exampleInner">
<pre>
&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE rdf:RDF [&lt;!ENTITY xsd "http://www.w3.org/2001/XMLSchema#"&gt;]&gt;
&lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
            xmlns:dc="http://purl.org/dc/elements/1.1/"
            xmlns:exterms="http://www.example.com/terms/"
            xml:base="http://www.example.com/2002/04/products"&gt;

  &lt;rdf:Description rdf:ID="item10245"&gt;
     &lt;exterms:weight rdf:ID="triple12345" rdf:datatype="&amp;xsd;decimal"&gt;2.4
     &lt;/exterms:weight&gt;
  &lt;/rdf:Description&gt;

  &lt;rdf:Description rdf:about="#triple12345"&gt;
     &lt;dc:creator rdf:resource="http://www.example.com/staffid/85740"/&gt;
  &lt;/rdf:Description&gt;

&lt;/rdf:RDF&gt;
</pre>
          </div>
        </div>

       <p>この事例では、<code>exterms:weight</code>要素で属性<code>rdf:ID="triple12345"</code>を指定すると、以下のようなテントの重さを記述した最初のトリプルになります。</p>

        <div class="exampleOuter exampleInner">
<pre>
exproducts:item10245   exterms:weight   "2.4"^^xsd:decimal .</pre>
        </div>

       <p>さらに、以下のような具体化トリプルになります。</p>

        <div class="exampleOuter exampleInner">
<pre>
exproducts:triple12345   rdf:type        rdf:Statement .
exproducts:triple12345   rdf:subject     exproducts:item10245 .
exproducts:triple12345   rdf:predicate   exterms:weight . 
exproducts:triple12345   rdf:object      "2.4"^^xsd:decimal .
</pre>
        </div>

       <p>これらの具体化トリプルの主語は、ドキュメントの基底URI（<code>xml:base</code>宣言で示される）と、文字列「#」（これに続くものがフラグメント識別子であることを示すために）、そして<code>rdf:ID</code>属性の値を連結して形成したURIrefです。すなわち、トリプルは、前の例と同じ主語<code>exproducts:triple12345</code>を持っています。</p>

        <p>具体化を言明することは最初のステートメントを言明することと同じではなく、どちらももう一方を暗示しないことに注意してください。すなわち、Johnがテントの重さに関して何かを言ったと誰かが述べた場合、彼はテントの重さ自体に関するステートメントを作成しているのではなく、Johnが言ったことに関するステートメントを作成しているのです。逆に、誰かがテントの重さを記述する場合も、彼は、自作したステートメントに関するステートメントを作成しているのではありません（彼らには「ステートメント」と呼ばれるものに関して話す意図がないので）。</p>

       <p>上記のテキストでは、意図的に多くの場所で「具体化の慣用的な使用法」を示しています。以前に指摘したように、実際には定義されていない事物を語彙が定義していると推測しがちであるため、RDF具体化語彙の使用には注意が必要です。具体化をうまく使用するアプリケーションもありますが、これは、RDFが具体化語彙に対して定義する実際の意味と、RDFがこの語彙をサポートするために提供する実際機能に加えて、いくつかの慣用法に従い、いくつかの仮定をすることによって実現しているのです。</p> 

        <p>一例をあげると、具体化の慣用的な使用法では、具体化トリプルの主語は、同じ主語、述語、目的語を持っているある任意のトリプルではなく、特定のRDFドキュメントのトリプルの<em>特定のインスタンス</em>を識別すると思われることに注意することが重要です。既に例示したように、具体化は、作成日や情報源のデータなどのプロパティーを表現するためのものであり、これらのプロパティーをトリプルの特定のインスタンスに適用する必要があるため、このような特定の慣用法が使用されます。1つのグラフが1<em>組</em>のトリプルとして定義されていたとしても、同じ主語、述語、目的語を持ったいくつかのトリプルが存在することは可能で、同じトリプルの構造を持ったいくつかのインスタンスが異なるドキュメントに出現しえます。したがって、この慣用法を完全にサポートするためには、具体化トリプルの主語を<em>あるドキュメントの個体トリプル</em>に関連付ける何らかの手段が必要です。しかし、RDFは、これを行う方法を提供していません。</p>

       <p>例えば、上記の例では、テントの重さを記述している最初のステートメントは資源<code>exproducts:triple12345</code>で、この資源は4つの具体化ステートメントの主語であり、John Smithが作成したステートメントである、ということを実際に示している明示的な情報はトリプルにもRDF/XMLにもありません。これは、<a href="#figure17">図17</a>で示したグラフを見れば分かります。最初のステートメントは確かにこのグラフの一部ですが、グラフの情報に関する限り、<code>exproducts:triple12345</code>は別個の資源であり、グラフのその一部分を識別しているのではありません。RDFは、<code>exproducts:triple12345</code>のようなURIrefがどのように特定のステートメントやグラフと関連しているかを示す組み込み済みの手段を提供しないし、同じく、<code>exproducts:item10245</code>のようなURIrefがどのように実際のテントと関連しているかを示す組み込み済みの手段も提供しません。特定のURIrefを特定の資源（この場合は、ステートメント）に関連付けるには、RDFの以外のメカニズムを使用しなければなりません。</p>

          <p><a href="#example20">例20</a>で示したように<code>rdf:ID</code>を使用すれば、具体化が自動的に生成され、具体化におけるステートメントの主語としてURIrefが使用されていることを示す便利な方法が提供されます。さらに、<code>rdf:ID</code>属性の値<code>triple12345</code>が具体化トリプルの主語のURIrefを生成するために使用されるため、<code>rdf:ID</code>は、具体化におけるトリプルをそのトリプルを作成したRDF/XML構文の一部に関連付ける部分的な「フック」（hook）の機能を果たします。しかし、その結果生じるトリプルには最初のトリプルがURIref <code>exproducts:triple12345</code>を持っていたと明示的に述べるものが何もないため、この関係もまたRDF以外のものです（RDFは、使用されたり省略化されたURIrefとRDF/XMLとの間に関係があるとは見なしません）。</p>

        <p>URIrefをステートメントに割り当てるための組み込み済みの手段がないということは、この種の「来歴」情報をRDFで表現できないということを意味しているのではなく、RDFが具体化語彙と関連している意味のみを使用しても表現できないということを意味しているだけです。例えば、RDFドキュメント（例えば、ウェブ・ページ）にURIがある場合、このURIで識別される資源に関するステートメントを作成でき、このステートメントをどのように解釈すべきかに関するあるアプリケーションに依存した理解に基づいて、それらのステートメントがドキュメントのすべてのステートメントにわたって「分散している」（等しく適用されている）かのようにアプリケーションは動作できます。また、個々のRDFステートメントにURIを割り当てるための何らかのメカニズムが（RDFの外部に）存在している場合、これらのステートメントを識別するためにこれらのURIを使用し、これらの個々のステートメントに関するステートメントを確実に作成できます。しかし、これらの場合にも、必ずしも慣用的な方法で具体化語彙を使用する必要はないでしょう。</p>

        <p>これを理解するために、以下の最初のステートメント</p> 

        <div class="exampleOuter exampleInner">
<pre>
exproducts:item10245   exterms:weight   "2.4"^^xsd:decimal .
</pre>
        </div>
        <p>が、URIref <code>exproducts:triple12345</code>を持っていると仮定すれば、具体化語彙を使用しなくても（<code>exproducts:triple12345</code>が<code>rdf:type</code> <code>rdf:Statement</code>を持っていると記述することは役立つかもしれないが）、以下のステートメントだけで、ステートメントがJohn Smithによるものであると考えることができます。</p>

        <div class="exampleOuter exampleInner">
<pre>
exproducts:triple12345   dc:creator   exstaff:85740 .
</pre>
        </div>

        <p>さらに、上記で記述した慣用法に従って具体化語彙を直接使用でき、同様に、特定のトリプルをこの具体化に関連付ける方法に関してアプリケーションに依存した理解をすることもできます。しかし、このRDFを受け取る他のアプリケーションは、必ずしもこのアプリケーションに依存した理解を共有するわけではなく、したがって、必ずしも適切にグラフを解釈するわけではないでしょう。</p>

<p>ここで説明した具体化の解釈が、一部の言語で見られるような「引用」とは異なるものであることに注意することも重要です。そうではなく、具体化は、トリプルの特定のインスタンスとトリプルが示す資源との関係について記述します。具体化は、「このRDFトリプルは、この形式を持っている」と（引用のように）述べているのではなく、「このRDFトリプルは、これらの事物に関して述べている」と述べていると直観的に解することができます。例えば、この項で使用されている具体化の例では、最初のステートメントの<code>rdf:subject</code>を記述している以下のトリプル</p>

        <div class="exampleOuter exampleInner">
<pre>
exproducts:triple12345   rdf:subject   exproducts:item10245 .
</pre>
        </div>

<p>は、ステートメントの主語がURIref <code>exproducts:item10245</code>で識別される資源（テント）であると述べています。これは、引用のように、ステートメントの主語がURIref自体（すなわち、特定の文字で始まる文字列）であるとは述べて<em>いません</em>。</p>

</div>
      </div>

      <div class="section">

        <h3><a name="rdfvalue" id="rdfvalue">4.4 構造化された値: rdf:valueに関する詳細</a></h3>

        <p><a href="#structuredproperties">2.3項</a>では、RDFモデルが本来、<em>2項</em>関係のみをサポートするということを指摘しました。すなわち、ステートメントは2つの資源間の関係を指定します。例えば、以下のステートメント</p>
        <div class="exampleOuter exampleInner">
<pre>
exstaff:85740   exterms:manager   exstaff:62345 .
</pre>
        </div>

        <p>は、関係<code>exterms:manager</code>が2人の従業員の間（恐らく、1人がもう1人を管理する）で成立っていると述べています。</p>

        <p>しかし、より多項な関係（3つ以上の資源間の関係）を含む情報をRDFで表現する必要がある場合もあります。これに関する1つの例を<a href="#structuredproperties">2.3項</a>で論じました。そこでの問題は、John Smithと彼の住所情報との関係を表現することであり、John Smithの住所の値は、彼が住む通り、市、州、および郵便番号の構造化された値でした。これを関係として書くと、この住所は以下の形式の5項関係であることが分かります。</p>
        <p class="ptriple"><code>address(exstaff:85740, "1501 Grant
        Avenue", "Bedford", "Massachusetts", "01730")</code></p>

        <p><a href="#structuredproperties">2.3項</a>では、以下のトリプルのように、記述する集合物（ここでは、Johnの住所を表現する構成要素のグループ）を別個の資源として考え、以下のトリプルのように、その新しい資源に関する別々のステートメントを作成することによって、この種の構造化された情報をRDFで表現できることを指摘しました。</p>

        <div class="exampleOuter exampleInner">
<pre>
exstaff:85740   exterms:address        _:johnaddress .
_:johnaddress   exterms:street         "1501 Grant Avenue" .
_:johnaddress   exterms:city           "Bedford" .
_:johnaddress   exterms:state          "Massachusetts" .
_:johnaddress   exterms:postalCode     "01730" .
</pre>
        </div>

        <p>（ここでは、<code>_:johnaddress</code>はJohnの住所を表現している空白ノードの空白ノード識別子です。）</p>

        <p>これは、RDFのn項関係を表現する一般的な方法です。つまり、要素のうちの1つ（この場合、John）を選んで最初の関係の主語（この場合、<code>address</code>）として扱い、次に、中間の資源を指定して残りの関係を表現し（URLを割り当てたり、割り当てなかったりして）、その後に、その関係の残りの構成要素を表現するプロパティーをその新しい資源に付与します。</p>

        <p>Johnの住所の場合、構造化された値の個々の部分は、どれも<code>exterms:address</code>プロパティーの「主要な」値であるとは考えられず、住所のすべての部分は等しく値に寄与します。しかし、構造化された値の部分の1つが「主要な」値として考えられる場合もあり、その関係の他の部分は、主要な値を修飾する別のコンテキスト上の情報や他の情報を提供します。例えば、<a href="#newresources">3.2項</a>の<a href="#example9">例9</a>では、特定のテントの重さを、型付きリテラルを使用して<span class="newstuff">十進の値<em>2.4</em>として示しました</span>。つまり、以下のとおりです。</p>

        <div class="exampleOuter exampleInner">
<pre>exproduct:item10245   exterms:weight   "2.4"^^xsd:decimal .
</pre>
        </div>

        <p>実際には、重さのより完全な記述は、単なる十進の値<em>2.4</em>ではなく、<em>2.4キログラム</em>でしょう。このように述べるためには、<code>exterms:weight</code>プロパティーの値は、十進の値に対する型付きリテラルと測定単位の表示（キログラム）という、2つの構成要素を持つ必要があります。このような状況では、この十進の値は<code>exterms:weight</code>プロパティーの「主要な」値であるとみなすことができます。なぜならば、述べられていない単位の情報を補うために、この値は、コンテキストの理解に依存してしばしば単に型付きリテラルとして記録される（上記のトリプルのように）からです。</p>

        <p>RDFモデルでは、この種の修飾付きプロパティーの値は、単にもう1種類の構造化された値であるとみなすことができます。これを表現するために、別々の資源を使用して構造化された値（この場合、重さ）を全体として表現し、最初のステートメントの目的語として扱うことができます。次に、構造化された値の個々の部分を表現するプロパティーを、その資源に付与できます。この場合、十進数の値を表現する型付きリテラルに対するプロパティーと、単位に対するプロパティーがなければなりません。RDFは、定義済み<code>rdf:value</code>プロパティーを提供し、構造化された値の主要な値（もし、あれば）を記述します。そのため、この場合、型付きリテラルを<code>rdf:value</code>プロパティーの値として、資源<code>exunits:kilograms</code>を<code>exterms:units</code>プロパティーの値として付与できます（資源<code>exunits:kilograms</code>がexample.orgの語彙の一部として定義されていると仮定して）。結果として生じるトリプルは、以下のようになり、</p>

        <div class="exampleOuter exampleInner">
<pre>
exproduct:item10245   exterms:weight   _:weight10245 .
_:weight10245         rdf:value        "2.4"^^xsd:decimal .
_:weight10245         exterms:units    exunits:kilograms .
</pre>
        </div>

        <p><a href="#example21">例21</a>で示すRDF/XMLを使用して表現できます。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example21" name="example21">例21: <code>rdf:value</code>を使用したRDF/XML</a>
          </div>

          <div class="exampleInner">
<pre>
&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE rdf:RDF [&lt;!ENTITY xsd "http://www.w3.org/2001/XMLSchema#"&gt;]&gt;
&lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
            xmlns:exterms="http://www.example.org/terms/"&gt;

  &lt;rdf:Description rdf:about="http://www.example.com/2002/04/products#item10245"&gt;
     &lt;exterms:weight rdf:parseType="Resource"&gt;
       &lt;rdf:value rdf:datatype="&amp;xsd;decimal"&gt;2.4&lt;/rdf:value&gt;
       &lt;exterms:units rdf:resource="http://www.example.org/units/kilograms"/&gt;
     &lt;/exterms:weight&gt;
  &lt;/rdf:Description&gt;

&lt;/rdf:RDF&gt;
</pre>
          </div>
        </div>

        <p class="newstuff">また、<a href="#example21">例21</a>では、<a href="#collections">4.2項</a>で紹介した<code>rdf:parseType</code>属性の2番目の使用も例示しており、この場合は、<code>rdf:parseType="Resource"</code>です。<code>rdf:parseType="Resource"</code>属性は、入れ子なった<code>rdf:Description</code>を実際に書かなくても、要素のコンテンツが新しい（空白ノード）資源の記述として解釈されるということを示すために使用されます。この場合、<code>exterms:weight</code>プロパティー要素に使用される<code>rdf:parseType="Resource"</code>は、空白ノードが<code>exterms:weight</code>プロパティーの値として作成され、囲み込まれている要素（<code>rdf:value</code>と<code>exterms:units</code>）がその空白ノードのプロパティーを記述するということを示します。<code>rdf:parseType="Resource"</code>に関する詳細は、<a href="#ref-rdf-syntax">[RDF-SYNTAX]</a>で示します。</p>

        <p><code>rdf:value</code>プロパティーを使用して主要な値を付与し、プロパティーを追加使用してその値をより詳細に記述した分類体系やその他の情報を識別することによって、異なる分類体系やレイティング・システムからの値のみならず、どのような測定単位を使用した量でも同じアプローチを使用して表現できます。</p>

        <p>このような目的のために<code>rdf:value</code>を使用する必要はなく（例えば、<code>exterms:amount</code>のようなユーザ定義のプロパティー名を、<a href="#example21">例21</a>の<code>rdf:value</code>の代わりに使用できる）、RDFではいかなる特別な意味も<code>rdf:value</code>に関連づけません。このようなよく起こる状況では、<code>rdf:value</code>は、単に使用の便宜上、提供されます。</p>

<p>しかし、データベースやウェブにある（そして入門書の後半の例の）大量の既存のデータが、重さ、コストなどのようなプロパティーに対してシンプルな値の形式をとっているにもかかわらず、このようなシンプルな値ではこれらの値を適切に記述するにはしばしば不十分であるという原則は重要です。ウェブのような世界規模の環境では、プロパティーの値にアクセスする誰かが、使用されている単位（または、関連があるかもしれない他のコンテキストに依存した情報）を理解すると仮定することは、一般に安全では<em>ありません</em>。例えば、米国のサイトでは重さの値をポンドで示しますが、米国以外からこのデータにアクセスする人は、重さがキログラムで示されていると思うかもしれません。ウェブ環境でデータを正しく解釈するには、追加情報（単位情報などの）を明示的に記録する必要があります。これは、個々のアイテムや製品の記述か、一連のデータ（例えば、カタログやサイトにおけるすべてのデータ）の記述か、スキーマか（<a href="#rdfschema">5項</a>を参照）のいずれかで、<code>rdf:value</code>を使用したり、単位をプロパティー名に組み込んだり（例えば、<code>exterms:weightInKg</code>）、単位情報を含む特殊なデータ型を定義したり（例えば、<code>extypes:kilograms</code>）、他のユーザ定義のプロパティーを加えてこの情報を指定したり（例えば、<code>exterms:unitOfWeight</code>）といった、様々な方法で可能です。</p>

      </div>

<div class="newstuff">
      <div class="section">

        <h3><a name="xmlliterals" id="xmlliterals">4.5 XMLリテラル</a></h3>

       <p>プロパティーの値は、XMLのフラグメント、あるいはXMLマークアップを含んだテキストである必要がある場合があります。例えば、出版社が本や記事のタイトルを含んだRDFメタデータを維持していることがあります。このようなタイトルは、大抵はシンプルな文字列にすぎませんが、常にそうであるというわけではありません。例えば、数学の本のタイトルは、MathML <a href="#ref-mathml">[MATHML]</a>を使用して表現できる数学の公式を含んでいることがあります。また、タイトルには、ルビ注釈 <a href="#ref-ruby">[RUBY]</a>、または双方向レンダリングや特殊なグリフ異体字（例えば、<a href="#ref-charmod">[CHARMOD]</a>を参照）のような、その他の理由でマークアップを含むことができます。</p>


       <p>RDF/XMLでは、この種のリテラルを簡単に書くために特殊な表記法を提供しています。これは、<code>rdf:parseType</code>の3番目の値を使用して行います。要素に属性<code>rdf:parseType="Literal"</code>を付与することで、その要素のコンテンツがXMLフラグメントとして解釈されるということが示されます。<a href="#example22">例22</a>は、<code>rdf:parseType="Literal"</code>の使用例を示しています。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example22" name="example22">例22: XMLリテラルのRDF/XML</a>
          </div>

          <div class="exampleInner">
<pre>
&lt;?xml version="1.0"?&gt;
&lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
            xmlns:dc="http://purl.org/dc/elements/1.1/"
            xml:base="http://www.example.com/books"&gt;

  &lt;rdf:Description rdf:ID="book12345"&gt;
     &lt;dc:title rdf:parseType="Literal"&gt;
       &lt;span xml:lang="en"&gt;
         The &lt;em&gt;&amp;lt;br /&amp;gt;&lt;/em&gt; Element Considered Harmful.
       &lt;/span&gt;
     &lt;/dc:title&gt;
  &lt;/rdf:Description&gt;

&lt;/rdf:RDF&gt;
</pre>
          </div>
        </div>

      <p><a href="#example22">例22</a>のRDF/XMLでは、主語<code>ex:book12345</code>と述語<code>dc:title</code>を持つ1つのトリプルを含むグラフを記述しています。RDF/XMLにおける<code>rdf:parseType="Literal"</code>属性は、<code>&lt;dc:title&gt;</code>要素中のすべてのXMLが、<code>dc:title</code>プロパティーの値であるXMLフラグメントであるということを示します。このグラフでは、この値は型付きリテラルであり、そのデータ型、<code>rdf:XMLLiteral</code>は、特にXMLのフラグメントを表現するために<a href="#ref-rdf-concepts">[RDF-CONCEPTS]</a>で定義されています（XMLマークアップを含むことも含まないこともある文字シーケンスを含む）。XMLフラグメントは、XML排他的正規化勧告（XML Exclusive Canonicalization recommendation） <a href="#ref-xml-xc14n">[XML-XC14N]</a>に従って正規化されています。これによって、使用された名前空間の宣言がフラグメントへの追加、統一した文字のエスケーピングまたはアンエスケーピング、空要素タグの展開、その他の変換が生じます。（これらの理由のために、そして、トリプル表記法自体がさらなるエスケーピングを要するという事実のために、実際の型付きリテラルはここでは示していません。RDF/XMLでは、RDFユーザがこれらの変換を直接処理<em>しなくても</em>よいように、<code>rdf:parseType="Literal"</code>属性を提供しています。詳細に関心があれば、<a href="#ref-rdf-concepts">[RDF-CONCEPTS]</a>と<a href="#ref-rdf-syntax">[RDF-SYNTAX]</a>を参考にしてください。）<code>xml:lang</code>や<code>xml:base</code>のようなコンテキスト上の属性は、RDF/XMLドキュメントから引き継がれず、必要であれば、例で示したようにXMLフラグメントで明示的に指定しなければなりません。</p>

        <p>この例では、RDFデータを設計する際に注意しなければならないことを示しています。一見したところでは、タイトルがプレーン・リテラルとして最もよく表現されたシンプルな文字列であるように見え、後になってはじめて、一部のタイトルにマークアップが含まれていることが分かるでしょう。属性の値がマークアップを含んだり含まなかったりすることがあるような場合には、<code>rdf:parseType="Literal"</code>を全体に使用するか、ソフトウェアがプレーン・リテラルと型<code>rdf:XMLLiteral</code>のリテラルの両方をプロパティーの値として処理するかのどちらかでなければなりません。</p>
      </div>
</div>

    </div>

    <div class="section">

      <h2>
<a id="rdfschema" name="rdfschema"></a>5. RDF語彙の定義: RDFスキーマ</h2>

      <p>RDFは、名前付きプロパティーと値を使用して、資源に関するシンプルなステートメントを表現する方法を提供します。しかし、RDFユーザのコミュニティーには、<span class="newstuff">これらのステートメントで使用するための<em>語彙</em>（用語）を定義する性能、特に、</span>特定の種類やクラスの資源を記述していることを示す性能が必要で、これらの資源を記述する際に特定のプロパティー使用するでしょう。例えば、<a href="#newresources">3.2項</a>の例の会社、example.comは、<code>exterms:Tent</code>などのクラスを記述したいと考え、<code>exterms:model</code>や<code>exterms:weightInKg</code>、<code>exterms:packedSize</code>などのプロパティーを使用してこれを記述します（2.1項で論じたように、様々な「example」名前空間接頭辞を持つQNameは、これらの名前がRDFでは実際に<em>URI参照</em>であるということを気づかしてくれるものとして、ここではクラスやプロパティーの名前として使用されます）。同様に、書誌的な資源の記述に関心を持っている人々は、<code>ex2:Book</code>や<code>ex2:MagazineArticle</code>などのクラスを記述したいと考え、<code>ex2:author</code>や<code>ex2:title</code>、<code>ex2:subject</code>などのプロパティーを使用してこれらを記述します。他のアプリケーションでは、<code>ex3:Person</code>や<code>ex3:Company</code>などのクラス、そして<code>ex3:age</code>や<code>ex3:jobTitle</code>、<code>ex3:stockSymbol</code>、<code>ex3:numberOfEmployees</code>などのプロパティーを記述する必要があるかもしれません。<span class="newstuff">RDF自体は、このようなアプリケーション固有のクラスとプロパティーを定義するための手段を提供しません。その代わりに、このようなクラスとプロパティーは、<em>RDFスキーマ</em>と呼ばれる、<a href="www.w3.org/TR/rdf-schema/">RDF語彙記述言語1.0</a> <a href="#ref-rdf-vocabulary">[RDF-VOCABULARY]</a>によって提供されるRDFの拡張を使用して、RDF語彙として記述されます。</span></p>

      <p>RDFスキーマは、<code>exterms:Tent</code>や<code>ex2:Book</code>、<code>ex3:Person</code>のようなアプリケーション固有のクラス、そして<code>exterms:weightInKg</code>や<code>ex2:author</code>、<code>ex3:JobTitle</code>のようなプロパティーの語彙を提供しません。その代わりに、このようなクラスとプロパティーを<em>記述</em>し、どのクラスとプロパティーが一緒に使用されると予期されるかを示すために必要な機能を提供します（例えば、<code>ex3:Person</code>を記述する際にプロパティー<code>ex3:jobTitle</code>が使用されると述べる）。言い換えれば、RDFスキーマはRDFの<em>型システム</em>を提供します。RDFスキーマの型システムは、Javaなどのオブジェクト指向プログラミング言語の型システムに多少似ています。例えば、RDFスキーマでは、資源を1つ以上の<em>クラス</em>のインスタンスとして定義できます。さらに、クラスを階層的に組織化できます。例えば、クラス<code>ex:Dog</code>は、<code>ex:Animal</code>のサブクラスである<code>ex:Mammal</code>のサブクラスとして定義できます。つまり、クラス<code>ex:Dog</code>にある資源は、暗黙的に<code>ex:Animal</code>にもあるということを意味します。しかし、RDFクラスとプロパティーは、プログラミング言語の型とはある点で非常に異なっています。RDFクラスとプロパティーの記述は、情報を強制しなければならないという拘束を作成せずに、それらが記述するRDF資源に関する追加情報を提供します。この情報は、様々な方法で使用でき、これに関しては5.3項で論じます。</p>

      <p><span class="newstuff">RDFスキーマの機能自体は、RDF語彙の形式、つまり、自身の特別な意味を持つ特殊化した定義済みRDF資源として提供されます。RDFスキーマ語彙の資源には、接頭辞<code>http://www.w3.org/2000/01/rdf-schema#</code>（慣習上QName接頭辞<code>rdfs:</code>と関連する）を持つURIrefがあります。RDFスキーマ言語で書かれた語彙記述（スキーマ）は、正当なRDFグラフです。したがって、追加のRDFスキーマ語彙も処理するように書かれていないRDFソフトウェアは、スキーマを様々な資源とプロパティーから構成される正当なRDFグラフとして解釈できますが、RDFスキーマ用語の追加的な組み込み済みの意味は「理解」しないでしょう。これらの追加の意味を理解するためには、<code>rdf:</code>語彙だけでなく、それらの組み込み済みの意味と一緒に、<code>rdfs:</code>語彙も含んだ拡張言語を処理するようにRDFソフトウェアを書かなければなりません。この点に関しては、次の項で例示します。</span></p>

      <p>以下の項では、RDFスキーマの基本的な資源とプロパティーを例示します。</p>

      <div class="section">

        <h3><a name="schemaclasses" id="schemaclasses">5.1 クラスの記述</a></h3>

        <p>どんな種類の記述プロセスであっても、基礎段階は記述する様々な種類の事物を識別することです。RDFスキーマでは、この「事物の種類」を<em>クラス</em>と呼びます。RDFスキーマの<em>クラス</em>は、<em>型</em>や<em>カテゴリー</em>の類概念に相当し、Javaなどのオブジェクト指向プログラミング言語のクラスの概念に多少似ています。RDFのクラスは、ウェブ・ページ、人、文書形式、データベース、抽象概念などのような、ほぼすべてのカテゴリーの事物を表現するために使用できます。クラスは、RDFスキーマ資源<code>rdfs:Class</code>や<code>rdfs:Resource</code>、そしてプロパティー<code>rdf:type</code>や<code>rdfs:subClassOf</code>を使用して記述します。</p>        <p>例えば、<code>example.org</code>という組織が、RDFを使用して様々な種類の自動車に関する情報を提供したいと考えているとします。RDFスキーマでは、<code>example.org</code>は、まず最初に、自動車である事物のカテゴリーを表現するためにクラスが必要です。クラスに属する資源を、そのクラスの<em>インスタン</em>と呼びます。この場合、<code>example.org</code>は、このクラスのインスタンスを自動車である資源にしようとします。</p>

        <p>RDFスキーマでは、<em>クラス</em>は、値が資源<code>rdfs:Class</code>である<code>rdf:type</code>プロパティーを持つ資源です。そのため、自動車のクラスは、クラスにURIrefを割り当てることによって記述されます。例えば<code>ex:MotorVehicle</code>（<span class="newstuff"><code>ex:</code>を使用してURIref <code>http://www.example.org/schemas/vehicles</code>を表し、これはexample.orgの語彙のURIrefに対する接頭辞として使用される</span>）や、値が資源<code>rdfs:Class</code>である<code>rdf:type</code>プロパティーでその資源を記述する場合などです。つまり、<code>example.org</code>は、以下のようなRDFステートメントを書きます。</p>

        <div class="exampleOuter exampleInner">
<pre>ex:MotorVehicle   rdf:type   rdfs:Class .
</pre>
        </div>

        <p><a href="#newresources">3.2項</a>で示したように、プロパティー<code>rdf:type</code>は、資源がクラスのインスタンスであることを示すために使用されます。そのため、<code>ex:MotorVehicle</code>をクラスとして記述すると、資源<code>exthings:companyCar</code>は、以下のRDFステートメントによって自動車であると記述されるでしょう。</p>

        <div class="exampleOuter exampleInner">
<pre>
exthings:companyCar   rdf:type   ex:MotorVehicle .
</pre>
        </div>

        <p>（このステートメントでは、プロパティー名とインスタンス名の頭文字を小文字で書き、クラス名の頭文字は大文字で書くという一般的な慣習を採用しています。しかし、この慣習はRDFスキーマでは要求されません。<span class="newstuff">また、このステートメントでは、example.orgが事物のクラスと事物のインスタンスに対して別々の語彙を定義することに決めたと仮定しています。）</span></p>

        <p>資源<code>rdfs:Class</code>自体は、<code>rdfs:Class</code>の<code>rdf:type</code>を持っています。資源は、複数のクラスのインスタンスでありえます。</p>

        <p>クラス<code>ex:MotorVehicle</code>を記述した後に、<code>example.org</code>は、乗用車、バン、ミニバンなどの様々な特種用途の自動車を表現するクラスを追記したいと考えるかもしれません。これらのクラスは、新しいクラスごとにURIrefを割り当て、例えば以下の記述のように、これらの資源をクラスとして記述するRDFステートメントを書くことによって、クラス<code>ex:MotorVehicle</code>と同じ方法で記述できます。</p>

        <div class="exampleOuter exampleInner">
<pre>
ex:Van     rdf:type   rdfs:Class .
ex:Truck   rdf:type   rdfs:Class .
</pre>
        </div>

        <p>しかし、これらのステートメント自体は、個々のクラスを記述するだけです。<code>example.org</code>は、クラス<code>ex:MotorVehicle</code>との特別な関係、すなわち、これらが特別な<em>種類</em>のMotorVehicle（自動車）であるということも示したいと考えるかもしれません。</p>

        <p>2つのクラス間のこの種の特別な関係は、定義済みの<code>rdfs:subClassOf</code>プロパティーを使用して2つのクラスを関連づけて記述します。例えば、<code>ex:Van</code>が特種な<code>ex:MotorVehicle</code>であると述べるために、<code>example.org</code>は以下のRDFステートメントを書くでしょう。</p>

        <div class="exampleOuter exampleInner">
<pre>
ex:Van   rdfs:subClassOf   ex:MotorVehicle .
</pre>
        </div>

        <p>この<code>rdfs:subClassOf</code>関係が意味するのは、クラスの<code>ex:Van</code>の任意のインスタンスはクラス<code>ex:MotorVehicle</code>のインスタンスでもあるということです。<span class="newstuff">そのため、資源<code>exthings:companyVan</code>が<code>ex:Van</code>のインスタンスである場合、宣言した<code>rdfs:subClassOf</code>関係に基づき、RDFスキーマ語彙を理解するように書かれたRDFソフトウェアは、<code>exthings:companyVan</code>が<code>ex:MotorVehicle</code>のインスタンスでもあるという追加情報を<a name="LCC-015" id="LCC-015">推論</a>できます。</span></p>

        <p class="newstuff">この<code>exthings:companyVan</code>の例は、前に指摘した拡張言語を定義したRDFスキーマに関するポイントを示しています。RDF自体は、<code>rdfs:subClassOf</code>などのRDFスキーマ語彙の用語に特別な意味を定義しません。そのため、RDFスキーマが<code>ex:Van</code>と<code>ex:MotorVehicle</code>の間のこの<code>rdfs:subClassOf</code>関係を定義する場合、RDFスキーマ用語を理解するように書かれていないRDFソフトウェアは、これが述語<code>rdfs:subClassOf</code>を持ったトリプルであるとは認識するでしょうが、<code>rdfs:subClassOf</code>の特別な意味は理解せず、<code>exthings:companyVan</code>が<code>ex:MotorVehicle</code>でもあるという追加の推論を導くことはできないでしょう。</p>

        <p><code>rdfs:subClassOf</code>プロパティーは<em>推移的</em>です。これは、例えば以下のRDFステートメントがある場合、</p>

        <div class="exampleOuter exampleInner">
<pre>
ex:Van       rdfs:subClassOf   ex:MotorVehicle .
ex:MiniVan   rdfs:subClassOf   ex:Van .
</pre>
        </div>

        <p class="newstuff">RDFスキーマは、<code>ex:MiniVan</code>を<code>ex:MotorVehicle</code>のサブクラスでもあると定義しているということを意味します。その結果、RDFスキーマは、クラス<code>ex:MiniVan</code>のインスタンスである資源を、クラス<code>ex:MotorVehicle</code>のインスタンスでもある（同様に、クラス<code>ex:Van</code>のインスタンスでもある）と定義します。クラスは、複数のクラスのサブクラスでありえます（例えば、<code>ex:MiniVan</code>は<code>ex:Van</code>と<code>ex:PassengerVehicle</code>の両方のサブクラスでありえます）。RDFスキーマでは、すべてのクラスをクラス<code>rdfs:Resource</code>のサブクラスとして定義します（すべてのクラスに属しているインスタンスは資源であるため）。</p>

        <p><a href="#figure18">図18</a>では、これらの例で論じているクラス階層の全体を示しています。</p>

<div class="newstuff">
        <div class="figure">
          <img src="www.asahi-net.or.jp/~ax2s-kmtn/internet/rdf/vehicleClassesJan12.png" alt="自動車のクラス階層"><br>
           <a id="figure18" name="figure18">図18: 自動車のクラス階層</a>
        </div>

        <p>（図を簡略化するために、各クラスを<code>rdfs:Class</code>に関連付ける<code>rdf:type</code>プロパティーは、<a href="#figure18">図18</a>では省略しています。実際には、RDFスキーマでは、<code>rdfs:subClassOf</code>プロパティーを型<code>rdfs:Class</code>の資源として使用するステートメントの主語と目的語の両方を定義するため、この情報を推論できます。しかし、実際にスキーマを書く際には、この情報を明示的に提供する方が望ましいです。)</p> 
         
</div>

        <p>このスキーマは、以下のトリプルでも記述できます。</p>

        <div class="exampleOuter exampleInner">
<pre>
ex:MotorVehicle       rdf:type          rdfs:Class .
ex:PassengerVehicle   rdf:type          rdfs:Class .
ex:Van                rdf:type          rdfs:Class .
ex:Truck              rdf:type          rdfs:Class .
ex:MiniVan            rdf:type          rdfs:Class .

ex:PassengerVehicle   rdfs:subClassOf   ex:MotorVehicle .
ex:Van                rdfs:subClassOf   ex:MotorVehicle .
ex:Truck              rdfs:subClassOf   ex:MotorVehicle .

ex:MiniVan            rdfs:subClassOf   ex:Van .
ex:MiniVan            rdfs:subClassOf   ex:PassengerVehicle .
</pre>
        </div>

        <p><a href="#example23">例23</a>では、このスキーマをどのようにRDF/XMLで記述できるかを示しています。</p>
        <div class="exampleOuter">
          <div class="c1">
            <a id="example23" name="example23">例23: RDF/XMLにおける自動車のクラス階層</a>
          </div>

          <div class="exampleInner">
<pre>
&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE rdf:RDF [&lt;!ENTITY xsd "http://www.w3.org/2001/XMLSchema#"&gt;]&gt;
&lt;rdf:RDF   
  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"  
  xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
  xml:base="http://example.org/schemas/vehicles"&gt;

&lt;rdf:Description rdf:ID="MotorVehicle"&gt;
  &lt;rdf:type rdf:resource="http://www.w3.org/2000/01/rdf-schema#Class"/&gt;
&lt;/rdf:Description&gt;

&lt;rdf:Description rdf:ID="PassengerVehicle"&gt;
  &lt;rdf:type rdf:resource="http://www.w3.org/2000/01/rdf-schema#Class"/&gt;
  &lt;rdfs:subClassOf rdf:resource="#MotorVehicle"/&gt;
&lt;/rdf:Description&gt;

&lt;rdf:Description rdf:ID="Truck"&gt;
  &lt;rdf:type rdf:resource="http://www.w3.org/2000/01/rdf-schema#Class"/&gt;
  &lt;rdfs:subClassOf rdf:resource="#MotorVehicle"/&gt;
&lt;/rdf:Description&gt;

&lt;rdf:Description rdf:ID="Van"&gt;
  &lt;rdf:type rdf:resource="http://www.w3.org/2000/01/rdf-schema#Class"/&gt;
  &lt;rdfs:subClassOf rdf:resource="#MotorVehicle"/&gt;
&lt;/rdf:Description&gt;

&lt;rdf:Description rdf:ID="MiniVan"&gt;
  &lt;rdf:type rdf:resource="http://www.w3.org/2000/01/rdf-schema#Class"/&gt;
  &lt;rdfs:subClassOf rdf:resource="#Van"/&gt;
  &lt;rdfs:subClassOf rdf:resource="#PassengerVehicle"/&gt;
&lt;/rdf:Description&gt;

&lt;/rdf:RDF&gt;
</pre>
          </div>
        </div>

<div class="newstuff">

       <p><a href="#example13">例13</a>に関連して<a href="#newresources">3.2</a>で論じたように、RDF/XMLでは、<code>rdf:type</code>プロパティー（<em>型付きノード</em>）持った資源を記述するための省略形を提供しています。RDFスキーマのクラスはRDF資源であるため、この省略形を適用してクラスを記述できます。この省略形を使用すれば、スキーマは<a href="#example24">例24</a>のように記述することもできます。</p>
        <div class="exampleOuter">
          <div class="c1">
            <a id="example24" name="example24">例24: 型付きノード省略を使用した自動車のクラス階層</a>
          </div>

          <div class="exampleInner">
<pre>
&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE rdf:RDF [&lt;!ENTITY xsd "http://www.w3.org/2001/XMLSchema#"&gt;]&gt;
&lt;rdf:RDF   
  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"  
  xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
  xml:base="http://example.org/schemas/vehicles"&gt;

&lt;rdfs:Class rdf:ID="MotorVehicle"/&gt;

&lt;rdfs:Class rdf:ID="PassengerVehicle"&gt;
  &lt;rdfs:subClassOf rdf:resource="#MotorVehicle"/&gt;
&lt;/rdfs:Class&gt;

&lt;rdfs:Class rdf:ID="Truck"&gt;
  &lt;rdfs:subClassOf rdf:resource="#MotorVehicle"/&gt;
&lt;/rdfs:Class&gt;

&lt;rdfs:Class rdf:ID="Van"&gt;
  &lt;rdfs:subClassOf rdf:resource="#MotorVehicle"/&gt;
&lt;/rdfs:Class&gt;

&lt;rdfs:Class rdf:ID="MiniVan"&gt;
  &lt;rdfs:subClassOf rdf:resource="#Van"/&gt;  &lt;rdfs:subClassOf rdf:resource="#PassengerVehicle"/&gt;&lt;/rdfs:Class&gt;

&lt;/rdf:RDF&gt;
</pre>
          </div>
        </div>

        <p>この項の残りでは、同様の型付きノード省略を使用します。</p>
</div>

        <p><a href="#example23">例23</a>と<a href="#example24">例24</a>のRDF/XMLでは、<a href="#newresources">3.2項</a>で述べたように、スキーマ・ドキュメントに関連するURIrefを「割り当てる」効果を出すために、<code>rdf:ID</code>を使用して記述した資源（クラス）に対し、<code>MotorVehicle</code>などの名前を導入しています。<span class="newstuff">ここでは<code>rdf:ID</code>は有用です。なぜならば、URIrefを省略するだけでなく、<code>rdf:ID</code>属性の値が現在の基底URI（通常、ドキュメントのURI）に対して一意であるということを追加確認できるからです。これは、RDFスキーマでクラス名とプロパティー名を定義する時に、繰り返されている<code>rdf:ID</code>の値を見つけ出すのに役立ちます。</span>その結果、これらの名前に基づく相対URIrefを同じスキーマ中の他のクラス定義に使用できます（例えば、<code>#MotorVehicle</code>は、他のクラスの記述に使用される）。スキーマ自体が資源<code>http://example.org/schemas/vehicles</code>であると仮定すると、このクラスの完全なURIrefは、<code>http://example.org/schemas/vehicles#MotorVehicle</code>になりますう（<a href="#figure18">図18</a>で示したように）。<a href="#newresources">3.2項</a>で述べたように、スキーマが移動したりコピーされたりしても、これらのスキーマのクラスへの参照が一貫して維持されることを保証するために（あるいは、スキーマ・クラスがすべて1か所で公開されているとは仮定しないで、ただ単にこれらのスキーマ・クラスに対して基底URIrefを割り当てるために）、クラス記述に明示的な<code>xml:base="http://example.org/schemas/vehicles"</code>宣言を含むこともできます。<span class="newstuff">明示的な<code>xml:base</code>宣言の使用は、望ましいと考えられ、どちらの例でも提供しています。</span></p>

        <p>他の場所にあるRDFインスタンス・データ（例えば、これらのクラスの個々の自動車を記述したデータ）でこれらのクラスを参照するためには、<code>example.org</code>は、<span class="newstuff">絶対URIrefを書くか、相対URIrefを適切な<code>xml:base</code>宣言と共に使用するか、QNameを適切なURIrefに展開してくれる適切な名前空間宣言と共にQNameを使用するかのいずれかの方法により、クラスを識別する必要があります。</span>例えば、資源<code>exthings:companyCar</code>は、<a href="#example25">例25</a>で示すRDF/XMLによって、<a href="#example24">例24</a>のスキーマで記述したクラス<code>ex:MotorVehicle</code>のインスタンスとして記述できます。</p>

<div class="newstuff">
        <div class="exampleOuter">
          <div class="c1">
            <a id="example25" name="example25">例25: <code>ex:MotorVehicle</code>のインスタンス
</a>
          </div>

          <div class="exampleInner">
<pre>
&lt;?xml version="1.0"?&gt;
&lt;rdf:RDF   
  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"  
  xmlns:ex="http://example.org/schemas/vehicles#"
  xml:base="http://example.org/things"&gt;

   &lt;ex:MotorVehicle rdf:ID="companyCar"/&gt;

&lt;/rdf:RDF&gt;
</pre>
          </div>
        </div>

       <p>QName <code>ex:MotorVehicle</code>は、名前空間宣<code>xmlns:ex="http://example.org/schemas/vehicles#"</code>を使用して展開すれば、完全なURIref <code>http://example.org/schemas/vehicles#MotorVehicle</code>になり、これは<a href="#figure18">図18</a>で示したように<code>MotorVehicle</code>クラスに対する正しいURIrefであるということに注意してください。<code>xml:base</code>宣言<code>xml:base="http://example.org/things"</code>を提供して、<code>rdf:ID="companyCar"</code>を適切な<code>exthings:companyCar</code>に展開できます（QNameを<code>rdf:ID</code>属性の値として使用できないので）。</p> 
</div>
      </div>

      <div class="section">

        <h3><a id="properties" name="properties">5.2 プロパティーの記述</a></h3>

        <p>記述したい事物の特定の<em>クラス</em>の記述に加え、ユーザ・コミュニティーは事物（乗用車を記述するための<code>rearSeatLegRoom</code>など）のクラスを特徴づける特定の<em>プロパティー</em>を記述できなければなりません。RDFスキーマでは、プロパティーは、RDFのクラス<code>rdf:Property</code>と、RDFスキーマ・プロパティー<code>rdfs:domain</code>、<code>rdfs:range</code>、<code>rdfs:subPropertyOf</code>を使用して記述されます。</p>

        <p>RDFのすべてのプロパティーは、クラス<code>rdf:Property</code>のインスタンスとして記述されます。そのため、<code>exterms:weightInKg</code>などの新しいプロパティーは、プロパティーにURIrefを割り当て、資源<code>rdf:Property</code>を値として持つ<code>rdf:type</code>プロパティーでその資源を記述することによって、例えば以下のようなRDFステートメントを書くこによって記述されます。</p>

        <div class="exampleOuter exampleInner">
<pre>
exterms:weightInKg   rdf:type   rdf:Property .
</pre>
        </div>

        <p>RDFスキーマでは、RDFデータでプロパティーとクラスがどのような意図で一緒に使用されるかを記述するための語彙も提供します。この種の最も重要な情報は、RDFスキーマ・プロパティー<code>rdfs:range</code>と<code>rdfs:domain</code>を使用してアプリケーション固有のプロパティーを詳細に記述することによって供されます。</p>

        <p><code>rdfs:range</code>プロパティーは、特定のプロパティーの値が指定されたクラスのインスタンスであることを示すために使用されます。例えば、<code>example.org</code>が、プロパティー<code>ex:author</code>がクラス<code>ex:Person</code>のインスタンスである値を持っているということを示したい場合、以下のRDFステートメントを書くでしょう。</p>

        <div class="exampleOuter exampleInner">
<pre>
ex:Person   rdf:type     rdfs:Class .
ex:author   rdf:type     rdf:Property .
ex:author   rdfs:range   ex:Person .
</pre>
        </div>

        <p>これらのステートメントでは、<code>ex:Person</code>がクラスで、<code>ex:author</code>がプロパティーであり、<code>ex:author</code>プロパティーを使用しているRDFステートメントが<code>ex:Person</code>のインスタンスを目的語として持っているということ示しています。</p>

        <p>例えば、プロパティー<code>ex:hasMother</code>は、0や1、または複数の。定義域プロパティーを持つことができます。<code>ex:hasMother</code>が定義域プロパティーを持っていない場合、<code>ex:hasMother</code>プロパティーの値に関して何も述べることはあません。<code>ex:hasMother</code>が、例えば<code>ex:Person</code>を範囲として指定するものなどの、1つの定義域プロパティーを持っている場合、<code>ex:hasMother</code>プロパティーの値がクラス<code>ex:Person</code>のインスタンスであるということを示します。<code>ex:hasMother</code>が、例えば1つが<code>ex:Person</code>をその範囲として指定するもので、もう1つが<code>ex:Female</code>をその範囲として指定するものであるなど、複数の定義域プロパティーを持っている場合、<code>ex:hasMother</code>プロパティーの値が範囲として指定された<em>すべて</em>のクラスのインスタンスである資源ということ、すなわち、<code>ex:hasMother</code>のいずれの値も<code>ex:Female</code><em>および</em><code>ex:Person</code>の<em>両方</em>であるということを示します。</p>

<div class="newstuff">
        <p>この最後の点は明白でないかもしれません。しかし、プロパティー<code>ex:hasMother</code>が<code>ex:Female</code>と<code>ex:Person</code>という2つの範囲を持つと述べることには、以下の2つの別々のステートメントを出すことが伴います。</p>

        <div class="exampleOuter exampleInner">
<pre>ex:hasMother   rdfs:range   ex:Female .ex:hasMother   rdfs:range   ex:Person .
</pre>
        </div>
        <p>例えば、以下のような、このプロパティーを使用するあるステートメントに関して、</p>

        <div class="exampleOuter exampleInner">
<pre>
exstaff:frank   ex:hasMother   exstaff:frances .
</pre>
        </div>

        <p><em>両方</em>の<code>rdfs:range</code>ステートメントが正しいものであるためには、<code>exstaff:frances</code>が<code>ex:Female</code>および<code>ex:Person</code>の<em>両方</em>である場合でなけばなりません。</p>
</div>

        <p><code>rdfs:range</code>プロパティーは、<a href="#typedliterals">2.4項</a>で論じたように、プロパティーの値が型付きリテラルによって付与されたということを示すために使用できます。例えば、プロパティー<code>ex:age</code>はXMLスキーマ・データ型<code>xsd:integer</code>の値を持つということを、<code>example.org</code>が示したい場合、以下のようなRDFステートメントを書くでしょう。</p>

        <div class="exampleOuter exampleInner">
<pre>
ex:age   rdf:type     rdf:Property .
ex:age   rdfs:range   xsd:integer .</pre>
        </div>

        <p>データ型<code>xsd:integer</code>は、自身のURIrefで識別されます（完全なURIrefは、<code>http://www.w3.org/2001/XMLSchema#integer</code>です）。このURIrefは、これがデータ型を識別するとスキーマで明示的に述べなくても使用できます。しかし、特定のURIrefがデータ型を識別すると明示的に述べることは多くの場合役立ちます。これは、RDFスキーマのクラス<code>rdfs:Datatype</code>を使用することで行えます。<code>example.org</code>は、<code>xsd:integer</code>がデータ型であると述べるために、以下のRDFステートメントを書くでしょう。</p>
        <div class="exampleOuter exampleInner">
<pre>
xsd:integer   rdf:type   rdfs:Datatype .
</pre>
        </div>

        <p>このステートメントでは、<code>xsd:integer</code>がデータ型のURIrefであると述べています（<a href="#ref-rdf-concepts">[RDF-CONCEPTS]</a>に記述されているRDFデータ型の要件に従っていると思われる）。このようなステートメントは、例えば<code>example.org</code>が新しいデータ型を定義しているという意味で、データ型の<em>定義</em>を制定<em>しません</em>。RDFスキーマでデータ型を定義する方法はありません。<a href="#typedliterals">2.4項</a>で指摘したように、データ型はRDF（および、RDFスキーマ）の外部で定義され、URIrefを通じてRDFステートメントで<em>参照</em>されます。このステートメントは、単にデータ型の存在を記録し、このデータ型がこのスキーマで使用されていることを明示する役割を果たします。</p>

        <p><code>rdfs:domain</code>プロパティーは、特定のプロパティーが指定されたクラスに適用されるということを示すために使用されます。例えば、<code>example.org</code>が、プロパティー<code>ex:author</code>はクラス<code>ex:Book</code>のインスタンスに適用するということを示したい場合、以下のRDFステートメントを書くでしょう。</p>

        <div class="exampleOuter exampleInner">
<pre>
ex:Book     rdf:type      rdfs:Class .
ex:author   rdf:type      rdf:Property .
ex:author   rdfs:domain   ex:Book .
</pre>
        </div>

        <p>これらのステートメントは、<code>ex:Book</code>がクラスで、<code>ex:author</code>がプロパティーであり、<code>ex:author</code>プロパティーを使用しているRDFステートメントが<code>ex:Book</code>のインスタンスを主語として持っているということを示しています。</p>

        <p>例えば、<code>exterms:weight</code>などの任意のプロパティーは、0や1、または複数の定義域プロパティーを持つことができます。<code>exterms:weight</code>が定義域プロパティーを持っていない場合、<code>exterms:weight</code>プロパティーが一緒に使用される資源に関して何も述べることはありません（どんな資源も<code>exterms:weight</code>を持つことができます）。<code>exterms:weight</code>が、例えば<code>ex:Book</code>をドメインとして指定するものなどの、1つの定義域プロパティーを持っている場合、<code>exterms:weight</code>プロパティーがクラス<code>ex:Book</code>のインスタンスに適用するということを述べています。<code>exterms:weight</code>が、例えば1つが<code>ex:Book</code>を範囲として指定するもので、もう1つが<code>ex:MotorVehicle</code>を範囲として指定するものであるなど、複数の定義域プロパティーを持っている場合、<code>exterms:weight</code>プロパティーを持っているいずれの資源もドメインとして指定された<em>すべて</em>のクラスのインスタンスであるということ、すなわち、<code>exterms:weight</code>プロパティーを持っているいずれの資源も<code>ex:Book</code><em>および</em><code>ex:MotorVehicle</code>の<em>両方</em>であるということを述べています（定義域と値域を指定する際に注意が必要であるということを示す）。</p>

<div class="newstuff">
        <p><code>rdfs:range</code>の場合と同様に、この最後の点<i></i>は明白でないかもしれません。しかし、プロパティー<code>exterms:weight</code>が<code>ex:Book</code>と<code>ex:MotorVehicle</code>という2つの範囲を持つと述べることには、以下の2つの別々のステートメントを出すことが伴います。</p>

        <div class="exampleOuter exampleInner">
<pre>
exterms:weight   rdfs:domain   ex:Book .
exterms:weight   rdfs:domain   ex:MotorVehicle .
</pre>
        </div>

        <p>例えば、以下のような、このプロパティーを使用するあるステートメントに関して、</p>

        <div class="exampleOuter exampleInner">
<pre>
exthings:companyCar   exterms:weight   "2500"^^xsd:integer .
</pre>
        </div>

        <p><em>両方</em>の<code>rdfs:domain</code>ステートメントが正しいものであるためには、<code>exthings:companyCar</code>が<code>ex:Book</code>および<code>ex:MotorVehicle</code>の<em>両方</em>のインスタンスでなければなりません。</p>

</div>

        <p>これらの値域と定義域の記述の使用は、自動車のスキーマを拡張し、2つのプロパティー<code>ex:registeredTo</code>と<code>ex:rearSeatLegRoom</code>や、新しいクラス<code>ex:Person</code>追加し、データ型<code>xsd:integer</code>をデータ型として明示的に記述することによって例示できます。<code>ex:registeredTo</code>プロパティーは、任意の<code>ex:MotorVehicle</code>にも適用し、その値は<code>ex:Person</code>です。この例のために、<code>ex:rearSeatLegRoom</code>はクラス<code>ex:PassengerVehicle</code>のインスタンスのみに適用します。値は、後部座席の足空間をセンチメートルによる数値で示した<code>xsd:integer</code>です。この記述は、<a href="#example26">例26</a>で示しています。</p>

<div class="newstuff">
        <div class="exampleOuter">
          <div class="c1">
            <a id="example26" name="example26">例26: 自動車スキーマのプロパティー記述の一部</a>
          </div>
          <div class="exampleInner">
<pre>
&lt;rdf:Property rdf:ID="registeredTo"&gt;
  &lt;rdfs:domain rdf:resource="#MotorVehicle"/&gt;
  &lt;rdfs:range rdf:resource="#Person"/&gt;
&lt;/rdf:Property&gt;

&lt;rdf:Property rdf:ID="rearSeatLegRoom"&gt;
  &lt;rdfs:domain rdf:resource="#PassengerVehicle"/&gt; 
  &lt;rdfs:range rdf:resource="&amp;xsd;integer"/&gt;
&lt;/rdf:Property&gt;

&lt;rdfs:Class rdf:ID="Person"/&gt;

&lt;rdfs:Datatype rdf:about="&amp;xsd;integer"/&gt;
</pre>
          </div>
        </div>
</div>

        <p><a href="#example24">例24</a>で述べた自動車のスキーマにこのRDF/XMLが追加されていると仮定しているため、<code>&lt;rdf:RDF&gt;</code>要素を<a href="#example26">例26</a>では使用しないことに注意してください。また、これと同じ仮定によって、<code>#MotorVehicle</code>のような相対URIrefを使用してそのスキーマに属する他のクラスを参照できます。</p>


        <p>RDFスキーマでは、クラスだけでなく<em>プロパティー</em>を特殊化する方法を提供しています。2つのプロパティー間のこの特殊化の関係は、定義済みの<code>rdfs:subPropertyOf</code>プロパティーを使用して記述されます。例えば、<code>ex:primaryDriver</code>と<code>ex:driver</code>の両方がプロパティーである場合、<code>example.org</code>は、以下のRDFステートメントを書くことにより、これらのプロパティーを記述し、<code>ex:primaryDriver</code>が<code>ex:driver</code>を特殊化したものであるという事実を記述できます。</p>

        <div class="exampleOuter exampleInner">
<pre>
ex:driver          rdf:type             rdf:Property .
ex:primaryDriver   rdf:type             rdf:Property .
ex:primaryDriver   rdfs:subPropertyOf   ex:driver .
</pre>
        </div>

        <p>この<code>rdfs:subPropertyOf</code>関係が意味するのは、インスタンス<code>exstaff:fred</code>がインスタンス<code>ex:companyVan</code>の<code>ex:primaryDriver</code>である場合、<span class="newstuff">RDFスキーマは<code>exstaff:fred</code>が<code>ex:companyVan</code>の<code>ex:driver</code>でもあると定義する、ということです。</span>これらのプロパティーを記述しているRDF/XMLを（ここでも、これが<a href="#example24">例24</a>で記述した自動車スキーマに追加されていると仮定している）<a href="#example27">例27</a>で示しています。</p>

<div class="newstuff">
        <div class="exampleOuter">
          <div class="c1">
            <a id="example27" name="example27">例27: 自動車スキーマのプロパティーの詳細</a>
          </div>
          <div class="exampleInner">
<pre>
&lt;rdf:Property rdf:ID="driver"&gt;
  &lt;rdfs:domain rdf:resource="#MotorVehicle"/&gt;
&lt;/rdf:Property&gt;

&lt;rdf:Property rdf:ID="primaryDriver"&gt;
  &lt;rdfs:subPropertyOf rdf:resource="#driver"/&gt;
&lt;/rdf:Property&gt;
</pre>
          </div>
        </div>
</div>

        <p>プロパティーは、0や1、または複数のプロパティーのサブプロパティーでありえます。RDFプロパティーに適用されるRDFスキーマである<code>rdfs:range</code>と<code>rdfs:domain</code>プロパティーはすべて、それぞれのサブプロパティーにも適用されます。そのため、上記の例では、RDFスキーマは、<span class="newstuff"><code>ex:driver</code>とのサブプロパティーの関係から、<code>ex:primaryDriver</code>が<code>ex:MotorVehicle</code>の<code>rdfs:domain</code>も持っていると定義します。</span></p>

        <p><a href="#example28">例28</a>では、今までに示したすべての記述を含めた、完全な自動車体系のRDF/XMLを示しています。</p>

<div class="newstuff">
        <div class="exampleOuter">
          <div class="c1">
            <a id="example28" name="example28">例28: 完全な自動車体系</a>
          </div>
          <div class="exampleInner">
<pre>
&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE rdf:RDF [&lt;!ENTITY xsd "http://www.w3.org/2001/XMLSchema#"&gt;]&gt;
&lt;rdf:RDF   
  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
  xml:base="http://example.org/schemas/vehicles"&gt;

&lt;rdfs:Class rdf:ID="MotorVehicle"/&gt;

&lt;rdfs:Class rdf:ID="PassengerVehicle"&gt;
  &lt;rdfs:subClassOf rdf:resource="#MotorVehicle"/&gt;
&lt;/rdfs:Class&gt;

&lt;rdfs:Class rdf:ID="Truck"&gt;
  &lt;rdfs:subClassOf rdf:resource="#MotorVehicle"/&gt;
&lt;/rdfs:Class&gt;

&lt;rdfs:Class rdf:ID="Van"&gt;
  &lt;rdfs:subClassOf rdf:resource="#MotorVehicle"/&gt;
&lt;/rdfs:Class&gt;

&lt;rdfs:Class rdf:ID="MiniVan"&gt;
  &lt;rdfs:subClassOf rdf:resource="#Van"/&gt;
  &lt;rdfs:subClassOf rdf:resource="#PassengerVehicle"/&gt;
&lt;/rdfs:Class&gt;

&lt;rdfs:Class rdf:ID="Person"/&gt;

&lt;rdfs:Datatype rdf:about="&amp;xsd;integer"/&gt;
&lt;rdf:Property rdf:ID="registeredTo"&gt;
  &lt;rdfs:domain rdf:resource="#MotorVehicle"/&gt;
  &lt;rdfs:range rdf:resource="#Person"/&gt;
&lt;/rdf:Property&gt;

&lt;rdf:Property rdf:ID="rearSeatLegRoom"&gt;
  &lt;rdfs:domain rdf:resource="#PassengerVehicle"/&gt; 
  &lt;rdfs:range rdf:resource="&amp;xsd;integer"/&gt;
&lt;/rdf:Property&gt;

&lt;rdf:Property rdf:ID="driver"&gt;
  &lt;rdfs:domain rdf:resource="#MotorVehicle"/&gt;&lt;/rdf:Property&gt;

&lt;rdf:Property rdf:ID="primaryDriver"&gt;
  &lt;rdfs:subPropertyOf rdf:resource="#driver"/&gt;
&lt;/rdf:Property&gt;

&lt;/rdf:RDF&gt;</pre>
          </div>
        </div>
</div>

        <p>RDFスキーマを使用してどのようにクラスとプロパティーを記述するかを示してきたため、今ではこれらのクラスとプロパティーを使用するインスタンスを例示できます。例えば、<a href="#example29">例29</a>では、プロパティーに対するいくつかの仮想の値と一緒に、<a href="#example28">例28</a>で記述した<code>ex:PassengerVehicle</code>クラスのインスタンスを記述しています。</p>

<div class="newstuff">
        <div class="exampleOuter">
          <div class="c1">
            <a id="example29" name="example29">例29: <code>ex:PassengerVehicle</code>のインスタンス</a>
          </div>

          <div class="exampleInner">
<pre>
&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE rdf:RDF [&lt;!ENTITY xsd "http://www.w3.org/2001/XMLSchema#"&gt;]&gt;
&lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
            xmlns:ex="http://example.org/schemas/vehicles#"
            xml:base="http://example.org/things"&gt;

  &lt;ex:PassengerVehicle rdf:ID="johnSmithsCar"&gt;
       &lt;ex:registeredTo rdf:resource="http://www.example.org/staffid/85740"/&gt;
       &lt;ex:rearSeatLegRoom 
           rdf:datatype="&amp;xsd;integer"&gt;127&lt;/ex:rearSeatLegRoom&gt;
       &lt;ex:primaryDriver rdf:resource="http://www.example.org/staffid/85740"/&gt;
  &lt;/ex:PassengerVehicle&gt;
&lt;/rdf:RDF&gt;
</pre>
          </div>
        </div>

        <p>この例では、インスタンスがスキーマとは別個のドキュメントで記述されると仮定しています。スキーマが<code>http://example.org/schemas/vehicles</code>の<code>xml:base</code>を持っているため、名前空間宣言<code>xmlns:ex="http://example.org/schemas/vehicles#"</code>を提供して、インスタンスのデータにおける<code>ex:registeredTo</code>などのQNameをこのスキーマで記述されたクラスとプロパティーのURIrefに適切に展開できるようにします。<code>xml:base</code>宣言もこのインスタンスに対して提供され、これによって、<code>rdf:ID="johnSmithsCar"</code>は、実際のドキュメントの位置に関わらず、適切なURIrefに展開できるようになります。</p>
</div>

        <p><code>ex:PassengerVehicle</code>が<code>ex:MotorVehicle</code>のサブクラスであるため、<code>ex:PassengerVehicle</code>のこのインスタンスを記述する際に<code>ex:registeredTo</code>プロパティーを使用できることに注意してください。このインスタンスでは、プレーン・リテラルではなく（つまり、<code>&lt;ex:rearSeatLegRoom&gt;127&lt;/ex:rearSeatLegRoom&gt;</code>として値を述べるのではなく）、型付きリテラルが<code>ex:rearSetLegRoom</code>プロパティーの値に使用されることにも注意してください。スキーマがこのプロパティーの地域を<code>xsd:integer</code>として記述するため、プロパティーの値は、値域の記述に合わせるためにそのデータ型の型付きリテラルでなければなりません<span class="newstuff">（すなわち、値域の宣言はプレーン・リテラルに自動的にデータ型を「割り当て」ないため、適切なデータ型の型付きリテラルを明示的に提供しなければなりません）。</span><a href="#rdfvalue">4.4項</a>で論じたように、<code>ex:rearSetLegRoom</code>プロパティーの<em>単位</em>（センチメートル）を明示的に指定するために、スキーマあるいは追加のインスタンスのデータにおける追加情報も提供できます。</p>
      </div>

      <div class="section">
        <h3><a id="interpretingschema" name="interpretingschema">5.3 RDFスキーマ宣言の解釈</a></h3>

        <p>以前に指摘したように、RDFスキーマの型システムは、Javaなどのオブジェクト指向プログラミング言語の型システムに多少似ています。しかし、RDFはいくつかの重要な点において、ほとんどのプログラミング言語の型システムとは異なっています。</p>

        <p>1つの重要な違いは、クラスが特定のプロパティーのコレクションを持っていると記述する代わりに、RDFスキーマは、<em>定義域</em>プロパティーと<em>値域</em>プロパティーを使用して、プロパティーが資源の特定のクラスに適用していると記述するということです。例えば、一般的なオブジェクト指向プログラミング言語では、型<code>Person</code>の値を持つ<code>author</code>という属性でクラス<code>Book</code>を定義できます。対応するRDFスキーマでは、クラス<code>ex:Book</code>を記述し、別の記述では<code>ex:Book</code>の定義域と<code>ex:Person</code>の値域を持ったプロパティー<code>ex:author</code>を記述するでしょう。</p>

        <p>これらの方法の違いは、構文的なものだけのように思えるかもしれませんが、実際には大きな違いがあります。プログラミング言語のクラス記述では、属性<code>author</code>はクラス<code>Book</code>の記述の一部であり、クラス<code>Book</code>のインスタンスにのみ適用します。他のクラス（例えば、<code>softwareModule</code>）も、<code>author</code>という属性を持つことができますが、これは<em>異なる</em>属性であると考えられます。言い換えれば、ほとんどのプログラミング言語における属性記述の<em>範囲</em>は、その属性が定義されているクラスまたは型に制限されています。一方で、RDFでは、プロパティー記述は、デフォルトでクラス定義から<em>独立</em>しており、デフォルトで<em>グローバルな</em>範囲を持っています（定義域の仕様を使用して、特定のクラスのみに適用すると宣言できる場合もありますが）。</p>

        <p>その結果、RDFスキーマは、定義域を指定せずに<code>exterms:weight</code>プロパティーを記述できます。このプロパティーは、重さを持っていると考えられる任意のクラスのインスタンスを記述するために使用できます。RDFのプロパティーに基く方法の1つの利点は、最初の記述では予期されていなかった状況にまでプロパティー定義の使用をより簡単に拡張できるということです。同時に、この「利点」は、不適切な状況でプロパティーが誤適用されないようにするために、慎重に使用しなければいけません。</p>

        <p class="newstuff">RDFのプロパティー記述がグローバルな範囲を持っていることの別の結果は、RDFスキーマでは、特定のプロパティーはそれを適用した資源のクラスに応じたローカルに異なる値域を持っていると定義できないということです。例えば、プロパティー<code>ex:hasParent</code>を定義する際には、プロパティーを使用してクラス<code>ex:Tiger</code>の資源を記述すれば、このプロパティーの値域はクラス<code>ex:Tiger</code>の資源でもあると述べ、同時に、プロパティーを使用してクラス<code>ex:Human</code>の資源を記述すれば、このプロパティーの値域はクラス<code>ex:Human</code>の資源でもあると述べることができることが望ましいでしょう。この種の定義は、RDFスキーマでは不可能です。その代わりに、RDFのプロパティーに対して定義した値域は、そのプロパティーの使用のすべてに適用されるため、値域は慎重に定義するべきです。しかし、RDFスキーマでは、このようなローカルに異なる値域を定義できませんが、<a href="#richerschemas">5.5項</a>で論じた、より豊かなスキーマ言語の一部ではこれらを定義できます。</p>

        <p>もうひとつの重要な違いは、RDFスキーマ記述は、必ずしも一般的なプログラミング言語の型宣言のように<em>規範的</em>である必要はないということです。例えば、プログラミング言語が、型<code>Person</code>の値を持っている<code>author</code>属性を持つクラス<code>Book</code>を宣言する場合、通常、これは一連の<em>制約</em>であると解釈されます。プログラミング言語では、<code>author</code>属性なしに<code>Book</code>のインスタンスを作成することは許されておらず、値として<code>Person</code>を持たない<code>author</code>属性を持つ<code>Book</code>のインスタンスは許されていないでしょう。そのうえ、クラス<code>Book</code>に対して定義された<em>唯一</em>の属性が<code>author</code>がである場合、プログラミング言語では、その他の属性を持つ<code>Book</code>のインスタンスは許されないでしょう。</p>

        <p>一方、RDFスキーマではスキーマ情報を資源の追加<em>記述</em>として提供しますが、この記述をアプリケーションでどのように使用すべきかは規定していません。例えば、<code>ex:author</code>プロパティーがクラス<code>ex:Person</code>の<code>rdfs:range</code>を持っているとRDFスキーマが述べているとします。これは単に、<code>ex:author</code>プロパティーを含むRDFステートメントが<code>ex:Person</code>のインスタンスを目的語として持っているというRDFステートメントです。</p>

        <p>このスキーマが提供する情報は、異なる方法で使用できます。あるアプリケーションでは、このステートメントは作成しているRDFデータ用のテンプレートの一部を指定していると解釈し、これを使用して<code>ex:author</code>プロパティーが指示された（<code>ex:Person</code>）クラスの値を持っていることを保証します。すなわち、このアプリケーションでは、プログラミング言語と同じ方法で<em>制約</em>としてスキーマ記述を解釈します。しかし、別のアプリケーションでは、このステートメントは受信しているデータに関する追加情報（最初のデータでは明示的に提供されない情報）を提供していると解釈するかもしれません。例えば、この2番目のアプリケーションでは、指定されていない資源を値として持つ<code>ex:author</code>プロパティーを含む一部のRDFデータを受信し、このスキーマが提供するステートメントを使用して資源がクラス<code>ex:Person</code>のインスタンスに間違いないと結論づけることができます。3番目のアプリケーションでは、クラス<code>ex:Corporation</code>の資源を値として持つ<code>ex:author</code>プロパティーを含む一部のRDFデータを受信し、このスキーマ情報を「ここには、矛盾がありえるが、ないこともありえる」という警告の根拠として使用するかもしれません。明白な矛盾を解決してくれる宣言が他のどこかにあるかもしれません（例えば、「法人は（法的な）人である」という趣旨の宣言）。</p>

        <p>そのうえ、アプリケーションがプロパティーの記述を解釈する方法により、一部のスキーマに特化したプロパティーが<em>ない</em>場合や（例えば、<code>ex:author</code>が<code>ex:Book</code>の定義域を持っていると記述されていても、<code>ex:author</code>プロパティーを持たない<code>ex:Book</code>のインスタンスはありえる）、<em>追加</em>プロパティーを持っている場合（例えば、クラス<code>ex:Book</code>を記述しているスキーマがそのようなプロパティーを記述しなくても、<code>ex:technicalEditor</code>プロパティーを持つ<code>ex:Book</code>のインスタンスはありえる）でもインスタンスの記述が有効であると見なせます。</p>

        <p>言い換えれば、RDFスキーマのステートメントは常に<em>記述</em>です。この記述は<em>規範的</em>でもありえますが（制約を導入する）、これはこのステートメントを解釈するアプリケーションがそのように処理したい場合に限ります。RDFスキーマが行うのは、この追加情報を述べる方法を提供することです。この情報が明示的に指定されたインスタンスのデータと相反するかどうかは、決定や動作を行うアプリケーション次第です。</p>

      </div>

      <div class="section">

        <h3><a id="otherschema" name="otherschema">5.4 その他のスキーマ情報</a></h3>

        <p>RDFスキーマは、その他の多くの組み込みプロパティーを提供し、これらを使用してRDFスキーマやインスタンスに関するドキュメントやその他の情報を提供できます。例えば、<code>rdfs:comment</code>プロパティーを使用して人間が読める資源の記述を提供できます。<code>rdfs:label</code>プロパティーを使用してより人間が読めるバージョンの資源名を提供できます。<code>rdfs:seeAlso</code>プロパティーを使用して、主語である資源に関する追加情報を提供できる資源を示すことができます。<code>rdfs:isDefinedBy</code>プロパティーは、<code>rdfs:seeAlso</code>のサブプロパティーであり、これを使用して主語である資源を「定義する」（ある意味で、RDFで指定されない資源。例えば、資源はRDFスキーマになれない）資源を示すことができます。これらのプロパティーのより詳細な議論に関しては、<a href="www.w3.org/TR/rdf-schema/">RDF語彙記述言語1.0: RDFスキーマ</a> <a href="#ref-rdf-vocabulary">[RDF-VOCABULARY]</a>を参考にしてください。</p>

        <p class="newstuff"><code>rdf:value</code>のような多くの組み込みRDFプロパティーと同様に、これらのRDFスキーマ・プロパティーに対して記述した用法は、これらのプロパティーが<em>意図する</em>用法にすぎません。<a href="#ref-rdf-semantics">[RDF-SEMANTICS]</a>ではこれらのプロパティーに対して特別な意味を定義せず、RDFスキーマではこれらの意図する用法に基づくいかなる制約も定義しません。例えば、<code>rdfs:seeAlso</code>プロパティーの目的語はこの目的語が出現するステートメントの主語に関する追加情報を提供しなければ<em>ならない</em>、という指定のある制約はありません。</p>
      </div>

      <div class="section">
        <h3><a id="richerschemas" name="richerschemas">5.5 より豊かなスキーマ言語</a></h3>

        <p>RDFスキーマには、RDF語彙を記述するための基本的な性能が備わっていますが、付加的な性能も可能であり、有益である場合があります。これらの性能は、RDFスキーマのさらなる開発を通じて提供したり、RDFに基づく他の言語で提供したりすることができます。有益であると認識されているより豊かなスキーマの性能（RDFスキーマでは提供されない）には、以下が含まれます。</p>

        <ul type="disc">
          <li>プロパティーにおける<em>カーディナリティー制約</em>。例えば、人（Person）には<em>きっかり1人</em>の実の父親がいるなど。</li>
          <li>あるプロパティー（<code>ex:hasAncestor</code>のような）が<em>推移的</em>であると指定すること。例えば、A <code>ex:hasAncestor</code> Bであり、B <code>ex:hasAncestor</code> Cである場合、A <code>ex:hasAncestor</code> Cであるなど。</li>

          <li>あるプロパティーが特定のクラスのインスタンスに対する一意の識別子（または、<em>キー</em>）であると指定すること。</li>

          <li>2つの異なるクラス（異なるURIrefを持っている）が実際には同じクラスを表現していると指定すること。</li>

          <li>2つの異なるインスタンス（異なるURIrefを持っている）が実際には同じ個体を表現していると指定すること。</li>

          <li><span class="newstuff">プロパティーが適用される資源のクラスに依存するプロパティーの値域やカーディナリティーにおける制約を指定すること。例えば、サッカー・チームでは<code>ex:hasPlayers</code>プロパティーには11の値がある一方で、バスケットボール・チームでは同じプロパティーに5つの値しかない、と言うことができるなど。</span></li>

          <li>他のクラスの組み合わせ（例えば、和集合と積集合）で新しいクラスを記述したり、2つのクラスが互いに素である（すなわち、資源は両方のクラスのインスタンスではない）と述べる性能。</li>
        </ul>

        <p>その他の性能に加え、上記で述べた追加性能は、<a href="www.w3.org/TR/daml+oil-reference">DAML+OIL</a> <a href="#ref-damloil">[DAML+OIL]</a>や<a href="www.w3.org/TR/owl-ref/">OWL</a> <a href="#ref-owl">[OWL]</a>などのオントロジー言語の対象です。これらの言語は、両方ともRDFとRDFスキーマに基づいています（現在、両方ともが上記のすべての追加性能を備えている）。これらの言語の目的は、機械が処理できる資源の<em>セマンティクス</em>を追加提供すること、すなわち、資源の機械表現をこれらの言語が意図する実世界のものにより類似したものにすることです。このような性能は、RDFを使用した有用なアプリケーションを構築するためには必ずしも必要ではありませんが（多くの既存のRDFアプリケーションの記述に関しては、<a href="#applications">6項</a>を参照）、このような言語の開発は<a href="www.w3.org/2001/sw/Activity">セマンティック・ウェブ</a>の開発の一環として非常に活発な取り組みの対象になっています。</p>
      </div>
    </div>

    <div class="section">

      <h2>
<a id="applications" name="applications"></a>6. RDFアプリケーションの一部: 現在のRDF</h2>
      <p>前項では、RDFとRDFスキーマの一般的な性能について述べました。これらの性能を例示するために前項では例を使用し、これらの例の一部では、RDFアプリケーションの可能性を提案しましたが、<em>実際の</em>アプリケーションについては少しも論じませんでした。この項では、多種多様な事物に関する情報を表現し操作するためにRDFがどのように様々な実世界の要件をサポートするかを示しながら、実際に開発されているRDFアプリケーションの一部について述べます。</p>

      <div class="section">

        <h3 id="dc"><a id="dublincore" name="dublincore">6.1 ダブリン・コア・メタデータ・イニシアティブ</a></h3>

        <p><em>メタデータ</em>は、<em>データに関するデータ</em>です。具体的には、この用語は、資源が物理的であるか電子的であるかに関わらず、情報資源の識別、記述、検索を行うために使用されるデータを意味します。コンピュータで処理される構造化されたメタデータは比較的新しい概念ですが、メタデータの基本概念は、大規模な情報を管理し利用する際に長年使用されてきました。図書館のカード目録は、このようなメタデータの身近な例です。</p>

        <p>ダブリン・コアは、ドキュメントを記述するための（したがって、メタデータを記録するための）1組の「要素」（プロパティー）です。この要素は元々、オハイオ州ダブリンで開かれた1995年3月のメタデータ・ワークショップで開発されました。その後、ダブリン・コアは、後のダブリン・コア・メタデータ・ワークショップに基づいて変更され、現在は<a href="dublincore.org/">ダブリン・コア・メタデータ・イニシアティブ</a>によって維持されています。ダブリン・コアの目的は、図書館のカード目録に似た方法で、ドキュメントのようなネットワーク化されたオブジェクトの記述と自動索引を容易にする記述要素の最小セットを提供することです。ダブリン・コア・メタデータ・セットは、一般的なWWWの検索エンジンに採用されている「ウェブクローラー」などの、インターネット上の資源発見ツールで使用するのに適しているように作られています。さらに、ダブリン・コアは、インターネットに情報を提供する広範囲の著者や一般の情報公開者が容易に理解し使用できることを目指しています。ダブリン・コアの要素は、インターネット資源を記録する際に広く使用されるようになりました（ダブリン・コアの<code>creator</code>要素は、既に前の例で使用しました）。ダブリン・コアの現行の要素は、<a href="dublincore.org/documents/2003/06/02/dces/">ダブリン・コア・メタデータ要素セット、Version 1.1: 参照記述</a> <a href="#ref-dublin-core">[DC]</a>で定義されており、以下のプロパティーに対する定義を含んでいます。</p>

        <ul type="disc">
          <li>
<strong>Title（タイトル）</strong>: 資源に付与された名前。</li>

          <li>
<strong>Creator（作者）</strong>: 資源のコンテンツの作成に主たる責任を持つ主体。</li>

          <li>
<strong>Subject（主題）</strong>: 資源のコンテンツの主題。</li>

          <li>
<strong>Description（記述）</strong>: 資源のコンテンツの説明。</li>

          <li>
<strong>Publisher（公開者）</strong>: 資源を利用可能にすることに責任を持つ主体。</li>

          <li>
<strong>Contributor（寄与者）</strong>: 資源のコンテンツへの寄与に責任を持つ主体。</li>

          <li>
<strong>Date（日付）</strong>: 資源のライフサイクル中の出来事に関連する日付。</li>

          <li>
<strong>Type（型）</strong>: 資源のコンテンツの性質やジャンル。</li>

          <li>
<strong>Format（形式）</strong>: 資源の物理的または電子的な表現形態。</li>

          <li>
<strong>Identifier（識別子）</strong>: あるコンテキスト内の資源への一意の参照。</li>

          <li>
<strong>Source（情報源）</strong>: 現在の資源を生じさせた資源への参照。</li>

          <li>
<strong>Language（言語）</strong>: 資源の知的コンテンツの言語。</li>

          <li>
<strong>Relation（関係）</strong>: 関連する資源への参照。</li>

          <li>
<strong>Coverage（範囲）</strong>: 資源のコンテンツの範囲。</li>

          <li>
<strong>Rights（権利）</strong>: 資源が保有する権利に関する情報。</li>
        </ul>

        <p>ダブリン・コア要素を使用した情報は、任意の適切な言語で（例えば、HTMLの<code>meta</code>要素で）表現できます。しかし、ダブリン・コア情報の理想的な表現方法はRDFです。以下の例では、ダブリン・コア語彙を使用したRDFでの1組の資源の簡単な記述を示します。ここで示している特定のダブリン・コアRDF語彙は、正式なものであることを意図していないことに注意してください。ダブリン・コア参照記述 <a href="#ref-dublin-core">[DC]</a>は、正式な参照です。</p>

        <p>最初の例（<a href="#example30">例30</a>）では、ダブリン・コアのプロパティーを使用してウェブサイトのホームページを記述しています。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example30" name="example30">例30: ダブリンコアのプロパティーを使用して記述したウェブ・ページ</a>
          </div>
          <div class="exampleInner">
<pre>&lt;rdf:RDF
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://purl.org/dc/elements/1.1/"&gt;
    &lt;rdf:Description rdf:about="http://www.dlib.org"&gt;
      &lt;dc:title&gt;D-Lib Program - Research in Digital Libraries&lt;/dc:title&gt;
      &lt;dc:description&gt;The D-Lib program supports the community of people
       with research interests in digital libraries and electronic
       publishing.&lt;/dc:description&gt;
      &lt;dc:publisher&gt;Corporation For National Research Initiatives&lt;/dc:publisher&gt;
      &lt;dc:date&gt;1995-01-07&lt;/dc:date&gt;
      &lt;dc:subject&gt;
        &lt;rdf:Bag&gt;
          &lt;rdf:li&gt;Research; statistical methods&lt;/rdf:li&gt;
          &lt;rdf:li&gt;Education, research, related topics&lt;/rdf:li&gt;
          &lt;rdf:li&gt;Library use Studies&lt;/rdf:li&gt;
        &lt;/rdf:Bag&gt;
      &lt;/dc:subject&gt;
      &lt;dc:type&gt;World Wide Web Home Page&lt;/dc:type&gt;
      &lt;dc:format&gt;text/html&lt;/dc:format&gt;
      &lt;dc:language&gt;en&lt;/dc:language&gt;
    &lt;/rdf:Description&gt;
&lt;/rdf:RDF&gt;
</pre>
          </div>
        </div>

        <p>RDFとダブリン・コアの両方が「Description」という（XML）要素を定義することに注意してください（ダブリン・コアの要素名は小文字で書かれていますが）。最初の文字が等しく大文字であっても、XML名前空間メカニズムによってこれらの2つの要素を区別できます（1つは<code>rdf:Description</code>で、もう1つは<code>dc:description</code>です）。また、関心があって、ウェブ・ブラウザで<a href="purl.org/dc/elements/1.1/">http://purl.org/dc/elements/1.1/</a>（この例では、この名前空間URIを使用してダブリン・コア語彙を識別した）にアクセスすると（執筆時点では）、<a href="#ref-dublin-core">[DC]</a>のRDFスキーマ宣言が検索されるでしょう。</p>

        <p>2番目の例（<a href="#example31">例31</a>）では、発行された雑誌について記述しています。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example31" name="example31">例31: ダブリン・コアを使用した雑誌の記述</a>
          </div>
          <div class="exampleInner">
<pre>
&lt;rdf:RDF
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://purl.org/dc/elements/1.1/"
    xmlns:dcterms="http://purl.org/dc/terms/"&gt;
    &lt;rdf:Description rdf:about="http://www.dlib.org/dlib/may98/05contents.html"&gt;
      &lt;dc:title&gt;DLIB Magazine - The Magazine for Digital Library Research
        - May 1998&lt;/dc:title&gt;
      &lt;dc:description&gt;D-LIB magazine is a monthly compilation of
       contributed stories, commentary, and briefings.&lt;/dc:description&gt;
      &lt;dc:contributor&gt;Amy Friedlander&lt;/dc:contributor&gt;
      &lt;dc:publisher&gt;Corporation for National Research Initiatives&lt;/dc:publisher&gt;
      &lt;dc:date&gt;1998-01-05&lt;/dc:date&gt;
      &lt;dc:type&gt;electronic journal&lt;/dc:type&gt;
      &lt;dc:subject&gt;
        &lt;rdf:Bag&gt;
          &lt;rdf:li&gt;library use studies&lt;/rdf:li&gt;
          &lt;rdf:li&gt;magazines and newspapers&lt;/rdf:li&gt;
        &lt;/rdf:Bag&gt;
      &lt;/dc:subject&gt;
      &lt;dc:format&gt;text/html&lt;/dc:format&gt;
      &lt;dc:identifier rdf:resource="urn:issn:1082-9873"/&gt;
      &lt;dcterms:isPartOf rdf:resource="http://www.dlib.org"/&gt;
    &lt;/rdf:Description&gt;
 &lt;/rdf:RDF&gt;
</pre>
          </div>
        </div>

        <p><a href="#example31">例31</a>では（最後から3行目で）、ダブリン・コア<em>限定子</em><code>isPartOf</code>（別の<span class="newstuff">語彙</span>からの）を使用して、この雑誌が以前に述べたウェブ・サイトの「一部」であることを示しています。</p>
        <p>3番目の例（<a href="#example32">例32</a>）では、<a href="#example31">例31</a>で記述した雑誌の特定記事を記述しています。</p>


        <div class="exampleOuter">
          <div class="c1">
            <a id="example32" name="example32">例32: 雑誌の記事の記述</a>
          </div>
          <div class="exampleInner">
<pre>
&lt;rdf:RDF
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:dc="http://purl.org/dc/elements/1.1/"
    xmlns:dcterms="http://purl.org/dc/terms/"&gt;
    &lt;rdf:Description rdf:about="http://www.dlib.org/dlib/may98/miller/05miller.html"&gt;
      &lt;dc:title&gt;An Introduction to the Resource Description Framework&lt;/dc:title&gt;
      &lt;dc:creator&gt;Eric J. Miller&lt;/dc:creator&gt;
      &lt;dc:description&gt;The Resource Description Framework (RDF) is an
       infrastructure that enables the encoding, exchange and reuse of
       structured metadata. rdf is an application of xml that imposes needed
       structural constraints to provide unambiguous methods of expressing
       semantics. rdf additionally provides a means for publishing both
       human-readable and machine-processable vocabularies designed to
       encourage the reuse and extension of metadata semantics among
       disparate information communities. the structural constraints rdf
       imposes to support the consistent encoding and exchange of
       standardized metadata provides for the interchangeability of separate
       packages of metadata defined by different resource description
       communities. &lt;/dc:description&gt;
      &lt;dc:publisher&gt;Corporation for National Research Initiatives&lt;/dc:publisher&gt;
      &lt;dc:subject&gt;
        &lt;rdf:Bag&gt;
          &lt;rdf:li&gt;machine-readable catalog record formats&lt;/rdf:li&gt;
          &lt;rdf:li&gt;applications of computer file organization and
           access methods&lt;/rdf:li&gt;
        &lt;/rdf:Bag&gt;
      &lt;/dc:subject&gt;
      &lt;dc:rights&gt;Copyright &copy; 1998 Eric Miller&lt;/dc:rights&gt;
      &lt;dc:type&gt;Electronic Document&lt;/dc:type&gt;
      &lt;dc:format&gt;text/html&lt;/dc:format&gt;
      &lt;dc:language&gt;en&lt;/dc:language&gt;
      &lt;dcterms:isPartOf rdf:resource="http://www.dlib.org/dlib/may98/05contents.html"/&gt;
    &lt;/rdf:Description&gt;
&lt;/rdf:RDF&gt;
</pre>
          </div>
        </div>

        <p><a href="#example32">例32</a>でも限定子<code>isPartOf</code>を使用しており、今回は、この記事が以前に記述した雑誌の「一部」であることを示しています。</p>

<div class="newstuff">
        <p>コンピュータ言語とファイル形式は、<a name="LCC-029" id="LCC-029">メタデータを、このメタデータが記述するデータをともに組み込む</a>ための明確な規定を常に設けているわけではありません。多くの場合、メタデータは、別の資源として指定され、データと明示的にリンクされなければなりません（これは、この入門書を記述するRDFメタデータのために行われました。この入門書の末尾にこのメタデータへの明示的なリンクがあります）。しかし、メタデータをデータに直接組み込むための明確な規定を作成しているアプリケーションや言語も徐々に増えています。例えば、W3CのSVG言語（Scalable Vector Graphics）<a href="#ref-svg">[SVG]</a>（別のXMLベースの言語）は、他のSVGデータと一緒にメタデータを記録するための明示的な<code>metadata</code>要素を提供します。この要素の中では、あらゆるXMLベースのメタデータ言語を使用できます。<a href="#ref-svg">[SVG]</a>には、<a href="#example33">例33</a>で示した、SVGドキュメント自体にSVGドキュメントを記述したメタデータを組み込む方法の例が含まれています。この例では、メタデータを記録するためにダブリン・コア語彙とRDF/XMLを使用しています。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example33" name="example33">例33: SVGドキュメントにメタデータを含む</a>
          </div>

          <div class="exampleInner">
<pre>
&lt;?xml version="1.0"?&gt;
&lt;svg width="4in" height="3in" version="1.1"
    xmlns = 'http://www.w3.org/2000/svg'&gt;
    &lt;desc xmlns:myfoo="http://example.org/myfoo"&gt;
      &lt;myfoo:title&gt;This is a financial report&lt;/myfoo:title&gt;
      &lt;myfoo:descr&gt;The global description uses markup from the
        &lt;myfoo:emph&gt;myfoo&lt;/myfoo:emph&gt; namespace.&lt;/myfoo:descr&gt;
      &lt;myfoo:scene&gt;&lt;myfoo:what&gt;widget $growth&lt;/myfoo:what&gt;
      &lt;myfoo:contains&gt;$three $graph-bar&lt;/myfoo:contains&gt;
        &lt;myfoo:when&gt;1998 $through 2000&lt;/myfoo:when&gt; &lt;/myfoo:scene&gt;
   &lt;/desc&gt;
    &lt;metadata&gt;
      &lt;rdf:RDF
           xmlns:rdf = "http://www.w3.org/1999/02/22-rdf-syntax-ns#"
           xmlns:rdfs = "http://www.w3.org/2000/01/rdf-schema#"
           xmlns:dc = "http://purl.org/dc/elements/1.1/" &gt;
        &lt;rdf:Description rdf:about="http://example.org/myfoo"
             dc:title="MyFoo Financial Report"
             dc:description="$three $bar $thousands $dollars $from 1998 $through 2000"
             dc:publisher="Example Organization"
             dc:date="2000-04-11"
             dc:format="image/svg+xml"
             dc:language="en" &gt;          &lt;dc:creator&gt;
            &lt;rdf:Bag&gt;
              &lt;rdf:li&gt;Irving Bird&lt;/rdf:li&gt;
              &lt;rdf:li&gt;Mary Lambert&lt;/rdf:li&gt;
            &lt;/rdf:Bag&gt;
          &lt;/dc:creator&gt;
        &lt;/rdf:Description&gt;
      &lt;/rdf:RDF&gt;
    &lt;/metadata&gt;
&lt;/svg&gt;
</pre>
          </div>
        </div>
        
        <p>Adobe社の<a href="www.adobe.com/products/xmp/main.html">XMP（Extensible Metadata Platform）</a>は、ファイルに関するメタデータをファイル自体に組み込めるようにする技術に関する別の例です。XMPでは、メタデータ表現の基礎としてRDF/XMLを使用します。Adobe製品の多くが既にXMPをサポートしています。</p>
</div>

      </div>

      <div class="section">

        <h3><a id="prism" name="prism">6.2 PRISM</a></h3>

        <p><a href="www.prismstandard.org/">PRISM: Publishing Requirements for Industry Standard Metadata</a> <a href="#ref-prism">[PRISM]</a>は、出版業界で開発されたメタデータの仕様です。雑誌の出版社とその販売業者は、PRISMワーキンググループを結成して業界のメタデータに対するニーズを識別し、そのニーズを満たすように仕様を定義しました。出版社は、コンテンツの作成時に行った投資よりも大きな利益を得るために、様々な方法で既存のコンテンツを使用したいと考えています。雑誌記事をウェブに掲載するためにHTMLに変換するのは、その1つの例です。別の例としては、<a href="www.lexisnexis.com/">LexisNexis</a>のようなアグリゲーター（訳注：aggregator。複数の出版社の雑誌記事を総合的に収集・提供する機関）にその雑誌記事をライセンス提供するものがあります。これらはすべてコンテンツの「初めての使用」であり、通常は、雑誌の発売時に稼動します。出版社は、そのコンテンツが「いつまでも新鮮」であって欲しいとも願います。このコンテンツは、回顧記事などの形で新刊号で使用できます。雑誌の写真やレシピなどを編集した本などの形で、その出版社内の別の部署でも使用できます。別の使用方法としては、製品レビューの再版や別の出版社による復刻版などの、外部に対して使用許可を与えるというのもあります。この全体的な目標には、<em>発見</em>（discovery）や<em>権利追求</em>（rights tracking）、<em>エンド・ツー・エンド・メタデータ</em>（end-to-end metadata）に重点を置いたメターデータのアプローチが必要です。</p>

        <p><em>発見:</em> 発見とは、検索やブラウジング、コンテンツ・ルーティング、その他の技術を包括する、コンテンツを見つけることに対する一般的な用語です。発見に関する議論は、消費者による一般のウェブサイト検索にしばしば重点が置かれます。しかし、コンテンツの発見は、それよりずっと広範囲です。対象者は、消費者で構成されることもあれば、研究者やデザイナー、写真編集者、ライセンシング・エージェントなどの内部利用者で構成されることもあります。PRISMでは、発見を支援するために、プロパティーを提供して資源の話題や形式、ジャンル、起源、コンテキストを記述します。PRISMでは、複数の主題記述分類法を使用して資源を分類する手段も提供しています。</p>

        <p><em>権利追求:</em> 雑誌には、他から使用許可を得た素材が頻繁に含まれています。ストック写真の代理店が提供する写真は、最も一般的な種類の使用許可済みの素材ですが、記事や補足記事、そして他のすべての種類のコンテンツの使用許可を得ることもできます。コンテンツが、1回のみの使用が許可されているのか、ロイヤリティの支払いを要するのか、出版社が完全に所有しているのかを単に知るだけでも大変です。PRISMでは、そのような権利の基本的な追跡のための要素を提供しています。PRISMの仕様で定義されている別の語彙は、コンテンツが使用できたりできなかったりする場所や時間、業界の記述をサポートしています。</p>

        <p><em>エンド・ツー・エンド・メタデータ:</em> 出版されたコンテンツのほとんどは、そのコンテンツ用に作成されたメタデータを既に持っています。残念ながら、コンテンツがシステム間で移動すると、しばしばそのメタデータは廃棄され、後の生産過程でかなりの費用をかけて再作成されます。PRISMは、コンテンツ作成過程の多くの段階で使用できる仕様を提供してこの問題を削減することを目指しています。PRISMの仕様の大きな特徴は、他の既存の仕様を使用するということです。PRISMのグループは、全く新しいものを作成するのではなく、できる限り既存の仕様を使用し、必要な場合にのみ新しい事柄を定義することに決めました。このような理由で、PRISMの仕様は、様々なISOの形式や語彙に加え、XML、RDF、ダブリン・コアを使用しています。PRISMの記述は、プレーン・リテラル値を持つ一部のダブリン・コアのプロパティーと同じくらい簡単かもしれません。<a href="#example34">例34</a>では、タイトル、写真家、形式などに関する基本情報を提供して写真を記述しています。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example34" name="example34">例34: 写真のPRISM記述</a>
          </div>

          <div class="exampleInner">
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
         xmlns:dc="http://purl.org/dc/elements/1.1/"
         xml:lang="en-US"&gt;

 &lt;rdf:Description rdf:about="http://travel.example.com/2000/08/Corfu.jpg"&gt;
  &lt;dc:title&gt;Walking on the Beach in Corfu&lt;/dc:title&gt;
  &lt;dc:description&gt;Photograph taken at 6:00 am on Corfu with two models
  &lt;/dc:description&gt;
  &lt;dc:creator&gt;John Peterson&lt;/dc:creator&gt;
  &lt;dc:contributor&gt;Sally Smith, lighting&lt;/dc:contributor&gt;
  &lt;dc:format&gt;image/jpeg&lt;/dc:format&gt; &lt;/rdf:Description&gt;
&lt;/rdf:RDF&gt;</pre>
          </div>
        </div>
        <p>PRISMは、ダブリン・コアを強化して、より詳細な記述も可能にします。この強化は、一般的に接頭辞<code>prism:</code>、<code>pcv:</code>、<code>prl:</code>を使用して引用される<span class="newstuff">3つの新しい語彙として</span>定義されています。</p>

        <p><code>prism:</code>: この接頭辞は、主要なPRISM<span class="newstuff">語彙を参照し、その用語はURI接頭辞<code>http://prismstandard.org/namespaces/basic/1.0/</code>を使用します</span>。この語彙のプロパティーの大部分は、ダブリン・コアに属するプロパティーの、より特定的なバージョンです。例えば、<code>dc:date</code>のより特定的なバージョンは、<code>prism:publicationTime</code>、<code>prism:releaseTime</code>、<code>prism:expirationTime</code>などのようなプロパティーで提供されています。</p>

        <p><code>pcv:</code> この接頭辞は、PRISM統制語彙（PRISM Controlled Vocabulary、pcv）という<span class="newstuff">語彙を参照し、その用語はURI接頭辞<code>http://prismstandard.org/namespaces/pcv/1.0/</code>を使用します</span>。現在、記事の主題を記述するためには、記述的なキーワードを提供するという方法が一般的にとられています。残念ながら、人によって使用するキーワードが異なるため、簡単なキーワードでは検索性能に大きな違いは生じません<a href="#ref-bates96">[BATES96]</a>。最も良い方法は、「統制語彙」の件名で記事をコード化することです。この語彙は、その語彙の用語に対してできる限り多くの同義語を提供する必要があります。このようにして、統制用語は、検索者と索引作成者が提供したキーワードが出会う場所を提供します。pcv語彙は、語彙の用語、用語間の関係、用語の別名を指定するためのプロパティーを提供します。</p>

        <p><code>prl:</code> この接頭辞は、PRISM権利言語<span class="newstuff">語彙を参照し、その用語はURI接頭辞<code>http://prismstandard.org/namespaces/prl/1.0/</code>を使用します</span>。デジタル権利管理は、かなりの激変を経験している分野です。権利管理言語に対する多くの提案がありますが、業界全体で明らかに好まれているものはありません。推奨すべきものも明確にはないため、暫定措置としてPRISM権利言語（PRL）が定義されています。これは、時間、地理、業界の条件によって、項目を「使用」できるかできないかを述べられるようにするプロパティーを提供します。これは、権利を追跡する時に出版社が費用を削減し始めるのに役立つ80/20のトレードオフであると信じられています。一般的な権利言語であることや、出版社が自動的に消費者のコンテンツの使用に制限を課すようにすることを意図したものではありません。</p>

        <p>様々な複雑さの記述を処理する性能のために、PRISMはRDFを使用します。現在、メタデータの多くは、以下のようなシンプルな文字列（プレーン・リテラル）の値を使用しています。</p>
        <div class="exampleOuter exampleInner">
<pre>
&lt;dc:coverage&gt;Greece&lt;/dc:coverage&gt;
</pre>
        </div>

        <p>PRISMの開発者は、簡単なリテラル値からより構造化された値へと移行し、PRISMの仕様の使用がやがて洗練されることを期待しています。実際、現在直面している状況はその範囲の値です。洗練された統制語彙を既に使用している出版社もあれば、手動で提供されるキーワードを辛うじて使用している出版社もあります。これを例示するために、<code>dc:coverage</code>プロパティーに提供できる異なる種類の値の例をいくつか以下に示します。</p>

        <div class="exampleOuter exampleInner">
<pre>
&lt;dc:coverage&gt;Greece&lt;/dc:coverage&gt;

&lt;dc:coverage rdf:resource="http://prismstandard.org/vocabs/ISO-3166/GR"/&gt;
</pre>
        </div>

        <p>（すなわち、プレーン・リテラルかURIrefのどちらかを使用して国を識別し、）</p>

        <div class="exampleOuter exampleInner">
<pre>
&lt;dc:coverage&gt;
  &lt;pcv:Descriptor rdf:about="http://prismstandard.org/vocabs/ISO-3166/GR"&gt;
    &lt;pcv:label xml:lang="en"&gt;Greece&lt;/pcv:label&gt;
    &lt;pcv:label xml:lang="fr"&gt;Gr&egrave;ce&lt;/pcv:label&gt;
  &lt;/pcv:Descriptor&gt;
&lt;/dc:coverage&gt;</pre>
        </div>

        <p>（構造化された値を使用してURIrefと様々な言語による名前の両方を提供します。）</p>

        <p>意味が似ているプロパティーや、他のプロパティーのサブセットであるプロパティーがあることにも注意してください。例えば、資源の地理的な主題は以下のように示されます。</p>

        <div class="exampleOuter exampleInner">
<pre>
&lt;prism:subject&gt;Greece&lt;/prism:subject&gt;
&lt;dc:coverage&gt;Greece&lt;/dc:coverage&gt;</pre>
        </div>

        <p>または、</p>

        <div class="exampleOuter exampleInner">
<pre>
&lt;prism:location&gt;Greece&lt;/prism:location&gt;
</pre>
        </div>

        <p>これらのプロパティーはいずれも、シンプルなリテラルの値か、より複雑な構造化された値を使用できます。このような可能性は、DTDや新しいXMLスキーマでさえ適切に記述できません。扱うべき構文の変化が広範囲なものであっても、RDFのグラフ・モデルは、1組のトリプルというシンプルな構造を持っています。トリプルの定義域でメタデータを扱うと、古いソフトウェアは非常に簡単にコンテンツを新たな拡張に対応させることができます。</p>

        <p>最後に、2つの例を示してこの項を終わります。<a href="#example35">例35</a>は、この画像（<code>.../Corfu.jpg</code>）は、たばこ業界（SIC：標準産業分類のコード21）で使用できない（<code>#none</code>）と述べています。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example35" name="example35">例35: 画像のPRISM記述</a>
          </div>

          <div class="exampleInner">
<pre>
&lt;rdf:RDF xmlns:prism="http://prismstandard.org/namespaces/basic/1.0/"
         xmlns:prl="http://prismstandard.org/namespaces/prl/1.0/"
         xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
         xmlns:dc="http://purl.org/dc/elements/1.1/"&gt;

 &lt;rdf:Description rdf:about="http://travel.example.com/2000/08/Corfu.jpg"&gt;
  &lt;dc:rights rdf:parseType="Resource"
         xml:base="http://prismstandard.org/vocabularies/1.0/usage.xml"&gt;
     &lt;prl:usage rdf:resource="#none"/&gt;
     &lt;prl:industry rdf:resource="http://prismstandard.org/vocabs/SIC/21"/&gt;
  &lt;/dc:rights&gt;
 &lt;/rdf:Description&gt;
&lt;/rdf:RDF&gt;
</pre>
          </div>
        </div>

        <p><a href="#example36">例36</a>は、コルフ（Corfu）という画像の写真家は、John Petersonとしてよりよく知られている従業員3845であることを示しています。また、写真の地理的範囲がギリシアであることも示しています。しかし、統制語彙のコードだけでなく、語彙の中のその用語に対する情報のキャッシュされたバージョンを提供することでこのように示しています。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example36" name="example36">例36: 例35の画像に関する追加情報</a>
          </div>

          <div class="exampleInner">
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
         xmlns:pcv="http://prismstandard.org/namespaces/pcv/1.0/"
         xmlns:dc="http://purl.org/dc/elements/1.1/"
         xml:base="http://travel.example.com/"&gt;
  &lt;rdf:Description rdf:about="/2000/08/Corfu.jpg"&gt;
    &lt;dc:identifier rdf:resource="/content/2357845" /&gt;
    &lt;dc:creator&gt;
      &lt;pcv:Descriptor rdf:about="/emp3845"&gt;
        &lt;pcv:label&gt;John Peterson&lt;/pcv:label&gt;
      &lt;/pcv:Descriptor&gt;
    &lt;/dc:creator&gt;
    &lt;dc:coverage&gt;
      &lt;pcv:Descriptor
          rdf:about="http://prismstandard.org/vocabs/ISO-3166/GR"&gt;
        &lt;pcv:label xml:lang="en"&gt;Greece&lt;/pcv:label&gt;
        &lt;pcv:label xml:lang="fr"&gt;Grece&lt;/pcv:label&gt;
      &lt;/pcv:Descriptor&gt;
    &lt;/dc:coverage&gt;
  &lt;/rdf:Description&gt;
&lt;/rdf:RDF&gt;
</pre>
          </div>
        </div>
      </div>

      <div class="section">

        <h3><a id="xpackage" name="xpackage">6.3 XPackage</a></h3>

<div class="newstuff">
        <p>多くの状況では、1つの単位として使用される、または、使用されうる資源の構造化されたグループ分けやその関連性に関する情報を保持する必要性が伴います。<a href="www.xpackage.org/specification/">XMLパッケージ（XPackage）仕様</a><a href="#ref-xpackage">[XPACKAGE]</a>は、このようなグループ分けを定義するための<em>パッケージ</em>というフレームワークを提供します。XPackageは、そのようなパッケージに含まれる資源、その資源のプロパティー、その包含方法、互いの関係を記述するためのフレームワークを指定します。XPackageアプリケーションには、ドキュメントで使用するスタイルシートの指定や、複数のドキュメントで共有する画像の宣言、ドキュメントの著者やその他のメタデータの提示、XML資源で名前空間を使用する方法の記述、資源を1つのアーカイブ・ファイルにまとめるための明細リストの提供が含まれています。</p>

        <p>XPackageフレームワークは、XML、RDF、<a href="www.w3.org/TR/xlink/">XMLリンク付け言語</a> <a href="#ref-xlink">[XLINK]</a>に基づいており、複数のRDF語彙を提供します。その1つは一般的なパッケージ記述のためのもので、他のいくつかの語彙はパッケージ・プロセッサに有用な補足的な資源情報を提供するためのものです。</p>

        <p>XPackageの1つの応用は、XHTMLドキュメントとそれをサポートしている資源の記述です。ウェブサイトで検索されたXHTMLドキュメントは、同じく検索される必要があるスタイルシートや画像ファイルなどの他の資源に依存しています。しかし、これらのサポートしている資源の独自性は、全文書を処理しなければ明白でないこともありえます。著者の名前などのドキュメントに関する他の情報も、文書を処理しなければ利用できないかもしれません。XPackageでは、そのような記述情報を、RDFを含んでいるパッケージ記述ドキュメントに標準の方法で格納できます。そのようなXHTMLドキュメントを記述しているパッケージ記述ドキュメントの外的要素は、<a href="#example37">例37</a>（簡単にするために名前空間宣言を省いている）のようになります。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example37" name="example37">例37: XPackageパッケージ記述ドキュメントの外部要素</a>
          </div>

          <div class="exampleInner">
<pre>
&lt;?xml version="1.0"?&gt;
&lt;xpackage:description&gt;
  &lt;rdf:RDF&gt;

    (description of individual resources go here)

  &lt;/rdf:RDF&gt;
&lt;/xpackage:description&gt;
</pre>
          </div>
        </div>
        <p>資源（XHTMLドキュメント、スタイルシート、画像など）は、標準のRDF/XML構文を使用して、このパッケージ記述ドキュメントで記述されています。それぞれの資源記述要素には、様々な語彙のRDFプロパティーを含めるとができます（XPackageでは、RDFで「語彙」と呼ぶものに対し「オントロジー」という用語を使用します）。主要なパッケージング語彙以外に、XPackage自体は、以下を含むいくつかの補足語彙を指定しています。</p>

        <ul>

        <li>ファイルを記述するための（<code>file:size</code>のようなプロパティーで）語彙（接頭辞<code>file:</code>を使用して）</li>

        <li>MIME情報を提供するための（<code>mime:contentType</code>のようなプロパティーで）語彙（接頭辞<code>mime:</code>を使用して）</li>

        <li>文字使用情報を提供するための（<code>unicode:script</code>のようなプロパティーで）語彙（接頭辞<code>unicode:</code>を使用して）</li>

        <li>XMLベースの資源を記述するための（<code>x:namespace</code>や<code>x:style</code>のようなプロパティーで）語彙（接頭辞<code>x:</code>を使用して）</li>
  
        </ul>

        <p><a href="#example38">例38</a>では、ドキュメントのMIMEコンテンツ・タイプ（「application/xhtml+xml」）は、XPackage MIME語彙の標準XPackageプロパティーである<code>mime:contentType</code>を使用して定義されています。別のプロパティーであるドキュメントの著者（この場合、「Garret Wilson」)は、XPackageの外部で定義されている、ダブリン・コア語彙のプロパティーを使用して記述され、<code>dc:creator</code>プロパティーになります。</p>
        <div class="exampleOuter">
          <div class="c1">
            <a id="example38" name="example38">例38: XHTMLドキュメントの記述</a>
          </div>

          <div class="exampleInner">
<pre>
&lt;?xml version="1.0"?&gt; 
&lt;xpackage:description 
           xmlns:xpackage="http://xpackage.org/namespaces/2003/xpackage#"
           xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
           xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
           xmlns:dc="http://purl.org/dc/elements/1.1/"
           xmlns:mime="http://xpackage.org/namespaces/2003/mime#" 
           xmlns:x="http://xpackage.org/namespaces/2003/xml#"
           xmlns:xlink="http://www.w3.org/1999/xlink"&gt;  
    &lt;rdf:RDF&gt;

    &lt;!--doc.html--&gt;
    &lt;rdf:Description rdf:about="urn:example:xhtmldocument-doc"&gt;
      &lt;rdfs:comment&gt;The XHTML document.&lt;/rdfs:comment&gt;
      &lt;xpackage:location xlink:href="doc.html"/&gt;
      &lt;mime:contentType&gt;application/xhtml+xml&lt;/mime:contentType&gt;
      &lt;x:namespace rdf:resource="http://www.w3.org/1999/xhtml"/&gt;
      &lt;x:style rdf:resource="urn:example:xhtmldocument-stylesheet"/&gt;
      &lt;dc:creator&gt;Garret Wilson&lt;/dc:creator&gt;
      &lt;xpackage:manifest rdf:parseType="Collection"&gt;
         &lt;rdf:Description rdf:about="urn:example:xhtmldocument-stylesheet"/&gt;
         &lt;rdf:Description rdf:about="urn:example:xhtmldocument-image"/&gt;
      &lt;/xpackage:manifest&gt;
    &lt;/rdf:Description&gt;

    &lt;/rdf:RDF&gt; 
&lt;/xpackage:description&gt;
</pre>
          </div>
        </div>

        <p><code>xpackage:manifest</code>プロパティーは、処理にスタイルシートと画像資源の両方が必要であることを示しており、これらの資源は、パッケージ記述ドキュメント内で別々に記述されています。<a href="#example39">例39</a>のスタイルシート資源の記述例では、一般的なXPackage語彙<code>xpackage:location</code>プロパティー（XLinkと互換性がある）を使用してパッケージ内の位置（「stylesheet.css」）を記載し、XPackageのMIME語彙<code>mime:contentType</code>プロパティーを使用して、それがCSSスタイルシート（「text/css」）であることを示します。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example39" name="example39">例39: スタイルシート資源記述</a>
          </div>

          <div class="exampleInner">
<pre>
&lt;?xml version="1.0"?&gt; 
&lt;xpackage:description 
           xmlns:xpackage="http://xpackage.org/namespaces/2003/xpackage#"
           xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
           xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
           xmlns:dc="http://purl.org/dc/elements/1.1/"
           xmlns:mime="http://xpackage.org/namespaces/2003/mime#" 
           xmlns:x="http://xpackage.org/namespaces/2003/xml#"
           xmlns:xlink="http://www.w3.org/1999/xlink"&gt;  
    &lt;rdf:RDF&gt; 

    &lt;!--stylesheet.css--&gt;
    &lt;rdf:Description rdf:about="urn:example:xhtmldocument-css"&gt;
      &lt;rdfs:comment&gt;The document style sheet.&lt;/rdfs:comment&gt;
      &lt;xpackage:location xlink:href="stylesheet.css"/&gt;
      &lt;mime:contentType&gt;text/css&lt;/mime:contentType&gt;
    &lt;/rdf:Description&gt;

    &lt;/rdf:RDF&gt;
 &lt;/xpackage:description&gt;
</pre>
          </div>
        </div>

        <p>この例の完全版は、<a href="#ref-xpackage">[XPACKAGE]</a>にあります。</p>
</div>
      </div>

      <div class="section">

        <h3><a id="rss" name="rss">6.4 RSS 1.0: RDFサイト・サマリー</a></h3>

        <p>スケジュール、やることリスト、ニュースの見出し、検索結果、「新着情報」などの、ウェブに上の様々な情報に日常的にアクセスすることが必要になることがあります。ウェブに上の情報の情報源や多様性が増すにつれ、この情報を管理し、全体として一貫したものに統合することはますます難しくなります。<a href="purl.org/rss/1.0">RSS1.0</a>（「RDFサイト・サマリ」）は、タイムリーで大規模な発信と再利用を可能にする情報を記述する、軽量ながらも強力な方法を提供するRDF語彙です。RSS1.0は、恐らくウェブ上で最も広く使用されているRDFアプリケーションでもありす。</p>

        <p>簡単な例をあげると、<a href="www.w3.org/">W3Cのホームページ</a>は、一般の人々との主要な接点であり、ある部分では、コンソーシアムの成果物に関する情報を広める役目も果たしています。ある日のW3Cのホームページの例を<a href="#figure19">図19</a>で示しています。中央のニュース記事のコラムは、頻繁に変わります。この情報のタイムリーな配布をサポートするために、W3Cチームでは、中央のコラムのコンテンツを他の人が再利用できるようにしてくれるRDFサイト・サマリー（<a href="purl.org/rss/1.0/">RSS1.0</a>）のニュース配信を実装しました。ニュース配信サイトではその日の最新ニュースの要約（サマリー）に見出しを結び付け、他のサイトでは読者へのサービスとしてその見出しをリンクで表示することで、個人がデスクトップ・アプリケーションでこの配信を購読できるようになります。このデスクトップ<em>RSSリーダー</em>を使用すると、ブラウザで各サイトを訪問しなくても、何百ものサイトの動向を把握できます。</p>

        <div class="figure">
          <a href="www.asahi-net.or.jp/~ax2s-kmtn/internet/rdf/w3c-rss.crop.gif"><img src="www.asahi-net.or.jp/~ax2s-kmtn/internet/rdf/fig18dec16.gif" alt="W3Cのホームページ"></a><br>
          <br>
           <a id="figure19" name="figure19">図19: W3Cのホームページ</a>
        </div>

        <p>ウェブの多くのサイトがRSS 1.0配信を提供しています。<a href="#example40">例40</a>は、（異なる日付の）<a href="www.w3.org/2000/08/w3c-synd/home.rss">W3C配信</a>の例です。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example40" name="example40">例40: W3CのRSS 1.0配信の例</a>
          </div>

          <div class="exampleInner">
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;

&lt;rdf:RDF xmlns="http://purl.org/rss/1.0/"
    xmlns:dc="http://purl.org/dc/elements/1.1/" 
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;

  &lt;channel rdf:about="http://www.w3.org/2000/08/w3c-synd/home.rss"&gt;
    &lt;title&gt;The World Wide Web Consortium&lt;/title&gt;
    &lt;description&gt;Leading the Web to its Full Potential...&lt;/description&gt;
    &lt;link&gt;http://www.w3.org/&lt;/link&gt;

    &lt;dc:date&gt;2002-10-28T08:07:21Z&lt;/dc:date&gt;
    &lt;items&gt;        &lt;rdf:Seq&gt;
            &lt;rdf:li rdf:resource="http://www.w3.org/News/2002#item164"/&gt;
            &lt;rdf:li rdf:resource="http://www.w3.org/News/2002#item168"/&gt;
            &lt;rdf:li rdf:resource="http://www.w3.org/News/2002#item167"/&gt;
        &lt;/rdf:Seq&gt;
    &lt;/items&gt;

  &lt;/channel&gt;

  &lt;item rdf:about="http://www.w3.org/News/2002#item164"&gt;
    &lt;title&gt;User Agent Accessibility Guidelines Become a W3C 
       Proposed Recommendation&lt;/title&gt;
    &lt;description&gt;17 October 2002: W3C is pleased to announce the 
       advancement of User Agent Accessibility Guidelines 1.0 to 
       Proposed Recommendation. Comments are welcome through 14 November. 
       Written for developers of user agents, the guidelines lower 
       barriers to Web accessibility for people with disabilities 
       (visual, hearing, physical, cognitive, and neurological). 
       The companion Techniques Working Draft is updated. Read about 
       the Web Accessibility Initiative. (News archive)&lt;/description&gt;
    &lt;link&gt;http://www.w3.org/News/2002#item164&lt;/link&gt;
    &lt;dc:date&gt;2002-10-17&lt;/dc:date&gt;
  &lt;/item&gt;

  &lt;item rdf:about="http://www.w3.org/News/2002#item168"&gt;
    &lt;title&gt;Working Draft of Authoring Challenges for Device 
       Independence Published&lt;/title&gt;
    &lt;description&gt;25 October 2002: The Device Independence 
       Working Group has released the first public Working Draft of 
       Authoring Challenges for Device Independence. The draft describes 
       the considerations that Web authors face in supporting access to 
       their sites from a variety of different devices. It is written 
       for authors, language developers, device experts and developers 
       of Web applications and authoring systems. Read about the Device 
       Independence Activity (News archive)&lt;/description&gt;
    &lt;link&gt;http://www.w3.org/News/2002#item168&lt;/link&gt;
    &lt;dc:date&gt;2002-10-25&lt;/dc:date&gt;
  &lt;/item&gt;

  &lt;item rdf:about="http://www.w3.org/News/2002#item167"&gt;
    &lt;title&gt;CSS3 Last Call Working Drafts Published&lt;/title&gt;
    &lt;description&gt;24 October 2002: The CSS Working Group has 
       released two Last Call Working Drafts and welcomes comments 
       on them through 27 November. CSS3 module: text is a set of 
       text formatting properties and addresses international contexts. 
       CSS3 module: Ruby is properties for ruby, a short run of text 
       alongside base text typically used in East Asia. CSS3 module: 
       The box model for the layout of textual documents in visual 
       media is also updated. Cascading Style Sheets (CSS) is a 
       language used to render structured documents like HTML and 
       XML on screen, on paper, and in speech. Visit the CSS home 
       page. (News archive)&lt;/description&gt;
    &lt;link&gt;http://www.w3.org/News/2002#item167&lt;/link&gt;
    &lt;dc:date&gt;2002-10-24&lt;/dc:date&gt;
  &lt;/item&gt;

&lt;/rdf:RDF&gt;
</pre>
          </div>
        </div>

        <p><a href="#example40">例40</a>で示しているように、この形式は容易に区別できる部分にまとめることができるコンテンツ用に設計されています。ニュース・サイト、ウェブログ、スポーツの得点、株価などは、すべてRSS 1.0の使用例です。</p>

        <p>HTTPを「話す」ことができるアプリケーションでRSS配信を要求できます。しかし、最近では、RSS 1.0アプリケーションは以下の3つの異なるカテゴリーに分かれています。</p>

        <ul>
          <li>オンライン・アグリゲーター － <a href="#figure20">図20</a>で並べて示している<a href="www.oreillynet.com/meerkat/index.php?amp;c=4743&amp;t=ALL">Meerkat</a>や<a href="www.newsisfree.com/sources/info/906/">NewsIsFree</a>などのサイト（それぞれはW3Cのニュース・コラムのミラーリング）。これらは、何千もの情報源から配信を収集し、<code>&lt;item&gt;</code>ごとに切り離し、再び1つの大きなグループにまとめます。そして、そのグループ全体が検索できるようになります。このような方法で、例えば「Java」に関する最新ニュースを、全てのサイトを検索しなくても、恐らく何千ものサイトから検索できます。</li>

          <li>デスクトップ・リーダー － <a href="www.disobey.com/amphetadesk/">Amphetadesk</a>や<a href="ranchero.com/netnewswire/">NetNewsWire Lite</a>などのユーティリティを使用すると、ユーザーはデスクトップから何百もの配信を購読できます。通常、リーダーは1時間ごとに各配信を更新し、ユーザが最新情報を得られるようにしてくれます。</li>

          <li>スクリプト － RSSの本来の目的は、ウェブマスターが自分のサイトに他のサイトのコンテンツを組み込めるようにすることでした。RSS 1.0は、トップページにRSS配信を組み込んでいる多くのサイト（例えば、<a href="slashdot.org/">Slashdot</a>）で、今でもこの方法で使用されています。</li>
        </ul>

        <div class="figure">
          <a href="www.asahi-net.or.jp/~ax2s-kmtn/internet/rdf/meerkat-rss.crop.gif"><img src="www.asahi-net.or.jp/~ax2s-kmtn/internet/rdf/fig19Adec16.gif" alt="MeerkatのRSS"></a> <a href="www.asahi-net.or.jp/~ax2s-kmtn/internet/rdf/newsisfree-rss.crop.gif"><img src="www.asahi-net.or.jp/~ax2s-kmtn/internet/rdf/fig19Bdec16.gif" alt="NewsIsFreeのRSS"></a><br>
          <br>
           <a id="figure20" name="figure20">図20: MeerKatとNewsIsFree</a>
        </div>

        <p>RSS 1.0は拡張可能なように設計されています。別のRDF語彙（または、RSS開発コミュニティーでは<em>モジュール</em>として知られている）をインポートすることにより、RSS 1.0の著者は、大量のメタデータや取り扱い上の注意事項をファイルの受信者に提供できます。より一般的なRDF語彙と同様に、誰でもモジュールを書くことができます。現在、<a href="web.resource.org/rss/1.0/">3つの公式モジュール</a>と、コミュニティー全体がもうじき承認する<a href="web.resource.org/rss/1.0/modules/proposed.html">19の提案モジュール</a>があります。これらのモジュールは、完全な<a href="web.resource.org/rss/1.0/modules/dc/">ダブリン・コアのモジュール</a>から<a href="web.resource.org/rss/1.0/modules/aggregation/">集約モジュール</a>などのより特化したRSS中心のモジュールにまで及びます。</p>

        <p>RDFの範囲で「RSS」を論じる時には注意が必要です。現在、RSS仕様には2つの系統があります。1つ（RSS 0.91,0.92,0.93,0.94と2.0）はRDFを使用せず、もう1つ（RSS 0.9 and 1.0）は使用します。</p>
      </div>

      <div class="section">
        <h3>
<a id="cimxml" name="cimxml"></a>6.5 CIM/XML</h3>

        <p>電気事業は、多様な目的に電力システム・モデルを使用しています。例えば、計画とセキュリティー分析には、電力システムのシミュレーションが必要です。また、電力システム・モデルは、例えばエネルギー制御センターで使用するエネルギー管理システム（Energy Management Systems；EMS）などでの実際の運営にも使用されています。運営上の電力システム・モデルは、何千ものクラスの情報から構成されることがあります。これらのモデルを組織内で使用すること以外に、事業には、例えば送電の調整や信頼できる運営の確保のために、計画と運営の両方を目的としたシステム・モデリング情報の交換が必要です。しかし、個々の事業は、これらの目的に対して異なるソフトウェアを使用しており、その結果、システム・モデルが異なる形式で蓄えられるため、モデルの交換が難しくなっています。</p>

        <p>電力システム・モデルの交換に対応するために、事業では、電力システムの事業体と関係性に関する共通定義に合意する必要がありました。これに対応するために、非営利のエネルギー研究コンソーシアムである<a href="www.epri.com/">電力研究所</a>（Electric Power Research Institute；EPRI）が、共通情報モデル（Common Information Model；CIM）<a href="#ref-cim">[CIM]</a>を開発しました。CIMでは、電力システムの資源、その属性、関係に対する共通のセマンティックスを定めています。さらに、CIMモデルを電子的に交換する性能もサポートするために、電力業界は、XMLでCIMモデルを表現するための言語である<a href="www.langdale.com.au/CIMXML/">CIM/XML</a>を開発しました。CIM/XMLは、RDFとRDFスキーマを使用してXML構造を組織化するRDFアプリケーションです。<a href="www.nerc.com/">北米電気信頼度協議会</a>（North American Electric Reliability Council；NERC）（北米の電気供給の信頼性向上のために結成された業界が支援する組織）は、送電システムのオペレーターの間でモデルを交換するための標準としてCIM/XMLを採用しました。CIM/XMLフォーマットは、IECの国際標準化プロセスも踏んでいます。<a href="#ref-devos">[DWZ01]</a>には、CIM/XMLの素晴らしい議論が掲載されています。[注意: この電力業界のCIMを、分散型のソフトウェアやネットワーク、企業環境に関する管理情報を表現するための<a href="www.dmtf.org/">分散管理タスクフォース</a>（Distributed Management Task Force）が開発したCIMと混同してはいけません。DMTFのCIMもXML表現を持っています。しかし、RDFを使用する方向に進行している独自の研究もあますが、現在のところは使用していません。]</p>

        <p>CIMは、電気事業のすべての主要な客体を目的語のクラスや属性として、また、それらの関係を表現できます。CIMは、これらの目的語のクラスや属性を使用して、業者固有のEMSシステム間や、EMSシステムと発電管理や送電管理のような電力システム運営の様々な側面に関連する他のシステムとの間で独自に開発されたアプリケーションの統合をサポートします。</p>

        <p>CIMは、統一モデリング言語（Unified Modeling Language；UML）を使用した1組のクラスの図表として指定されます。CIMの基底クラスは<code>PowerSystemResource</code>クラスで、<code>Substation</code>や<code>Switch</code>、<code>Breaker</code>などの他のより特化したクラスをサブクラスとして定義しています。CIM/XMLは、CIMをRDFスキーマ語彙として表現し、RDF/XMLを特定のシステム・モデルを交換するための言語として使用します。<a href="#example41">例41</a>では、CIM/XMLのクラスとプロパティーの定義の例を示しています。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example41" name="example41">例41: CIM/XMLのクラスとプロパティーの定義の例</a>
          </div>

          <div class="exampleInner">
<pre>
&lt;rdfs:Class rdf:ID="PowerSystemResource"&gt;
   &lt;rdfs:label xml:lang="en"&gt;PowerSystemResource&lt;/rdfs:label&gt; 
  &lt;rdfs:comment&gt;"A power system component that can be either an
    individual element such as a switch or a set of elements 
    such as a substation. PowerSystemResources that are sets 
    could be members of other sets. For example a Switch is a 
    member of a Substation and a Substation could be a member
     of a division of a Company"&lt;/rdfs:comment&gt; 
&lt;/rdfs:Class&gt;

&lt;rdfs:Class rdf:ID="Breaker"&gt; 
  &lt;rdfs:label xml:lang="en"&gt;Breaker&lt;/rdfs:label&gt; 
  &lt;rdfs:subClassOf rdf:resource="#Switch" /&gt; 
  &lt;rdfs:comment&gt;"A mechanical switching device capable of making, 
     carrying, and breaking currents under normal circuit conditions 
     and also making, carrying for a specified time, and breaking 
     currents under specified abnormal circuit conditions e.g. those 
     of short circuit. The typeName is the type of breaker, e.g., 
     oil, air blast, vacuum, SF6."&lt;/rdfs:comment&gt;
 &lt;/rdfs:Class&gt;

&lt;rdf:Property rdf:ID="Breaker.ampRating"&gt; 
   &lt;rdfs:label xml:lang="en"&gt;ampRating&lt;/rdfs:label&gt; 
   &lt;rdfs:domain rdf:resource="#Breaker" /&gt; 
   &lt;rdfs:range rdf:resource="#CurrentFlow" /&gt; 
   &lt;rdfs:comment&gt;"Fault interrupting rating in amperes"&lt;/rdfs:comment&gt; 
&lt;/rdf:Property&gt;
</pre>
          </div>
        </div>

        <p>CIM/XMLは、モデルの表現を簡略化するために、完全なRDF/XML構文のサブセットのみを使用します。さらに、CIM/XMLはRDFスキーマ語彙への一部の拡張を実装します。この拡張は、逆の役割および、特定の資源に対していくつの特定のプロパティーのインスタンスが許されるのかを記述する多重度（カーディナリティー）制約をサポートします（多重性宣言に許されている値は、0か1、きっかり1、0以上、1以上です）。<a href="#example42">例42</a>のプロパティーでは、この拡張（<code>cims:</code> QName接頭辞によって識別される）を例示しています。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example42" name="example42">例42: RDFスキーマの一部のCIM/XML拡張</a>
          </div>

          <div class="exampleInner">
<pre>
&lt;rdf:Property rdf:ID="Breaker.OperatedBy"&gt; 
   &lt;rdfs:label xml:lang="en"&gt;OperatedBy&lt;/rdfs:label&gt; 
   &lt;rdfs:domain rdf:resource="#Breaker" /&gt; 
   &lt;rdfs:range rdf:resource="#ProtectionEquipment" /&gt; 
   &lt;cims:inverseRoleName rdf:resource="#ProtectionEquipment.Operates" /&gt; 
   &lt;cims:multiplicity rdf:resource="http://www.cim-logic.com/schema/990530#M:0..n" /&gt;
   &lt;rdfs:comment&gt;"Circuit breakers may be operated by 
       protection relays."&lt;/rdfs:comment&gt;
&lt;/rdf:Property&gt;
&lt;rdf:Property rdf:ID="ProtectionEquipment.Operates"&gt; 
   &lt;rdfs:label xml:lang="en"&gt;Operates&lt;/rdfs:label&gt; 
   &lt;rdfs:domain rdf:resource="#ProtectionEquipment" /&gt; 
   &lt;rdfs:range rdf:resource="#Breaker" /&gt; 
   &lt;cims:inverseRoleName rdf:resource="#Breaker.OperatedBy" /&gt; 
   &lt;cims:multiplicity rdf:resource="http://www.cim-logic.com/schema/990530#M:0..n" /&gt;
   &lt;rdfs:comment&gt;"Circuit breakers may be operated by 
       protection relays."&lt;/rdfs:comment&gt;
&lt;/rdf:Property&gt;
</pre>
          </div>
        </div>

        <p>EPRIでは、様々なベンダー製品間で実際の大規模なモデル（テストの1事例として、2000以上の変電所を記述したデータが含まれる）を交換するためにCIM/XMLを使用して相互運用性テストを成功裡に行い、このモデルが一般のユーティリティ・アプリケーションで正しく解釈されることを確認しました。CIMは元々、EMSシステムを目的としていましたが、送電やその他の用途にも対応するように拡張されています。</p>

        <p><a href="www.omg.org/">オブジェクト管理グループ</a>（Object Management Group；OMG）は、オブジェクト・インターフェース標準を採用して、データ・アクセス設備（Data Access Facility）<a href="#ref-daf">[DAF]</a>というCIM電力ステム・モデルにアクセスしています。CIM/XML言語と同様に、DAFは、RDFモデルに基づいており、同じCIMスキーマを共有します。しかし、CIM/XMLはモデルがドキュメントとして交換できるようにしますが、DAFはアプリケーションが1組のオブジェクトとしてモデルにアクセスできるようにします。</p>

        <p>CIM/XMLは、エンティティーの関係やオブジェクト指向クラス、属性、関係として必然的に表現される情報のXMLベースの交換をサポートする際に、RDFが果たすことのできる有益な役割を例示します（その情報が必ずしもウェブでアクセスできない場合でも）。この場合、RDFは、オブジェクトの識別と構造化された関係への使用をサポートする基本構造をXMLに提供します。この関係は、RDF（または、OWLなどのオントロジー言語）とUML（そして、そのXML表現）の関連性を調査する多くのプロジェクトのみならず、情報交換用にRDF/XMLを使用する多くのアプリケーションによって示されます。また、CIM/XMLがカーディナリティー制約と逆の関係をサポートするためにRDFスキーマを拡張する必要があるということから、<a href="#richerschemas">5.5項</a>で述べたDAML+OILやOWLなどのより強力なRDFベースのスキーマ／オントロジー言語の開発を導いた種々の要件も説明できます。このような言語は、多くの同様のモデル・アプリケーションを将来サポートする際に適しているかもしれません。</p>

        <p>最後に、CIM/XMLは、「現在のRDF」の例をさらに求める人にとって重要な事実も示しています。つまり、言語が「XML」言語として記述されることがあるとか、システムが「XML」を使用していると記述されてるとか、そして、実際に使用している「XML」がRDF/XMLであるなどで、つまり、これらはRDFアプリケーションであるということです。これを見つけるために、言語やシステムの記述をかなり詳細に探す必要があることがあります。（RDFが全く明示的に述べられていない例も一部ありますが、サンプル・データではRDF/XMLであることが明確に分かります）。そのうえ、CIM/XMLなどのアプリケーションは、一般的なアクセスではなくソフトウェア・コンポーネント間での情報交換を目的としているため、生成されたRDFはウェブで容易に探せないでしょう（将来のシナリオでは、この種のRDFがより多くウェブでアクセス可能になると想像できますが）。</p>
      </div>

      <div class="section">

        <h3>
<a id="geneont" name="geneont"></a>6.6 遺伝子オントロジー・コンソーシアム</h3>

        <p><a href="www.snomed.org/">SNOMED RT</a>（Systematized Nomenclature of Medicine Reference Terminology）や<a href="www.nlm.nih.gov/mesh/meshhome.html">MeSH</a>（Medical Subject Headings）などの統制語彙を使用した構造化されたメタデータは、より効率的な文献検索を可能にして医療知識<a href="#ref-cowan">[COWAN]</a>の配信や交換をサポートし、医療で重要な役割を果たしています。同時に、医療の分野は急激に変化するため、語彙をさらに開発する必要性が生じます。</p>

        <p><a href="www.geneontology.org/">遺伝子オントロジー（GO）コンソーシアム</a>（Gene Ontology (GO) Consortium） <a href="#ref-go">[GO]</a>の目的は、統制語彙を提供して遺伝子産物の特定の側面を記述することです。データベースと連携すれば、注釈を裏付けるために参照を提供したりどのような証拠が利用できるかを示して、遺伝子産物（または、遺伝子）をGO用語で注釈します。これらのデータベースで共通のGO用語を使用すれば、統一的な横断検索が容易になります。GOオントロジーは、帰属と照会の両方を異なるレベルの粒度で実行できるように構造化されます。細胞内の遺伝子やタンパク質の役割に関する知識が蓄積され変化しているため、GO語彙は動的です。</p>

        <p>GOの3つの組織化原理は、<em>分子機能</em>、<em>生物学的過程</em>、<em>細胞成分</em>です。遺伝子産物は、1つ以上の分子機能を持ち、1つ以上の生物学的過程で使用され、1つ以上の細胞成分であるか、関連しています。これらのすべて3つのオントロジー内の用語の定義は、1つの（テキスト形式の）定義ファイルに含まれています。3つすべてのオントロジーのファイルとすべての利用可能な定義を含んだXML形式のバージョンが毎月生成されます。</p>

        <p>機能、過程、成分は、有向非巡回グラフ（DAG）またはネットワークとして表現されます。子用語はその親用語の「インスタンス」（isa関係）か、その親用語の構成要素（part-of関係）でありえます。子用語は、複数の親用語を持つことができ、異なる関係のクラスを異なる親と持つことができます。このオントロジーでは、同義語や外部のデータベースとの相互参照も表現されます。<span class="newstuff">GOは、広範囲なツールをサポートし、グラフ構造の表現に柔軟性があるため、RDF/XML機能を使用して、XMLバージョンのオントロジーにおける用語間の関係を表現します。同時に、GOは現在、用語の記述内で<em>非</em>RDFの入れ子のXML構造を使用するため、使用される言語は純粋なRDF/XMLではありません。</span></p>

        <p><a href="#example43">例43</a>は、<a href="www.geneontology.org/GO.doc.html">GOドキュメント</a>からのGO情報のサンプルの一部を示しています。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example43" name="example43">例43: GO情報のサンプル</a>
          </div>

          <div class="exampleInner">
<pre>
&lt;?xml version="1.0" encoding="UTF-8"?&gt; 
&lt;!DOCTYPE go:go&gt; 
&lt;go:go xmlns:go="http://www.geneontology.org/xml-dtd/go.dtd#" 
       xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt; 
  &lt;go:version timestamp="Wed May 9 23:55:02 2001" /&gt; 

  &lt;rdf:RDF&gt; 
     &lt;go:term rdf:about="http://www.geneontology.org/go#GO:0003673"&gt; 
        &lt;go:accession&gt;GO:0003673&lt;/go:accession&gt; 
        &lt;go:name&gt;Gene_Ontology&lt;/go:name&gt; 
        &lt;go:definition&gt;&lt;/go:definition&gt; 
     &lt;/go:term&gt; 

     &lt;go:term rdf:about="http://www.geneontology.org/go#GO:0003674"&gt;
         &lt;go:accession&gt;GO:0003674&lt;/go:accession&gt;         &lt;go:name&gt;molecular_function&lt;/go:name&gt; 
        &lt;go:definition&gt;The action characteristic of a gene product.&lt;/go:definition&gt; 
        &lt;go:part-of rdf:resource="http://www.geneontology.org/go#GO:0003673" /&gt; 
        &lt;go:dbxref&gt; 
           &lt;go:database_symbol&gt;go&lt;/go:database_symbol&gt; 
           &lt;go:reference&gt;curators&lt;/go:reference&gt; 
        &lt;/go:dbxref&gt; 
     &lt;/go:term&gt; 
     &lt;go:term rdf:about="http://www.geneontology.org/go#GO:0016209"&gt; 
        &lt;go:accession&gt;GO:0016209&lt;/go:accession&gt; 
        &lt;go:name&gt;antioxidant&lt;/go:name&gt; 
        &lt;go:definition&gt;&lt;/go:definition&gt; 
        &lt;go:isa rdf:resource="http://www.geneontology.org/go#GO:0003674" /&gt; 
        &lt;go:association&gt; 
           &lt;go:evidence evidence_code="ISS"&gt; 
              &lt;go:dbxref&gt;
                  &lt;go:database_symbol&gt;fb&lt;/go:database_symbol&gt; 
                 &lt;go:reference&gt;fbrf0105495&lt;/go:reference&gt; 
              &lt;/go:dbxref&gt; 
           &lt;/go:evidence&gt; 
           &lt;go:gene_product&gt; 
              &lt;go:name&gt;CG7217&lt;/go:name&gt; 
              &lt;go:dbxref&gt; 
                 &lt;go:database_symbol&gt;fb&lt;/go:database_symbol&gt; 
                 &lt;go:reference&gt;FBgn0038570&lt;/go:reference&gt; 
              &lt;/go:dbxref&gt; 
           &lt;/go:gene_product&gt; 
        &lt;/go:association&gt; 
        &lt;go:association&gt; 
           &lt;go:evidence evidence_code="ISS"&gt; 
              &lt;go:dbxref&gt; 
                 &lt;go:database_symbol&gt;fb&lt;/go:database_symbol&gt; 
                 &lt;go:reference&gt;fbrf0105495&lt;/go:reference&gt; 
              &lt;/go:dbxref&gt; 
           &lt;/go:evidence&gt; 
           &lt;go:gene_product&gt;
               &lt;go:name&gt;Jafrac1&lt;/go:name&gt; 
              &lt;go:dbxref&gt; 
                 &lt;go:database_symbol&gt;fb&lt;/go:database_symbol&gt; 
                 &lt;go:reference&gt;FBgn0040309&lt;/go:reference&gt; 
              &lt;/go:dbxref&gt; 
           &lt;/go:gene_product&gt; 
        &lt;/go:association&gt; 
      &lt;/go:term&gt; 
  &lt;/rdf:RDF&gt; 
&lt;/go:go&gt; 
</pre>
          </div>
        </div>

        <p><a href="#example43">例43</a>では、<code>go:term</code>が基本要素であることを示しています。場合によっては、GOはRDFスキーマを使用しないで、自身の用語を定義してきました。例えば、用語<code>GO:0016209</code>には、要素<code>&lt;go:isa rdf:resource="http://www.geneontology.org/go#GO:0003674" /&gt;</code>があります。このタグは、「<code>GO:0016209</code> isa <code>GO:0003674</code>」という関係、つまり、英語で言うと「Antioxidant is a molecular function.（酸化防止剤は分子機能です。）」を表現しています。別の特殊化した関係は<code>go:part-of</code>です。例えば、<code>GO:0003674</code>には要素<code>&lt;go:part-of rdf:resource="http://www.geneontology.org/go#GO:0003673" /&gt;</code>があります。これは「分子機能は遺伝子オントロジーの一部です」という意味です。</p>

        <p>すべての注釈は、文献参照や別のデータベース、コンピュータ解析のような、情報源に属していなければなりません。注釈は、引用された情報源でどのような証拠が発見されるのかを示して、遺伝子産物とGO用語との間の関連性を裏づけなければなりません。簡単な統制語彙を使用して証拠を記録します。例には以下のものが含まれます。</p>

        <ul>
          <li>ISSは、「[&lt;database:sequence_id&gt;との]配列相同性から推論された」を意味します。</li>

          <li>IDAは、「直接分析から推論された」を意味します。</li>

          <li>TASは、「追跡可能な著者の発言」を意味します。</li>
        </ul>

        <p><code>go:dbxref</code>要素は外部データベースの用語を表し、<code>go:association</code>は各用語の遺伝子の関連性を表します。<code>go:association</code>は、関連性を裏付ける証拠への<code>go:dbxref</code>を保持する<code>go:evidence</code>と、遺伝子記号と<code>go:dbxref</code>を含む<code>go:gene_product</code>の両方を持つことができます。<span class="newstuff">これらの要素は、これらの要素内に他の要素を入れ子にすることは<a href="#ref-rdf-syntax">[RDF-SYNTAX]</a>の2.1項と2.2項で記述している別のノード／述語アークの「ストライプ」に準じていないため、GO XML構文が「純粋な」RDF/XMLでないことを示します。</span></p>

        <p>GOは、多くの興味深い点を示しています。まず最初に、情報交換のためにXMLを使用する価値を、RDFを使用してそのXMLを構造化することによって高めることができることを示しています。これは、厳密な階層構造ではなく、全面的なグラフやネットワーク構造を持つデータに特に当てはまります。GOは、ウェブを直接使用した時に、RDFを使用したデータが必ずしも表示されない別の例でもあります（ファイルにはウェブでアクセスできますが）。また、一見すると「XML」で記述されているけれども、よく調べてみるとRDF/XML機能（「純粋な」RDF/XMLではないが）を使用しているという、データの別の例もあります。最後に、GOは、オントロジーを表現するための基礎としてRDFが果たすことができる役割を示しています。<a href="#richerschemas">5.5項</a>で論じたDAML+OILやOWL言語などの、オントロジーを指定するためのより豊かなRDFベースの言語がより広範囲に使用されるようになると、この役割はさらに高められます。<span class="newstuff">実際に、<a href="gong.man.ac.uk/">次世代遺伝子オントロジー</a>（Gene Ontology Next Generation）プロジェクトは現在、GOオントロジーの表現をこれらのより豊かな言語で開発しています。</span></p>
      </div>

      <div class="section">

        <h3><a id="devcap" name="devcap">6.7 機器性能とユーザ嗜好の記述</a></h3>

        <p>近年、ウェブをブラウジングするための新しいモバイル機器が多く出現しました。これらの機器の多くは、広範囲な入出力性能や異なるレベルの言語のサポートを含む非常に多様な性能を持っています。モバイル機器は、非常に多様なネットワーク接続性能を持つこともできます。これらの新しい機器のユーザは、機器の性能や現在のネットワーク特性に関係なく、便利な表現を期待します。同様に、ユーザは、コンテンツやアプリケーションが表示される時に、自分達の動的に変わる嗜好（例えば、音声をオン・オフするなど）を考慮して欲しいと考えます。しかし、現実には、機器の異種性や、ユーザが自分達の嗜好をサーバに伝える標準的な方法が欠けていることにより、コンテンツを機器に保存できなかったり、コンテンツを表示できなかったり、コンテンツがユーザの望みに反するといった結果が生じます。さらに、結果的に生成されるコンテンツがネットワークを通じてクライアント機器に達するのに時間がかかり過ぎることもありえます。</p>

        <p>これらの問題に対する解決策は、クライアントが<em>配信コンテキスト</em>―機器の性能、ユーザの嗜好、ネットワーク特性など―を、サーバがそのコンテキストを使用してコンテンツを機器やユーザ用にカスタマイズできるような方法でコード化することです（配信コンテキストの定義に関しては、<a href="#ref-diprinc">[DIPRINC]</a>を参照）。W3Cの複合性能／嗜好プロファイル（Composite Capabilities/Preferences Profile；CC/PP）の仕様<a href="#ref-ccpp">[CC/PP]</a>は、包括的なフレームワークを定義して配信コンテキストを記述することで、この問題に対処するのに役立ちます。</p>

        <p>CC/PPフレームワークは、比較的簡単な構造―構成要素と属性／値の組み合わせによる2つのレベルの階層構造を定義します。<em>構成要素</em>を使用して、配信コンテキストの一部（例えば、ネットワーク特性、機器がサポートするソフトウェア、機器のハードウェア特性など）を収集できます。構成要素には、1つ以上の<em>属性</em>を含むことができます。例えば、ユーザの嗜好をコード化する構成要素には、<em>音声出力</em>（AudioOutput）が必要かどうかを指定する属性を含むことができます。</p>

        <p>CC/PPは、RDFスキーマを使用して構造（上記の階層）を定義します（構造スキーマの詳細に関しては、<a href="#ref-ccpp">[CC/PP]</a>を参照してください）。CC/PP<em>語彙</em>は、特定の構成要素とその属性を定義します。しかし、<a href="#ref-ccpp">[CC/PP]</a>は、このような語彙を定義しません。その代わりに、語彙は他の機関やアプリケーションで定義されます（以下で述べるように）。<a href="#ref-ccpp">[CC/PP]</a>は、CC/PP語彙のインスタンスを送信するプロトコルも定義していません。</p>
        <p>CC/PP語彙のインスタンスを<em>プロファイル</em>と呼びます。CC/PP属性は、プロファイルでRDFプロパティーとしてコード化されます。<a href="#example44">例44</a>では、音声表現を好むユーザのためにユーザ嗜好のプロファイルのフラグメントを示しています。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example44" name="example44">例44: CC/PPプロファイルのフラグメント</a>
          </div>

          <div class="exampleInner">
<pre>
 &lt;ccpp:component&gt;
  &lt;rdf:Description rdf:ID="UserPreferences"&gt;
   &lt;rdf:type rdf:resource="http://www.example.org/profiles/prefs/v1_0#UserPreferences"/&gt;
   &lt;ex:AudioOutput&gt;Yes&lt;/ex:AudioOutput&gt;
   &lt;ex:Graphics&gt;No&lt;/ex:Graphics&gt;
   &lt;ex:Languages&gt;
    &lt;rdf:Seq&gt;
     &lt;rdf:li&gt;en-cockney&lt;/rdf:li&gt;
     &lt;rdf:li&gt;en&lt;/rdf:li&gt;
    &lt;/rdf:Seq&gt;
   &lt;/ex:Languages&gt;
  &lt;/rdf:Description&gt;
 &lt;/ccpp:component&gt;
</pre>
          </div>
        </div>

        <p>このアプリケーションでRDFを使用することには、いくつかの利点があります。まず最初に、CC/PPでコード化したプロファイルには、異なる機関が作成したスキーマで定義された属性を含むことができます。集約されたプロファイル・データに対する<em>上位</em>スキーマを1つの機関が作成することはないだろうと思われるため、RDFはこれらのプロファイルに正にと適しています。RDFの2番目の利点は、（グラフ・ベースのデータ・モデルのおかげで）任意の属性（RDFプロパティー）をプロファイルへ容易に挿入できるようになるということです。これは、ロケーション情報などの、頻繁に変更されるデータを含むプロファイルに特に有益です。</p>

        <p>オープン・モバイル・アライアンス（Open Mobile Alliance）は、ユーザー・エージェント・プロファイル（User Agent Profile；UAProf）<a href="#ref-uaprof">[UAPROF]</a>―プロファイル送信のためのプロトコルのみならず、機器性能、ユーザ・エージェント性能、ネットワーク特性などを記述するための語彙を含むCC/PPベースのフレームワークを定義しました。UAProfは、<em>HardwarePlatform</em>、<em>SoftwarePlatform</em>、<em>NetworkCharacteristics</em>、<em>BrowserUA</em>を含む6つの構成要素を定義しています。構成要素の属性は確定されていませんが―補足されたり置換されうる―各コンポーネントに対してもいくつかの属性を定義しています。<a href="#example45">例45</a>では、UAProfの<em>HardwarePlatform</em>構成要素のフラグメントを示しています。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example45" name="example45">例45: UAProfのHardwarePlatform構成要素のフラグメント</a>
          </div>

          <div class="exampleInner">
<pre>
 &lt;prf:component&gt;
  &lt;rdf:Description rdf:ID="HardwarePlatform"&gt;
   &lt;rdf:type rdf:resource="http://www.openmobilealliance.org/profiles/UAPROF/ccppschema-20021113#HardwarePlatform"/&gt;
   &lt;prf:ScreenSizeChar&gt;15x6&lt;/prf:ScreenSizeChar&gt;
   &lt;prf:BitsPerPixel&gt;2&lt;/prf:BitsPerPixel&gt;
   &lt;prf:ColorCapable&gt;No&lt;/prf:ColorCapable&gt;
   &lt;prf:BluetoothProfile&gt;
    &lt;rdf:Bag&gt;
     &lt;rdf:li&gt;headset&lt;/rdf:li&gt;
     &lt;rdf:li&gt;dialup&lt;/rdf:li&gt;
     &lt;rdf:li&gt;lanaccess&lt;/rdf:li&gt;
    &lt;/rdf:Bag&gt;
   &lt;/prf:BluetoothProfile&gt;
  &lt;/rdf:Description&gt;
 &lt;/prf:component&gt;
</pre>
          </div>
        </div>

        <p>UAProfプロトコルは、<em>静的</em>プロファイルと<em>動的</em>プロファイルの両方をサポートします。<em>静的</em>プロフィールには、URIでアクセスします。これにはいくつかの利点があります。それは、サーバへのクライアントの要求には冗長になりかねないXMLドキュメントではなくURIのみが含まれる（したがって、空中のトラフィックが最小になる）、クライアントはプロファイルを保存そして／または作成する必要がない、クライアントの実装負荷が比較的軽いということです。<em>動的</em>プロファイルはオン・ザ・フライで作成され、その結果、関連するURIを持ちません。動的プロファイルは、静的プロファイルとの<em>相違点</em>を含むプロファイル・フラグメントで構成することもできますが、クライアントの静的プロファイルに含まれていない一意のデータを含むこともできます。要求には、静的プロファイルと動的プロファイルをいくつでも含むことができます。しかし、要求では、古いプロファイルが新しいプロファイルに置換えられるため、プロファイルの順序は重要です。UAProfのプロトコルと、複数のプロファイルを処理するための規則に関する詳細情報に関しては<a href="#ref-uaprof">[UAPROF]</a>を参照してください。</p>

        <p>他のいくつかのコミュニティー（3GPPのTS 26.234 <a href="#ref-3gpp">[3GPP]</a>やWAPフォーラムのマルチメディア・メッセージング・サービス・クライアント・トランザクション仕様（Multimedia Messaging Service Client Transactions Specification；MMS-CTR）など<a href="#ref-mms">[MMS-CTR]</a>）がCC/PPに基づいた語彙を定義しました。その結果、プロファイルは、RDFの分散的な性質を利用して様々な語彙で定義された構成要素を含むことができます。<a href="#example46">例46</a>では、このようなプロファイルを示しています。</p>

        <div class="exampleOuter">
          <div class="c1">
            <a id="example46" name="example46">例46: 数個の語彙を使用したプロファイル</a>
          </div>

          <div class="exampleInner">
<pre>
&lt;rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
         xmlns:prf="http://www.wapforum.org/profiles/UAPROF/ccppschema-20010330#"
         xmlns:mms="http://www.wapforum.org/profiles/MMS/ccppschema-20010111#"
     xmlns:pss="http://www.3gpp.org/profiles/PSS/ccppschema-YYYYMMDD#"&gt;

 &lt;rdf:Description rdf:ID="SomeDevice"&gt;
  &lt;prf:component&gt;
   &lt;rdf:Description rdf:ID="Streaming"&gt;
    &lt;rdf:type rdf:resource="http://www.3gpp.org/profiles/PSS/ccppschema-PSS5#Streaming"/&gt;
    &lt;pss:AudioChannels&gt;Stereo&lt;/pss:AudioChannels&gt;
    &lt;pss:VideoPreDecoderBufferSize&gt;30720&lt;/pss:VideoPreDecoderBufferSize&gt;
    &lt;pss:VideoInitialPostDecoderBufferingPeriod&gt;0&lt;/pss:VideoInitialPostDecoderBufferingPeriod&gt;
    &lt;pss:VideoDecodingByteRate&gt;16000&lt;/pss:VideoDecodingByteRate&gt;
   &lt;/rdf:Description&gt;
  &lt;/prf:component&gt; 
  &lt;prf:component&gt;
   &lt;rdf:Description rdf:ID="MmsCharacteristics"&gt;
    &lt;rdf:type rdf:resource="http://www.wapforum.org/profiles/MMS/ccppschema-20010111#Streaming"/&gt;
    &lt;mms:MmsMaxMessageSize&gt;2048&lt;/mms:MmsMaxMessageSize&gt;
    &lt;mms:MmsMaxImageResolution&gt;80x60&lt;/mms:MmsMaxImageResolution&gt;
    &lt;mms:MmsVersion&gt;2.0&lt;/mms:MmsVersion&gt;
   &lt;/rdf:Description&gt;
  &lt;/prf:component&gt;

  &lt;prf:component&gt;
   &lt;rdf:Description rdf:ID="PushCharacteristics"&gt;
    &lt;rdf:type rdf:resource="http://www.openmobilealliance.org/profiles/UAPROF/ccppschema-20010330#PushCharacteristics"/&gt;
    &lt;prf:Push-MsgSize&gt;1024&lt;/prf:Push-MsgSize&gt;
    &lt;prf:Push-MaxPushReq&gt;5&lt;/prf:Push-MaxPushReq&gt;
    &lt;prf:Push-Accept&gt;
     &lt;rdf:Bag&gt;
      &lt;rdf:li&gt;text/html&lt;/rdf:li&gt;
      &lt;rdf:li&gt;text/plain&lt;/rdf:li&gt;
      &lt;rdf:li&gt;image/gif&lt;/rdf:li&gt;
     &lt;/rdf:Bag&gt;
    &lt;/prf:Push-Accept&gt;
   &lt;/rdf:Description&gt;
  &lt;/prf:component&gt;

 &lt;/rdf:Description&gt;
&lt;/rdf:RDF&gt;</pre>
          </div>
        </div>

        <p>配信コンテキストの定義とコンテキスト内のデータは絶えず進化します。その結果、RDFの本来の拡張性と、それ故に動的に変化する語彙に対するサポートによって、RDFは配信コンテキストのコード化に適したフレームワークになります。</p>

      </div>
    </div>

    <div class="section">
      <h2><a id="otherparts" name="otherparts">7. RDF仕様のその他の部分</a></h2>

      <p><a href="#intro">1項</a>では、RDFの仕様が（この入門書に加え）以下の多くのドキュメントで構成されることを示しました。</p>

      <ul>
        <li>
<a href="www.w3.org/TR/rdf-concepts/">RDF概念および抽象構文</a> <a href="#ref-rdf-concepts">[RDF-CONCEPTS]</a>
</li>

        <li>
<a href="www.w3.org/TR/rdf-syntax-grammar/">RDF/XML構文仕様</a> <a href="#ref-rdf-syntax">[RDF-SYNTAX]</a>
</li>

        <li>
<a href="www.w3.org/TR/rdf-schema/">RDF語彙記述言語1.0: RDFスキーマ</a> <a href="#ref-rdf-vocabulary">[RDF-VOCABULARY]</a>
</li>

        <li>
<a href="www.w3.org/TR/rdf-mt/">RDFセマンティクス</a> <a href="#ref-rdf-semantics">[RDF-SEMANTICS]</a>
</li>
        <li>
<a href="www.w3.org/TR/rdf-testcases/">RDFテストケース</a> <a href="#ref-rdf-tests">[RDF-TESTS]</a>
</li>
      </ul>

      <p>この入門書では、これらのドキュメントのいくつかのテーマ、つまり、RDFの基本概念（<a href="#statements">2項</a>）、RDF/XML構文（<a href="#rdfxml">3項</a>）、RDFスキーマ（<a href="#rdfschema">5項</a>）について既に論じました。この項では、RDFの完全な仕様におけるこれらのドキュメントの役割について説明するために、残りのドキュメントについて簡潔に述べます（<a href="#ref-rdf-semantics">[RDF-SEMANTICS]</a>は既に何度も参照しましたが）。</p>

      <div class="section">
        <h3><a id="semantics" name="semantics">7.1 RDFセマンティクス</a></h3>

        <p>前項で論じたように、RDFは、特定の語彙（資源、プロパティー、クラスなどの名前）を使用して、資源に関するステートメントをグラフの形式で表わすために使用することを目的としています。RDFは、<a href="#richerschemas">5.5項</a>で論じたような、より高度な言語の基盤になることも目的としています。これらの目的を果たすために、RDFグラフの「意味」は非常に正確な方法で定義されなければなりません。</p>

        <p>非常に一般的な意味で、RDFグラフの「意味」が厳密に何で構成されているかは、ユーザが定義したRDFのクラスやプロパティーを特定の方法で解釈するユーザ・コミュニティー内の規定や、自然言語によるコメント、他のコンテンツを持つドキュメントへのリンクを含む、多くの要素に依存しています。<a href="#rdfmodel">2.2項</a>で簡潔に指摘したように、この意味は、RDF情報の人間の翻訳者が使用したり、そのRDF情報で様々な種類の処理を実行するソフトウェアを書くプログラマが使用したりできますが、これらの形式で伝えられた意味の多くは、機械処理には直接利用できないでしょう。しかし、RDFステートメントには、機械が特定のRDFグラフから引き出せる結論（または、<em>含意</em>）を極めて正確に決定づける<em>形式的な</em>意味もあります。<a href="www.w3.org/TR/rdf-mt/">RDFセマンティクス</a> <a href="#ref-rdf-semantics">[RDF-SEMANTICS]</a>ドキュメントでは、形式言語のセマンティクスを指定するための<em>モデル理論</em>と呼ばれる技術を使用してこの形式的な意味を定義しています。<span class="newstuff"><a href="#ref-rdf-semantics">[RDF-SEMANTICS]</a>は、RDFスキーマや個々のデータ型によって表現されたRDF言語へのセマンティックの拡張も定義しています。</span>言い換えれば、RDFモデル理論は、すべてのRDF概念に対する形式的な基盤を提供しています。モデル理論で定義されているセマンティクスに基づいて、RDFグラフを基本的に同じ意味を持つ論理式に翻訳するのは簡単です。</p>
      </div>

      <div class="section">

        <h3><a id="testcases" name="testcases">7.2 テストケース</a></h3>

        <p><a href="www.w3.org/TR/rdf-testcases/">RDFテストケース</a> <a href="#ref-rdf-tests">[RDF-TESTS]</a>は、RDFコア・ワーキンググループが対処した特定の技術的な課題に対応するテストケース（例）でRDF仕様の原文を補います。テストケース・ドキュメントでは、これらの例の記述に役立つように、<a href="www.w3.org/TR/rdf-testcases/#ntriples">Nトリプル</a>と呼ばれる表記法を導入し、これによって、この入門書を通じて使用しているトリプル表記法の根拠を提供しています。テストケースは、テストケース・ドキュメントで参照されているウェブ・ロケーションに機械可読形式で掲載されているため、開発者は、RDFソフトウェアの自動テストの根拠としてこれらを使用できます。</p>

        <p>テストケースは、以下の多くのカテゴリーに分類されています。</p>

        <ul>
          <li>ポジティブ・パーサ・テストおよびネガティブ・パーサ・テスト: これらは、RDF/XMLパーサが正当なRDF/XMLから正しいNトリプル出力グラフを作成するかどうか、または、入力ドキュメントが正当なRDF/XMLでない場合にエラーを正しく報告するかをテストします。</li>

          <li>ポジティブ含意テストおよびネガティブ含意テスト: これらは、一連の指定されたRDFステートメントから適切な含意（結論）が引き出せるかどうかをテストします。</li>

          <li>データ型を意識した含意テスト: これらは、データ型の使用に関わるポジティブまたはネガティブの含意テストであり、したがって、このテストに関わる特定のデータ型に対する追加サポートを要します。</li>

          <li>その他のテスト: これらは、上記のカテゴリーに該当しないテストです。</li>
        </ul>

        <p>このテストケースは、RDFの完全な仕様ではなく、他の仕様ドキュメントに優先するものでもありません。しかし、これは、RDFの設計に関するRDFコア・ワーキンググループの意図を示すことを目的としており、仕様のある詳細部分の表現が不明瞭である場合、このテストケースは開発者にとって役立つものとなるでしょう。</p>

      </div>
    </div>

    <div class="section">
      <h2><a name="references" id="references">8. 参考文献</a></h2>

      <div class="section">
        <h3><a name="normative-references" id="normative-references">8.1 規範的な参考文献</a></h3>

        <dl>
          <dt>
<a id="ref-rdf-concepts" name="ref-rdf-concepts"></a>[RDF-CONCEPTS]</dt>

          <dd>
<cite><a href="www.w3.org/TR/2004/REC-rdf-concepts-20040210/">Resource
          Description Framework (RDF): Concepts and Abstract
          Syntax</a></cite>, Klyne G., Carroll J. (Editors), W3C Recommendation, 10 February 2004. <a href="www.w3.org/TR/2004/REC-rdf-primer-20040210/">最新バージョン</a>は、http://www.w3.org/TR/2004/REC-rdf-primer-20040210/です。<a href="www.w3.org/TR/rdf-concepts/">最新バージョン</a>は、http://www.w3.org/TR/rdf-concepts/です。</dd>

          <dt>
<a id="ref-rdf-mime-type" name="ref-rdf-mime-type"></a>[RDF-MIME-TYPE]</dt>
  <dd>
    <cite><a href="www.iana.org/assignments/media-types/">MIME Media Types</a></cite>, The Internet Assigned Numbers Authority (IANA). このドキュメントは、http://www.iana.org/assignments/media-types/です。<a href="www.w3.org/2001/sw/RDFCore/mediatype-registration"><code>application/rdf+xml</code>への登録</a>は、http://www.w3.org/2001/sw/RDFCore/mediatype-registrationでアーカイブされています。
  </dd>

          <dt><a id="ref-rdfms" name="ref-rdfms">[RDF-MS]</a></dt>

          <dd>
<cite><a href="www.w3.org/TR/1999/REC-rdf-syntax-19990222/">Resource
          Description Framework (RDF) Model and Syntax
          Specification</a></cite>, Lassila O., Swick R. (Editors),
          World Wide Web Consortium, 22 February 1999. <a href="www.w3.org/TR/1999/REC-rdf-syntax-19990222/">本バージョン</a>は、http://www.w3.org/TR/1999/REC-rdf-syntax-19990222/です。<a href="www.w3.org/TR/REC-rdf-syntax/">最新バージョン</a>は、http://www.w3.org/TR/REC-rdf-syntax/です。</dd>

          <dt>
<a id="ref-rdf-semantics" name="ref-rdf-semantics"></a>[RDF-SEMANTICS]</dt>

          <dd>
<cite><a href="www.w3.org/TR/2004/REC-rdf-mt-20040210/">RDF
          Semantics</a></cite>, Hayes P. (Editor), W3C Recommendation,
10 February 2004。<a href="www.w3.org/TR/2004/REC-rdf-mt-20040210/">本バージョン</a>は、http://www.w3.org/TR/2004/REC-rdf-mt-20040210/です. <a href="www.w3.org/TR/rdf-mt/">最新バージョン</a>は、http://www.w3.org/TR/rdf-mt/です。</dd>
          <dt>
<a id="ref-rdf-syntax" name="ref-rdf-syntax"></a>[RDF-SYNTAX]</dt>

          <dd>
<cite><a href="www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/">
          RDF/XML Syntax Specification (Revised)</a></cite>, Beckett
          D.  (Editor), W3C Recommendation, 10 February 2004. <a href="www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/">本バージョン</a>は、http://www.w3.org/TR/2004/REC-rdf-syntax-grammar-20040210/です。<a href="www.w3.org/TR/rdf-syntax-grammar/">最新バージョン</a>は、http://www.w3.org/TR/rdf-syntax-grammar/です。</dd>

          <dt>
<a id="ref-rdf-tests" name="ref-rdf-tests"></a>[RDF-TESTS]</dt>

          <dd>
<cite><a href="www.w3.org/TR/2004/REC-rdf-testcases-20040210/">RDF
          Test Cases</a></cite>, Grant J., Beckett D. (Editors), W3C
Recommendation, 10 February 2004. <a href="www.w3.org/TR/2004/REC-rdf-testcases-20040210/">本バージョン</a>は、http://www.w3.org/TR/2004/REC-rdf-testcases-20040210/です。<a href="www.w3.org/TR/rdf-testcases/">最新バージョン</a>は、http://www.w3.org/TR/rdf-testcases/です。</dd>

          <dt>
<a id="ref-rdf-vocabulary" name="ref-rdf-vocabulary"></a>[RDF-VOCABULARY]</dt>

          <dd>
<cite><a href="www.w3.org/TR/2004/REC-rdf-schema-20040210/">RDF
          Vocabulary Description Language 1.0: RDF Schema</a></cite>,
          Brickley D., Guha R.V. (Editors), W3C Recommendation, 10 February 2004.
<a href="www.w3.org/TR/2004/REC-rdf-schema-20040210/">本バージョン</a>は、http://www.w3.org/TR/2004/REC-rdf-schema-20040210/です。<a href="www.w3.org/TR/rdf-schema/">最新バージョン</a>は、http://www.w3.org/TR/rdf-schema/です。</dd>

      <dt>
<a id="ref-unicode" name="ref-unicode"></a>[UNICODE]</dt>

      <dd>
<cite>The Unicode Standard, Version 3</cite>, The Unicode
      Consortium, Addison-Wesley, 2000。ISBN 0-201-61633-5、新しいバージョンの公表により時々更新される。（標準およびユニコード文字データベースのバージョンに関する最新バージョンと追加情報に関しては、<a href="www.unicode.org/unicode/standard/versions/">http://www.unicode.org/unicode/standard/versions/</a>を参照）。</dd>

          <dt><a id="ref-uri" name="ref-uri">[URIS]</a></dt>

          <dd>
<cite><a href="www.isi.edu/in-notes/rfc2396.txt">RFC 2396 -          Uniform Resource Identifiers (URI): Generic
          Syntax</a></cite>, Berners-Lee T., Fielding R., Masinter L.,
          IETF, August 1998, http://www.isi.edu/in-notes/rfc2396.txt.</dd>
          <dt><a id="ref-xml" name="ref-xml">[XML]</a></dt>

          <dd>
<cite><a href="www.w3.org/TR/2000/REC-xml-20001006">Extensible
          Markup Language (XML) 1.0, Second Edition</a></cite>, Bray
          T., Paoli J., Sperberg-McQueen C.M., Maler E. (Editors),
          World Wide Web Consortium, 6 October 2000. <a href="www.w3.org/TR/2000/REC-xml-20001006">本バージョン</a>は、http://www.w3.org/TR/2000/REC-xml-20001006です。<a href="www.w3.org/TR/REC-xml">最新バージョン</a>は、http://www.w3.org/TR/REC-xmlです。</dd>

          <dt><a id="ref-xml-base" name="ref-xml-base">[XML-BASE]</a></dt>

          <dd>
<cite><a href="www.w3.org/TR/2001/REC-xmlbase-20010627/">XML          Base</a></cite>, Marsh J. (Editor), World Wide Web Consortium, 27 June 2001. <a href="www.w3.org/TR/2001/REC-xmlbase-20010627/">本バージョン</a>は、http://www.w3.org/TR/2001/REC-xmlbase-20010627/です。<a href="www.w3.org/TR/xmlbase/">最新バージョン</a>は、http://www.w3.org/TR/xmlbase/です。</dd>

          <dt><a id="ref-namespaces" name="ref-namespaces">[XML-NS]</a></dt>

          <dd>
<cite><a href="www.w3.org/TR/1999/REC-xml-names-19990114/">Namespaces
          in XML</a></cite>, Bray T., Hollander D., Layman A.
          (Editors), World Wide Web Consortium, 14 January 1999. <a href="www.w3.org/TR/1999/REC-xml-names-19990114/">本バージョン</a>は、http://www.w3.org/TR/1999/REC-xml-names-19990114/です。<a href="www.w3.org/TR/REC-xml-names/">最新バージョン</a>は、http://www.w3.org/TR/REC-xml-names/です。</dd>
          <dt><a id="ref-xml-xc14n" name="ref-xml-xc14n">[XML-XC14N]</a></dt>

          <dd>
<cite><a href="www.w3.org/TR/2002/REC-xml-exc-c14n-20020718/">Exclusive           XML Canonicalization Version 1.0</a></cite>, Boyer J., Eastlake D.E. 3rd, 
          Reagle J. (Authors/Editors), World Wide Web Consortium, 18 July 2002.  <a href="www.w3.org/TR/2002/REC-xml-exc-c14n-20020718/">本バージョン</a>は、http://www.w3.org/TR/2002/REC-xml-exc-c14n-20020718/です。<a href="www.w3.org/TR/xml-exc-c14n/">最新バージョン</a>は、http://www.w3.org/TR/xml-exc-c14n/です。</dd>

        </dl>
      </div>

      <div class="section">

        <h3><a name="informational-references" id="informational-references">8.2 参考情報の参考文献</a></h3>

        <dl>
          <dt><a id="ref-3gpp" name="ref-3gpp">[3GPP]</a></dt>

          <dd>
<cite><a href="www.3gpp.org/specs/specs.htm">3GPP
          TS 26.234.</a></cite> 3rd Generation Partnership Project;
          Technical Specification Group Services and System Aspects;
          Transparent end-to-end packet switched streaming service;
          Protocols and codecs V5.2.0 (2002-09). <a href="www.3gpp.org/specs/specs.htm">このドキュメント</a>は、ftp://ftp.3gpp.org/specs/2002-09/Rel-5/26_series/のディレクトリ経由でhttp://www.3gpp.org/specs/specs.htmで入手できます。</dd>

          <dt><a id="ref-address-schemes" name="ref-address-schemes">[ADDRESS-SCHEMES]</a></dt>

          <dd>
<cite><a href="www.w3.org/Addressing/schemes.html">Addressing
          Schemes</a></cite>, Connolly D., 2001. <a href="www.w3.org/Addressing/schemes.html">このドキュメント</a>は、http://www.w3.org/Addressing/schemes.htmlです。</dd>

          <dt><a id="ref-bates96" name="ref-bates96">[BATES96]</a></dt>
          <dd>
<cite><a href="is.gseis.ucla.edu/research/mjbates.html">Indexing
          and Access for Digital Libraries and the Internet: Human,
          Database, and Domain Factors</a></cite>, Bates M.J., 1996. <a href="is.gseis.ucla.edu/research/mjbates.html">このドキュメント</a> は、http://is.gseis.ucla.edu/research/mjbates.htmlです。</dd>

          <dt><a id="ref-berners-lee98" name="ref-berners-lee98">[BERNERS-LEE98]</a></dt>

          <dd>
<cite><a href="www.w3.org/DesignIssues/RDFnot.html">What the
          Semantic Web can represent</a></cite>, Berners-Lee T., 1998.
          <a href="www.w3.org/DesignIssues/RDFnot.html">このドキュメント</a>は、http://www.w3.org/DesignIssues/RDFnot.htmlです。</dd>

          <dt><a id="ref-ccpp" name="ref-ccpp">[CC/PP]</a></dt>

          <dd>
<cite><a href="www.w3.org/TR/2004/REC-CCPP-struct-vocab-20040115/">
          Composite Capability/Preference Profiles (CC/PP): Structure
          and Vocabularies</a></cite>, Klyne G., Reynolds F., Woodrow
          C., Ohto H., Hjelm J., Butler M., Tran, L., W3C Recommendation, 15 January 2004. <a href="www.w3.org/TR/2004/REC-CCPP-struct-vocab-20040115/">本バージョン</a>は、http://www.w3.org/TR/2004/REC-CCPP-struct-vocab-20040115/です。<a href="www.w3.org/TR/CCPP-struct-vocab/">最新バージョン</a>は、http://www.w3.org/TR/CCPP-struct-vocab/です。</dd>

          <dt><a id="ref-cg" name="ref-cg">[CG]</a></dt>

          <dd>
<cite>Conceptual Graphs</cite>, Sowa J., ISO working
          document ISO/JTC1/SC32/WG2 N 000, 2 April 2001 (作業中). <a href="users.bestweb.net/~sowa/cg/cgstand.htm">http://users.bestweb.net/~sowa/cg/cgstand.htm</a>にあります。</dd>

          <dt><a id="ref-charmod" name="ref-charmod">[CHARMOD]</a></dt>

          <dd>
<cite><a href="www.w3.org/TR/2002/WD-charmod-20020220/">Character 
          Model for the World Wide Web 1.0</a></cite>, D&uuml;rst M., Yergeau F., 
          Ishida R., Wolf M., Freytag A., Texin T. (Editors), World Wide Web Consortium, 
          20 February 2002 (作業中).  
          <a href="www.w3.org/TR/2002/WD-charmod-20020220/">本バージョン</a>は、http://www.w3.org/TR/2002/WD-charmod-20020220/です。<a href="www.w3.org/TR/charmod/">最新バージョン</a>は、http://www.w3.org/TR/charmod/です。</dd>

          <dt><a id="ref-cim" name="ref-cim">[CIM]</a></dt>

          <dd>
<cite>Common Information Model (CIM): CIM 10 Version</cite>, 
          EPRI, Palo Alto, CA: 2001, 1001976. <a href="www.epri.com/attachments/286161_1001976(1).pdf">本バージョン</a>は、http://www.epri.com/attachments/286161_1001976(1).pdf (267pp.)にあります。</dd>

          <dt><a id="ref-cowan" name="ref-cowan">[COWAN]</a></dt>

          <dd>
<cite><a href="seminars.seyboldreports.com/2002_new_york/files/presentations/014/cowan_john.ppt">
          Metadata, Reuters Health Information, and Cross-Media
          Publishing</a></cite> , Cowan J., 2002. Presentation at
          Seybold New York 2002 Enterprise Publishing Conference. <a href="seminars.seyboldreports.com/2002_new_york/files/presentations/014/cowan_john.ppt">このドキュメント</a>は、http://seminars.seyboldreports.com/seminars/2002_new_york/presentations/014/cowan_john.pptです。付随の<a href="seminars.seyboldreports.com/2002_new_york/files/transcripts/doc/transcript_EP7.doc">記録</a>は、http://seminars.seyboldreports.com/2002_new_york/files/transcripts/doc/transcript_EP7.docです。</dd>

          <dt><a id="ref-daf" name="ref-daf">[DAF]</a></dt>
          <dd>
<cite><a href="www.omg.org/technology/documents/formal/UMS_Data_Access_Facility.htm">Utility
          Management System (UMS) Data Access Facility</a></cite>, version 2.0,
          Object Management Group, November 2002. <a href="www.omg.org/technology/documents/formal/UMS_Data_Access_Facility.htm">このドキュメント</a>は、http://www.omg.org/technology/documents/formal/UMS_Data_Access_Facility.htmにあります。</dd>

          <dt><a id="ref-damloil" name="ref-damloil">[DAML+OIL]</a></dt>

          <dd>
<cite><a href="www.w3.org/TR/daml+oil-reference">DAML+OIL
          (March 2001) Reference Description</a></cite>, Connolly D.,
          van Harmelen F., Horrocks I., McGuinness D.L.,
          Patel-Schneider P.F., Stein L.A., World Wide Web Consortium,
          18 December 2001. <a href="www.w3.org/TR/daml+oil-reference">このドキュメント</a>は、http://www.w3.org/TR/daml+oil-referenceです。</dd>
          <dt><a id="ref-dublin-core" name="ref-dublin-core">[DC]</a></dt>

          <dd>
<cite><a href="dublincore.org/documents/2003/06/02/dces/">Dublin Core
          Metadata Element Set, Version 1.1: Reference
          Description</a></cite>, 02 June 2003. <a href="dublincore.org/documents/2003/06/02/dces/">本バージョン</a>は、http://dublincore.org/documents/2003/06/02/dces/です。<a href="dublincore.org/documents/dces/">最新バージョン</a>は、http://dublincore.org/documents/dces/です。</dd>
          <dt><a id="ref-diprinc" name="ref-diprinc">[DIPRINC]</a></dt>

          <dd>
<cite><a href="www.w3.org/TR/di-princ/">Device
          Independence Principles.</a></cite> Gimson, R., Finkelstein,
          S., Maes, S., Suryanarayana, L., World Wide Web Consortium,
          18 September 2001 (作業中). <a href="www.w3.org/TR/2001/WD-di-princ-20010918/">本バージョン</a>は、http://www.w3.org/TR/2001/WD-di-princ-20010918です。<a href="www.w3.org/TR/di-princ/">最新バージョン</a>は、http://www.w3.org/TR/di-princ/です。</dd>

          <dt><a id="ref-devos" name="ref-devos">[DWZ01]</a></dt>

          <dd>
<cite><a href="www.langdale.com.au/PICA/">XML for
          CIM Model Exchange</a></cite> , deVos A., Widergreen S.E.,
          Zhu J., Proc. IEEE Conference on Power Industry Computer
          Systems, Sydney, Australia, 2001. <a href="www.langdale.com.au/PICA/">このドキュメント</a>は、http://www.langdale.com.au/PICA/です。</dd>

          <dt><a id="ref-go" name="ref-go">[GO]</a></dt>
          <dd>
<cite><a href="www.geneontology.org/GO_nature_genetics_2000.pdf">Gene 
          Ontology: tool for the unification of biology</a></cite>,
           The Gene Ontology Consortium, <em>Nature Genetics</em>, Vol. 25: 25-29, May 2000.
         <a href="www.geneontology.org/GO_nature_genetics_2000.pdf">http://www.geneontology.org/GO_nature_genetics_2000.pdf</a>にあります。</dd>

          <dt><a id="ref-gray" name="ref-gray">[GRAY]</a></dt>

          <dd>
<cite>Logic, Algebra and Databases</cite>, Gray P., Ellis
          Horwood Ltd., 1984. ISBN 0-85312-709-3, 0-85312-803-0,
          0-470-20103-7, 0-470-20259-9.</dd>

          <dt><a id="ref-hayes" name="ref-hayes">[HAYES]</a></dt>

          <dd>
<cite>In Defense of Logic</cite>, Hayes P., Proceedings
          from the International Joint Conference on Artificial
          Intelligence, 1975, San Francisco. Morgan Kaufmann Inc.,
          1977. Also in <cite>Computation and Intelligence: Collected
          Readings</cite>, Luger G. (ed), AAAI press/MIT press, 1995.
          ISBN 0-262-62101-0.</dd>

          <dt><a id="ref-kif" name="ref-kif">[KIF]</a></dt>
          <dd>
<cite>Knowledge Interchange Format</cite>, Genesereth M.,
          draft proposed American National Standard NCITS.T2/98-004.          <a href="logic.stanford.edu/kif/dpans.html">http://logic.stanford.edu/kif/dpans.html</a>にあります。</dd>

          <dt>
<a id="ref-lbase" name="ref-lbase"></a>[LBASE]</dt>

          <dd>
<cite><a href="www.w3.org/TR/2003/NOTE-lbase-20031010/">LBase: 
          Semantics for Languages of the Semantic Web</a></cite>, Guha R. V., Hayes P., 
          W3C Note, 10 October 2003. <a href="www.w3.org/TR/2003/NOTE-lbase-20031010/">本バージョン</a>は、http://www.w3.org/TR/2003/NOTE-lbase-20031010/です。<a href="www.w3.org/TR/lbase/">最新バージョン</a>は、http://www.w3.org/TR/lbase/.</dd>

          <dt><a id="ref-luger" name="ref-luger">[LUGER]</a></dt>

          <dd>
<cite>Artificial Intelligence: Structures and Strategies
          for Complex Problem Solving</cite> (3rd ed.), Luger G.,
          Stubblefield W., Addison Wesley Longman, 1998. ISBN          0-805-31196-3.</dd>

          <dt><a id="ref-mathml" name="ref-mathml">[MATHML]</a></dt>

          <dd>
<cite><a href="www.w3.org/TR/2001/REC-MathML2-20010221/">Mathematical
          Markup Language (MathML) Version 2.0</a></cite>, Carlisle D., Ion P., 
          Miner R., Poppelier N. (Editors); Ausbrooks R., Buswell S., Dalmas S., 
          Devitt S., Diaz A., Hunter R., Smith B., Soiffer N., Sutor R., 
          Watt S. (Principal Authors), World Wide Web Consortium, 21 February 2001.  
          <a href="www.w3.org/TR/2001/REC-MathML2-20010221/">本バージョン</a>は、http://www.w3.org/TR/2001/REC-MathML2-20010221/です。<a href="www.w3.org/TR/MathML2/">最新バージョン</a>は、http://www.w3.org/TR/MathML2/です。</dd>

          <dt><a id="ref-mms" name="ref-mms">[MMS-CTR]</a></dt>

          <dd>
<cite><a href="www.openmobilealliance.org/">Multimedia
          Messaging Service Client Transactions
          Specification.</a></cite> WAP-206-MMSCTR-20020115-a. 
          このドキュメントは、http://www.openmobilealliance.org/にあります。</dd>

          <dt><a id="ref-nameaddress" name="ref-nameaddress">[NAMEADDRESS]</a></dt>
          <dd>
<cite><a href="www.w3.org/Addressing/">Naming and
          Addressing: URIs, URLs, ...</a></cite>, Connolly D., 2002. <a href="www.w3.org/Addressing/">このドキュメント</a>は、http://www.w3.org/Addressing/です。</dd>

          <dt><a id="ref-owl" name="ref-owl">[OWL]</a></dt>
          <dd>
<cite><a href="www.w3.org/TR/2004/REC-owl-ref-20040210/">OWL Web
          Ontology Language Reference</a></cite>, Dean M., 
          Schreiber G (Editors); van Harmelen F., Hendler J., Horrocks I., 
          McGuinness D.L., Patel-Schneider P.F., Stein L.A. (Authors), 
          W3C Recommendation, 10 February 2004. <a href="www.w3.org/TR/owl-ref/">最新バージョン</a>は、http://www.w3.org/TR/owl-ref/です。</dd>

          <dt><a id="ref-prism" name="ref-prism">[PRISM]</a></dt>

          <dd>
<cite><a href="www.prismstandard.org/">PRISM:
          Publishing Requirements for Industry Standard
          Metadata</a></cite>, Version 1.1, 19 February 2002. PRISM仕様の<a href="www.prismstandard.org/">最新バージョン</a>は、http://www.prismstandard.org/にあります。</dd>

          <dt><a id="ref-rdf-issue" name="ref-rdf-issue">[RDFISSUE]</a></dt>

          <dd>
<cite><a href="www.w3.org/2000/03/rdf-tracking/">RDF Issue
          Tracking</a></cite>, McBride B., 2002. <a href="www.w3.org/2000/03/rdf-tracking/">このドキュメント</a>は、http://www.w3.org/2000/03/rdf-tracking/です。</dd>

          <dt><a id="ref-rdf-s" name="ref-rdf-s">[RDF-S]</a></dt>

          <dd>
<cite><a href="www.w3.org/TR/2000/CR-rdf-schema-20000327/">
          Resource Description Framework (RDF) Schema Specification 1.0</a>
          </cite>, Brickley D., Guha, R.V. (Editors), World Wide Web Consortium. 
          27 March 2000. <a href="www.w3.org/TR/2000/CR-rdf-schema-20000327/">
          本バージョン</a>は、http://www.w3.org/TR/2000/CR-rdf-schema-20000327/です。</dd>

          <dt><a id="ref-rss" name="ref-rss">[RSS]</a></dt>

          <dd>
<cite><a href="purl.org/rss/1.0/spec">RDF Site
          Summary (RSS) 1.0</a></cite>, Beged-Dov G., Brickley D.,
          Dornfest R., Davis I., Dodds L., Eisenzopf J., Galbraith D.,          Guha R.V., MacLeod K., Miller E., Swartz A., van der Vlist
          E., 2000. <a href="purl.org/rss/1.0/spec">このドキュメント</a>は、http://purl.org/rss/1.0/specです。</dd>

          <dt><a id="ref-ruby" name="ref-ruby">[RUBY]</a></dt>

          <dd>
<cite><a href="www.w3.org/TR/2001/REC-ruby-20010531/">Ruby 
          Annotation</a></cite>, Sawicki M., Suignard M., Ishikawa M., D&uuml;rst M., 
          Texin T. (Editors), World Wide Web Consortium, 31 May 2001.  
          <a href="www.w3.org/TR/2001/REC-ruby-20010531/">本バージョン</a>は、http://www.w3.org/TR/2001/REC-ruby-20010531/です。<a href="www.w3.org/TR/ruby/">最新バージョン</a>は、http://www.w3.org/TR/ruby/です。</dd>

          <dt><a id="ref-sowa" name="ref-sowa">[SOWA]</a></dt>

          <dd>
<cite>Knowledge Representation: Logical, Philosophical
          and Computational Foundations</cite>, Sowa J., Brookes/Cole,
          2000. ISBN 0-534-94965-7.</dd>

          <dt><a id="ref-svg" name="ref-svg">[SVG]</a></dt>
          <dd>
<cite><a href="www.w3.org/TR/2003/REC-SVG11-20030114/">Scalable
          Vector Graphics (SVG) 1.1 Specification</a></cite>, Ferraiolo J.,
          Fujisawa J., Jackson D. (Editors), World Wide Web Consortium, 14
          January 2003. <a href="www.w3.org/TR/2003/REC-SVG11-20030114/">本バージョン</a>は、http://www.w3.org/TR/2003/REC-SVG11-20030114/.
          The <a href="www.w3.org/TR/SVG11/">latest version</a>
          is http://www.w3.org/TR/SVG11/.</dd>

          <dt><a id="ref-uaprof" name="ref-uaprof">[UAPROF]</a></dt>

          <dd>
<cite><a href="www.openmobilealliance.org/">User
          Agent Profile.</a></cite> OMA-WAP-UAProf-v1_1. このドキュメントは、http://www.openmobilealliance.org/にあります。</dd>

          <dt><a id="ref-webdata" name="ref-webdata">[WEBDATA]</a></dt>

          <dd>
<cite><a href="www.w3.org/1999/04/WebData">Web
          Architecture: Describing and Exchanging Data</a></cite>,
          Berners-Lee T., Connolly D., Swick R., World Wide Web Consortium, 7 June 1999. <a href="www.w3.org/1999/04/WebData">このドキュメント</a>は、http://www.w3.org/1999/04/WebDataです。</dd>

          <dt><a id="ref-xlink" name="ref-xlink">[XLINK]</a></dt>

          <dd>
<cite><a href="www.w3.org/TR/2001/REC-xlink-20010627/">XML
          Linking Language (XLink) Version 1.0</a></cite>, DeRose S.,
          Maler E., Orchard D. (Editors), World Wide Web Consortium, 27
          June 2001. <a href="www.w3.org/TR/2001/REC-xlink-20010627/">本バージョン</a>は、http://www.w3.org/TR/2001/REC-xlink-20010627/です。<a href="www.w3.org/TR/xlink/">最新バージョン</a>は、http://www.w3.org/TR/xlink/です。</dd>

          <dt><a id="ref-xmlschema2" name="ref-xmlschema2">[XML-SCHEMA2]</a></dt>

          <dd>
<cite><a href="www.w3.org/TR/2001/REC-xmlschema-2-20010502/">XML
          Schema Part 2: Datatypes</a></cite>, Biron P., Malhotra A.
          (Editors), World Wide Web Consortium. 2 May 2001. <a href="www.w3.org/TR/2001/REC-xmlschema-2-20010502/">本バージョン</a>は、http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/です。<a href="www.w3.org/TR/xmlschema-2/">最新バージョン</a>は、http://www.w3.org/TR/xmlschema-2/です。</dd>

          <dt><a id="ref-xpackage" name="ref-xpackage">[XPACKAGE]</a></dt>

          <dd>
<cite><a href="www.xpackage.org/specification/xpackage-draft-20030306.html">
          XML Package (XPackage) 1.0</a></cite> , Wilson G., Editor's Working Draft,           6 March 2003. <a href="www.xpackage.org/specification/xpackage-draft-20030306.html">
          本バージョン</a>は、http://www.xpackage.org/specification/xpackage-draft-20030306.htmlです。<a href="www.xpackage.org/specification/">最新バージョン</a>は、http://www.xpackage.org/specification/です。</dd>
        </dl>
      </div>
    </div>

    <div class="section">
      <h2><a id="acknowledgements" name="acknowledgements">9. 謝辞</a></h2>

      <p>このドキュメントは、<a href="www.w3.org/2001/sw/RDFCore/">RDFコア・ワーキンググループ</a>の多くのメンバーからの情報提供の恩恵を受けています。特に、Art Barstow、Dave Beckett、Dan Brickley、Ron Daniel、Ben Hammersley、Martyn Horner、Graham Klyne、Sean Palmer、Patrick Stickler、Aaron Swartz、Ralph Swick、Garret Wilsonに感謝いたします。彼らは、入門書の以前のバージョンへコメントを寄せてくださった多くの人々と共に、このドキュメントに有益な貢献をしてくださいました。</p>

      <p>さらに、このドキュメントには、RDF系の仕様で述べているRDFデータ型機能の開発を先導したPat Hayes、Sergey Melnik、Patrick Sticklerによる大きな貢献もありました。</p>

      <p>Frank Manolaは、このドキュメントの準備のほとんどの期間中に彼が勤めていた<a href="www.mitre.org/">MITRE社</a>にも、MITRE主催の研究交付金を受けたRDFコア・ワーキンググループの活動への支援に対し感謝いたします。</p>
    </div>
    <hr>

    <div class="section">

      <h2>
<a id="identifiers" name="identifiers"></a>付録A: URI（Uniform Resource Identifiers）に関する詳細</h2>

      <p class="newstuff">注意: この項ではURIについて簡潔に紹介します。URIの最終的な仕様は<a href="www.isi.edu/in-notes/rfc2396.txt">RFC 2396</a> <a href="#ref-uri">[URIS]</a>であり、詳細に関してはこれを参考するべきです。また、URIに関するさらなる議論は、<a href="www.w3.org/Addressing/">Naming and Addressing: URIs, URLs, ...</a> <a href="#ref-nameaddress">[NAMEADDRESS]</a>に掲載されています。</p>

      <p><a href="#basicconcepts">2.1項</a>で論じたように、ウェブでは、ウェブに関する資源を識別する（命名する）ために、<a href="www.isi.edu/in-notes/rfc2396.txt">Uniform Resource Identifier</a>（URI）と呼ばれる一般的な形式の識別子を提供しています。URLとは異なり、URIは、ネットワーク上にロケーションを持つ事物や、他のコンピュータ・アクセス機構を使用する事物の識別に制限されていません。数多くの多様な<em>URIスキーム</em>（URI形式）が様々な目的で既に開発され、使用されています。例えば以下のようなものが含まれます。</p>

      <ul>
        <li>
<code>http:</code>（ハイパーテキスト転送プロトコル、ウェブ・ページ用）</li>

        <li>
<code>mailto:</code>（電子メール・アドレス）例えば、<code>mailto:em@w3.org</code>
</li>

        <li>
<code>ftp:</code>（ファイル転送プロトコル）</li>

        <li>
<code>urn:</code>（URN、永続的でロケーションに依存しない資源識別子用）例えば、<code>urn:isbn:0-520-02356-0</code>（書籍用）</li>
      </ul>

      <p>既存のURIスキームのリストは、<a href="www.w3.org/Addressing/schemes.html">アドレシング・スキーム</a>（Addressing Schemes）<a href="#ref-address-schemes">[ADDRESS-SCHEMES]</a>にあります。新しいものを作り出そうとするのではなく、既存のスキームの1つを特定の識別の目的に適合させることを検討する方が良いでしょう。</p>

      <p>個人や団体は、誰がURIを作り、どのように使用されるかを制御できません。URIスキームには、URLの<code>http:</code>のようにDNSなどの集中型システムに依存しているものもあれば、<code>freenet:</code>のような完全に分散型のスキームもあります。これは、他のあらゆる種類の名前と同じで、URIの作成には特別な権限や許可は必要ないということを意味します。また、自分が持っていない事物に対して日常の言語で好きな名前を使うことができるのと全く同じ様に、誰もが自分が持っていない事物を参照するためにURIを作成できます。</p>

      <p><a href="#basicconcepts">2.1項</a>でも指摘したように、RDFでは、<em>URI参照</em> <a href="#ref-uri">[URIS]</a>を使用してRDFステートメントで主語、述語、目的語を命名します。URI参照（または、<em>URIref</em>）はURIです（末尾に<em>フラグメント識別子</em>を伴うことがあります）。例えば、URI参照<code>http://www.example.org/index.html#section2</code>は、URI <code>http://www.example.org/index.html</code>と（「#」という文字で区切られた）フラグメント識別子<code>Section2</code>で構成されています。RDF URIrefには、ユニコード<a href="#ref-unicode">[UNICODE]</a>の文字を含むことができ（<a href="#ref-rdf-concepts">[RDF-CONCEPTS]</a>を参照）、これによって多くの言語をURIrefに反映できます。</p>

      <p>URIrefは、絶対あるいは相対のどちらかでありえます。<em>絶対</em>URIrefは、URIrefが出現するコンテキスト、例えば<code>http://www.example.org/index.html</code>とは無関係に資源を示します。<em>相対</em>URIrefは絶対URIrefの省略形であり、URIrefの一部の接頭辞が欠けており、この欠けた情報を埋めるためにURIrefが出現するコンテキストからの情報が必要です。例えば、相対URIref <code>otherpage.html</code>が資源<code>http://www.example.org/index.html</code>で出現する時には、絶対URIref <code>http://www.example.org/otherpage.html</code>と書き込まれるでしょう。URI部分がないURIrefは、現在のドキュメント（そのURIrefが現れるドキュメント）への参照であると見なされます。そのため、ドキュメント内の空のURIrefは、ドキュメント自体のURIrefと同じだと見なされます。フラグメント識別子のみで構成されるURIrefは、このURIrefが現れるドキュメントのURIrefにフラグメント識別子を追加したものと同じだと見なされます。例えば、<code>http://www.example.org/index.html</code>内で、<code>#section2</code>がURIrefとして出現する場合、これは絶対URIref <code>http://www.example.org/index.html#section2</code>と同じだと見なされます。</p>

      <p><a href="#ref-rdf-concepts">[RDF-CONCEPTS]</a>では、RDFグラフ（抽象モデル）が相対URIrefを使用しないということを指摘しています。すなわち、RDFステートメントの主語、述語、目的語（そして、型付きリテラルのデータ型）は、常にコンテキストとは無関係に識別されなければなりません。しかし、RDF/XMLなどの特定の具象RDF構文では、ある状況においては、相対URIrefを絶対URIrefの省略形として使用できます。RDF/XMLでは、実際にそのような相対URIrefの使用が可能で、この入門書のRDF/XMLの例の一部でそのような使用法を示しています。詳細については、<a href="#ref-rdf-syntax">[RDF-SYNTAX]</a>を参照してください。</p>
      <p>RDFとウェブ・ブラウザの両方が、URIrefを使用して事物を識別します。しかし、RDFとブラウザは、少し違った方法でURIrefを解釈します。これは、RDFは事物を識別するために<em>だけ</em>URIrefを使用するけれども、ブラウザは事物を<em>検索</em>するためにもURIrefを使用するからです。大抵は実質的な違いはありませんが、違いが重要な場合もあります。1つの明白な違いは、ブラウザでURIrefを使用した場合には、実際に検索できる資源を識別すると予期される、すなわち、何かが実際にこのURIで識別されるロケーション「に」あると予期されます。しかし、RDFでは、URIrefは人などのウェブで検索できないものを識別するためにも使用できます。RDF資源を識別するためにURIrefを使用する場合、その資源に関する記述情報を含むページはウェブ上のそのURI「に」置かれるという慣習に従ってRDFを使用することがあります。そのため、URIrefをブラウザで使用してその情報を検索できます。オリジナル資源とそれを記述したウェブ・ページの区別が困難になりますが、状況によっては、この慣習は有益になりえます（<a href="#structuredproperties">2.3項</a>で詳細に論じた問題です）。しかし、この慣習はRDFの定義に明示されている事項ではなく、RDF自体はURIrefが検索できるものを識別することを想定していません。</p>

      <p>もう1つの違いは、フラグメント識別子を持つURIrefを扱う方法にあります。フラグメント識別子は、HTMLドキュメントを識別するURLでよく見られ、URLで識別されているドキュメント内の特定の場所を識別する働きをします。指示された資源を検索するためにURI参照を使用するという、通常のHTMLの使用法では、以下の2つのURIref</p>

      <p><code>http://www.example.org/index.html</code><br>
       <code>http://www.example.org/index.html#Section2</code></p>

      <p>には、関連があります（これらは2つとも同じドキュメントを参照し、2番目のURIrefは1番目のURIref内のロケーションを識別しています）。しかし、既に指摘したように、RDFは資源を検索するのではなく、純粋に資源を識別するためにURI参照を使用し、RDFではこの2つのURIref間の特定の関係を想定しません。これらのURI参照は構文的に異なっているため、RDFに関する限り、関連がない事物を参照することがありえます。これは、HTMLで定義されている包含関係が存在しないということを意味しているのではなく、RDFではURI参照のURI部分が同じであるという事実だけに基づいて、関係が存在するとは想定しないということだけを意味しています。</p>

<div class="newstuff">
      <p>この点をさらに説明すると、RDFでは、フラグメント識別子があるか否かに関係なく、共通の先行文字列を共有するURI参照の間に関係があるとは想定しません。例えば、RDFに関する限り、以下の2つのURIref</p>

      <p><code>http://www.example.org/foo.html</code><br>
       <code>http://www.example.org/bar.html</code></p>

      <p>は、両方とも、文字列<code>http://www.example.org/</code>で始まりますが、特定の関係はありません。これらのURIrefは異なっているため、RDFでは、これらは単に異なる資源です。（これらは、実際に同じディレクトリに位置する2個のファイルであるかもしれませんが、RDFは、このような関係、または、いかなるその他の関係も存在すると想定しません。）</p>
</div>
    </div>

    <div class="section">

      <h2>
<a id="documents" name="documents"></a>付録B: XML（Extensible Markup Language）に関する詳細</h2>

      <p class="newstuff">注意: この項は、XMLについて簡単に紹介することを目的としています。XMLの最終的な仕様は<a href="#ref-xml">[XML]</a>で、詳細についてはこれを参照してください。</p>

      <p>XML（<a href="www.w3.org/TR/2000/REC-xml-20001006">Extensible Markup Language</a>） <a href="#ref-xml">[XML]</a>は、誰もが自身のドキュメント形式を設計し、その形式でドキュメントを書くことができるよｙに設計されました。HTMLドキュメント（ウェブ・ページ）と同様に、XMLドキュメントにはテキストが含まれます。このテキストは、主にプレーン・テキストのコンテンツと<em>タグ</em>形式のマークアップで構成されています。このマークアップによって、処理プログラムが様々なコンテンツ（要素という）を解釈できるようになります。XMLコンテンツと（例外がある）タグの両方にユニコード<a href="#ref-unicode">[UNICODE]</a>の文字を含むことができ、これによって多くの言語による情報を直接表現できるようになります。HTMLでは、許されている一連のタグとその解釈は、HTMLの仕様で定義されています。しかし、XMLでは、ユーザが自身の特定の要求に合わせた独自のマークアップ言語（表示できるタグと構造）を定義できます（<a href="#rdfxml">3項</a>で述べたRDF/XML言語は、このようなXMLマークアップ言語の1つです)。例えば、以下はXMLベースのマークアップ言語を使用してマークアップした簡単な一節です。</p>

      <div class="exampleOuter exampleInner">
<pre>
&lt;sentence&gt;&lt;person webid="http://example.com/#johnsmith"&gt;I&lt;/person&gt; 
just got a new pet &lt;animal&gt;dog&lt;/animal&gt;.&lt;/sentence&gt;
</pre>
      </div>

      <p>タグ（<code>&lt;sentence&gt;</code>、<code>&lt;person&gt;</code>など）で区切られた要素は、この一節に関連する特定の構造を反映するために導入されています。この特定の要素やその構造化方法を理解して書かれたプログラムは、タグによって、この一節を適切に解釈できるようになります。例えば、この例にある要素の1つは<code>&lt;animal&gt;dog&lt;/animal&gt;</code>です。これは<em>開始タグ</em>の<code>&lt;animal&gt;</code>、要素<em>コンテンツ</em>、対応する<em>終了タグ</em>の<code>&lt;/animal&gt;</code>で構成されています。この<code>animal</code>要素は、<code>person</code>要素と一緒に、<code>sentence</code>要素のコンテンツの一部として入れ子にされています。以下のような文章が書かれていれば、入れ子はより明確である（また、この入門書の残りの部分に含まれる、さらに「構造化」されたXMLの一部により近い）と思われます。</p>

      <div class="exampleOuter exampleInner">
<pre>
&lt;sentence&gt;
    &lt;person webid="http://example.com/#johnsmith"&gt;I&lt;/person&gt; 
    just got a new pet 
    &lt;animal&gt;dog&lt;/animal&gt;.
&lt;/sentence&gt;
</pre>
      </div>

      <p>要素にコンテンツがない場合もあります。これは、<code>&lt;animal&gt;&lt;/animal&gt;</code>のように、1組の開始タグと終了タグ内にコンテンツを囲み込まないで書くか、<code>&lt;animal/&gt;</code>のように、<em>空要素タグ</em>というタグの省略形を使用して書くことができます。</p>

      <p>開始タグ（または、空の要素タグ）には、タグ名以外に修飾情報を<em>属性</em>の形式で含む場合もあります。例えば、<code>&lt;person&gt;</code>要素の開始タグは、属性<code>webid="http://example.com/#johnsmith"</code>（恐らく、参照される特定人物を識別する）を含んでいます。属性は、名前、等号、値（引用符で囲み込まれた）で構成されています。</p>

      <p>この特定のマークアップ言語は、要素の意味の一部を伝えるために「sentence」「person」「animal」という単語をタグ名として使用し、それを読んでいる英語を話す人々や、この語彙を解釈するように特別に書かれたプログラムに意味を伝える<em>でしょう</em>。しかし、ここには組み込み済みの意味はありません。例えば、英語を話さない人々や、このマークアップを理解するように書かれていないプログラムには、要素（<code>&lt;person&gt;</code>）は全く何も意味しないかもしれません。例えば、以下の一節の例をごらんください。</p>

      <div class="exampleOuter exampleInner">
<pre>
&lt;dfgre&gt;&lt;reghh bjhbw="http://example.com/#johnsmith"&gt;I&lt;/reghh&gt; 
just got a new pet &lt;yudis&gt;dog&lt;/yudis&gt;.&lt;/dfgre&gt;
</pre>
      </div>

      <p>機械にとっては、この一節は、前の例と全く同じ構造を持っています。しかし、タグが英単語でなくなっているため、英語を話す人々には、何が述べられているかはもはや明確ではありません。さらに、別々の人々が、完全に異なる意図を持った意味で同じ単語を自分達のマークアップ言語にタグとして使用しているかもしれません。例えば、他のマークアップ言語の「sentence」は、犯罪者が刑務所に服役しなければならない期間を意味するかもしれません（訳注：「sentence」には、「文」以外に「刑期」という意味もある）。そのため、XML語彙の正確性を保つための仕組みを追加提供しなければなりません。</p>

      <p>混乱を避けるため、マークアップ要素を一意に識別する必要があります。これは、<a href="www.w3.org/TR/REC-xml-names/">XML名前空間XML-NS</a> <a href="#ref-namespaces">[XML-NS]</a>をXMLで使用すれば行うことができます。<em>名前空間</em>は、単に、特定の名前の集合に対する限定子として機能する、ウェブ（空間）の一部を識別する方法です。名前空間は、その名前空間に対するURIを作成することにより、XMLマークアップ言語用に作成されます。この名前空間のURIでタグ名を修飾することにより、誰でもが独自のタグを作成し、他の人が作成した同じスペルのタグと適切に区別できます。慣習として、ウェブページを作成してマークアップ言語（および、タグが意図する意味）を記述し、そのウェブ・ページのURLをその名前空間のURIとして使用することもあります。しかし、これは慣習にすぎず、XMLとRDFのどちらも、名前空間URIが検索可能なウェブ資源を識別するとは想定しません。以下の例では、XML名前空間の使用法を示しています。</p>

      <div class="exampleOuter exampleInner">
<pre>
&lt;user:sentence xmlns:user="http://example.com/xml/documents/"&gt;
   &lt;user:person user:webid="http://example.com/#johnsmith"&gt;I&lt;/user:person&gt; 
just got a new pet &lt;user:animal&gt;dog&lt;/user:animal&gt;.
&lt;/user:sentence&gt;
</pre>
      </div>

      <p>この例では、属性<code>xmlns:user="http://example.com/xml/documents/"</code>は、XMLのこの部分で使用するための名前空間を宣言しています。これは、<em>接頭辞</em><code>user</code>を名前空間URI <code>http://example.com/xml/documents/</code>にマッピングします。次に、XMLコンテンツは、<em>修飾名</em>（または、QName）をタグとして使用できます。QNameには、名前空間を識別する接頭辞、その後にコロン、次にXMLタグや属性名のローカル名が含まれています。この例のように、名前空間URIを使用して名前の特定のグループを区別し、由来する名前空間のURIでタグを修飾することにより、タグ名が衝突する心配がなくなります。同じスペルの2つのタグは、それらが同じ名前空間URIを持つ場合にのみ、同じと見なされます。</p>

      <p>全てのXMLドキュメントは<dfn>整形式</dfn>（well-formed）である必要があります。これは、XMLドキュメントは、例えば、全ての開始タグには対応する終了タグがなければならず、要素は他の要素内に適切に入れ子にされなければならない（要素は重複してはならない）などの、多くの構文上の条件を満たさなければならないということを意味します。<a href="#ref-xml">[XML]</a>では、整形式性（well-formedness）の一揃いの条件が定義されています。</p> 

      <p>さらに、XMLドキュメントでは、XML<dfn>文書型宣言</dfn>（document type declaration）をオプションで含んで、ドキュメントの構造に制約を追加定義し、ドキュメント内で定義済みの単位のテキストを使用できます。文書型宣言（<code>DOCTYPE</code>で始まる）は、ドキュメントの文法を定義する宣言を含んだり指し示したりします。この文法は、<dfn>文書型定義</dfn>（document type definition）、または<dfn>DTD</dfn>として知られています。DTDにおける宣言では、DTDに対応してどのXML要素と属性がXMLドキュメントに出現できるか、これらの要素と属性の関係（例えば、どの要素を他のどの要素内で入れ子にできるか、または、どの属性がどの要素と共に出現できるか）、要素や属性が必須なのかオプションなのか、などの事項を指定します。文書型宣言は、ドキュメントの外部に位置する1組の宣言を指し示すことができたり（<dfn>外部サブセット</dfn>（external subset）と呼ばれ、これを使用して共通の宣言を複数のドキュメントで共有できる）、宣言をドキュメントに直接含むことができたり（<dfn>内部サブセット</dfn>（internal subset）と呼ばれる）、内部および外部の両方のDTDサブセットを持つことができます。ドキュメントの完全なDTDは、両方のサブセットを併せて構成されます。文書型宣言を持つXMLドキュメントの簡単な例を、以下の<a href="#example47">例47</a>で示しています。</p> 

      <div class="exampleOuter">
        <div class="c1">
          <a id="example47" name="example47">例47: 文書型宣言を持つXMLドキュメント</a>
        </div>

        <div class="exampleInner">
<pre>
&lt;?xml version="1.0"?&gt; 
&lt;!DOCTYPE greeting SYSTEM "http://www.example.org/dtds/hello.dtd"&gt; 
&lt;greeting&gt;Hello, world!&lt;/greeting&gt; 
</pre>
        </div>
      </div>

      <p>この場合、ドキュメントには外部DTDサブセットしかなく、<dfn>システム識別子</dfn>（system identifier）<code>http://www.example.org/dtds/hello.dtd</code>がこのドキュメントの位置（URIref）を規定します。</p>

      <p>XMLドキュメントは、関連する文書型宣言を持っていて、そのドキュメントが文書型宣言で定義されている制約に従っている場合、<dfn>正当</dfn>（valid）です。</p>

<div class="newstuff">

      <p>RDF/XMLドキュメントでは、整形式のXMLであることのみを要し、XML DTD（または、XMLスキーマ）に対する妥当性の検証を目的としておらず、<a href="#ref-rdf-syntax">[RDF-SYNTAX]</a>では、任意のRDF/XMLの妥当性を検証するために使用できる規範的なDTDを指定しません（<a href="#ref-rdf-syntax">[RDF-SYNTAX]</a>の付録では、RDF/XMLに対する規範的でないスキーマの例を提供しています）。その結果、XML DTD文法に関するより詳細な議論は、この入門書の範囲を超えています。XML DTDやXML妥当性検証に関する詳細は、<a href="#ref-xml">[XML]</a>やXMLに関する多くの本に掲載されています。</p>

      <p>しかし、RDF/XMLに関連<em>する</em>XML文書型宣言の使用法が1つあり、それは、XML<em>エンティティー</em>を定義する際の使用法です。XMLエンティティー宣言は、本質的に名前を文字列に関連づけます。エンティティー名がXMLドキュメント内の他のどこかで使用される場合、XMLプロセッサーはエンティティー名を対応する文字列に置き換えます。これによって、URIrefsなどの長い文字列を省略でき、このような文字列を含むXMLドキュメントがより読みやすくなります。文書型宣言を使用して単にXMLエンティティーを宣言することが可能で、（RDF/XMLと同様に）ドキュメントの妥当性の検証を目的としていない場合でも有用でありえます。</p>
   
      <p>RDF/XMLドキュメントでは、実体は一般的にドキュメント自身の中で、つまり内部のDTDサブセットのみを使用して宣言されます（この理由の1つは、RDF/XMLは妥当性を検証するように作られておらず、妥当性の検証を行わないXMLプロセッサは外部のDTDサブセットを処理する必要がないということです）。例えば、<a href="#example48">例48</a>で示した、RDF/XMLドキュメントの冒頭の文書型宣言を提供することで、<code>rdf</code>、<code>rdfs</code>、<code>xsd</code>の名前空間に対するそのドキュメントのURIrefを、例で示しているように、それぞれ<code>&amp;rdf;</code>、<code>&amp;rdfs;</code>、<code>&amp;xsd;</code>に省略化することができます。</p>

      <div class="exampleOuter">
        <div class="c1">
          <a id="example48" name="example48">例48: XMLエンティティー宣言のいくつか</a>
        </div>

        <div class="exampleInner">
<pre>
&lt;?xml version='1.0'?&gt; 

&lt;!DOCTYPE rdf:RDF [ 
    &lt;!ENTITY rdf "http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt; 
    &lt;!ENTITY rdfs "http://www.w3.org/2000/01/rdf-schema#"&gt; 
    &lt;!ENTITY xsd "http://www.w3.org/2001/XMLSchema#"&gt; 
]&gt; 
&lt;rdf:RDF 
    xmlns:rdf = "&amp;rdf;" 
    xmlns:rdfs = "&amp;rdfs;" 
    xmlns:xsd = "&amp;xsd;">

...RDF statements...
 
&lt;/rdf:RDF&gt;</pre>
        </div>
      </div>

      </div>

    </div>


    <div class="section">
      <h2>
<a id="changes" name="changes"></a>付録C: 変更</h2>

      <p><a href="www.w3.org/TR/2003/PR-rdf-primer-20031215/">勧告案バージョン</a>以降は、マイナーな編集上および活字上の変更だけが行われました。以前の変更の詳細は<a href="www.w3.org/TR/2003/PR-rdf-primer-20031215/#changes">変更ログ</a>をご覧ください。</p>

   </div>

    <hr>

    <div class="metadata">
      <p><a href="www.asahi-net.or.jp/~ax2s-kmtn/internet/rdf/metadata.rdf"><img border="0" src="www.w3.org/RDF/icons/rdf_metadata_button.40" alt="RDF/XML Metadata"></a></p>
    </div>
  </body>
</html>