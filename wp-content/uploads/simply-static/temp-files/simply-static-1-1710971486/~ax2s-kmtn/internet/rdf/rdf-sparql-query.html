<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja">

<head>
<meta name="generator" content="Microsoft FrontPage 6.0">
<meta name="generator" content="Emacs 22">
<meta name="RCS-Id" content="$Id: Overview.html,v 1.14 2008/01/16 15:38:27 eric Exp $">
<title>RDF用クエリ言語SPARQL</title>
<style type="text/css">
/*<![CDATA[*/
pre.data	{ border: thin solid #88AA88;
                  background-color: #E8F0E8;
                  margin: 1em 4em 1em 0em ; }
                  
.wgNote	{ border: thin solid #88AA88;
          background-color: #E8F0E8;
          padding: 0.5em ;
          margin: 1em 4em 1em 2em ; }

/*]]>*/
</style>
<link rel="stylesheet" type="text/css" href="www.w3.org/TR/2008/REC-rdf-sparql-query-20080115/local.css">
<link rel="stylesheet" type="text/css" href="www.w3.org/StyleSheets/TR/W3C-REC">
</head>
<body>

<p><a href="www.asahi-net.or.jp/~ax2s-kmtn/index.html"><img src="www.asahi-net.or.jp/~ax2s-kmtn/images/logo.gif" alt="CyberLibrarian" width="105" height="19"></a></p>

<p>【注意】 このドキュメントは、W3Cの<a href="www.w3.org/TR/2008/REC-rdf-sparql-query-20080115/">SPARQL Query Language for RDF W3C Recommendation 15 January 2008</a>の和訳です。<br>
このドキュメントの正式版はW3Cのサイト上にある英語版であり、このドキュメントには翻訳に起因する誤りがありえます。誤訳、誤植などのご指摘は、<a href="www.asahi-net.or.jp/~ax2s-kmtn/mail.html">訳者</a>までお願い致します。</p>

<p>First Update: 2013年7月21日</p>

<hr>

<div class="head">
  <p><a href="www.w3.org/">
  <img src="www.w3.org/Icons/w3c_home" alt="W3C" height="48" width="72"></a></p>

  <h1 id="main">RDF用クエリ言語SPARQL</h1>
  <h2><a name="w3c-doctype" id="w3c-doctype">W3C勧告 2008年1月15日</a></h2>
  <dl>
	<dt>本バージョン:</dt>
	<dd><a href="www.w3.org/TR/2008/REC-rdf-sparql-query-20080115/">http://www.w3.org/TR/2008/REC-rdf-sparql-query-20080115/</a></dd>
	<dt>最新バージョン:</dt>
	<dd><a href="www.w3.org/TR/rdf-sparql-query/">http://www.w3.org/TR/rdf-sparql-query/</a></dd>
	<dt>旧バージョン:</dt>
	<dd><a href="www.w3.org/TR/2007/PR-rdf-sparql-query-20071112/">http://www.w3.org/TR/2007/PR-rdf-sparql-query-20071112/</a></dd>
    <dt>編集者:</dt>
    <dd>Eric Prud&#39;hommeaux, W3C &lt;<a href="mailto:eric@w3.org">eric@w3.org</a>&gt;<br>
    Andy Seaborne, Hewlett-Packard Laboratories, Bristol &lt;<a href="mailto:andy.seaborne@hp.com">andy.seaborne@hp.com</a>&gt;</dd>
  </dl>
<p>このドキュメントに対する<a href="www.w3.org/2001/sw/DataAccess/query-errata"><strong>正誤表</strong></a>を参照してください。いくつかの規範的な修正が含まれているかもしれません。</p>

<p><a href="www.w3.org/2003/03/Translations/byTechnology?technology=sparql-query"><strong>翻訳版</strong></a>も参照してください。</p>

<p class="copyright"><a href="www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> &#169; 2006-2007 <a href="www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>&#174;</sup> (<a href="www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>, <a href="www.ercim.org/"><acronym title="European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>, <a href="www.keio.ac.jp/">Keio</a>), All Rights Reserved. W3C <a href="www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p>
</div>

<hr title="Separator for header">
<div>
  <h2 class="notoc"><a id="abstract" name="abstract">要約</a></h2>

  <p>RDFは、ウェブ上で情報を表すための、有向性の、ラベル付けされたグラフ・データ形式です。この仕様では、RDFに対するSPARQLクエリ言語の構文とセマンティクスを定義しています。SPARQLは、データがRDFそのものとして保存されているか、ミドルウェアを通してRDFとして見えるのかにかかわらず、さまざまなデータ情報源にまたがるクエリを表すために使用できます。SPARQLには、必須および任意のグラフ・パターンをその論理積と論理和とともに問い合わせる性能が含まれています。SPARQLは、ソースRDFグラフによる拡張可能な値テストやクエリの制約もサポートします。SPARQLクエリの結果は、結果集合またはRDFグラフでありえます。</p>

</div>
<div>

<h2 id="status">このドキュメントのステータス</h2>

<p><em>この項は、このドキュメントの公開時のステータスについて記述しています。他のドキュメントがこのドキュメントに取って代わることがありえます。現行のW3Cの刊行物およびこの技術報告の最新の改訂版のリストは、http://www.w3.org/TR/の<a href="www.w3.org/TR/">W3C技術報告インデックス</a>にあります。</em></p>

<p>これは、<a href="www.w3.org/2005/10/Process-20051014/tr.html#RecsW3C">W3C勧告</a>です。</p>

<p>このドキュメントは、W3Cメンバー、ソフトウェア開発者、他のW3Cグループ、および他の利害関係者によりレビューされ、W3C勧告として管理者の協賛を得ました。これは確定済みドキュメントであり、参考資料として用いたり、別のドキュメントで引用することができます。勧告の作成におけるW3Cの役割は、仕様に注意を引き付け、広範囲な開発を促進することです。これによってウェブの機能性および相互運用性が増強されます。</p>

<p>このドキュメントに関するコメントは、<a href="lists.w3.org/Archives/Public/public-rdf-dawg-comments">公開アーカイブ</a>付きのメーリングリスト、<a href="mailto:public-rdf-dawg-comments@w3.org">public-rdf-dawg-comments@w3.org</a>にお送りください。拡張や機能を含むこの仕様とは関連のないSPARQLに関する質問とコメントは、メーリングリスト<a href="mailto:public-sparql-dev@w3.org">public-sparql-dev@w3.org</a>（<a href="lists.w3.org/Archives/Public/public-sparql-dev">公開アーカイブ</a>）で議論できます。</p>

<p>このドキュメントは、<a href="www.w3.org/2001/sw/DataAccess/">RDFデータ・アクセス・ワーキンググループ</a>が作成したもので、<a href="www.w3.org/2001/sw/Activity">W3Cセマンティック・ウェブ・アクティビティ</a>の一部です。このドキュメントの草案としての最初の公開は2004年10月12日で、ワーキンググループは、それ以後に<a href="lists.w3.org/Archives/Public/public-rdf-dawg-comments/">受け取った多くのコメント</a>と<a href="www.w3.org/2001/sw/DataAccess/issues">課題</a>に取り組んで来ました。<a href="www.w3.org/TR/2007/PR-rdf-sparql-query-20071112/">2007年11月の勧告案</a>の公表以後に2つの<a href="#chlog">変更が行われ、記録されています</a>。</p>

<p id="implExp">ワーキンググループの<a href="www.w3.org/2001/sw/DataAccess/impl-report-ql">RDF用クエリ言語SPARQL実装報告書</a>は、<a href="www.w3.org/TR/2007/CR-rdf-sparql-query-20070614">2007年6月の勧告候補</a>で設定された相互運用可能な実装という目標が達成されたことを示しています。</p>

<p><span class="postponed">データ・アクセス・ワーキンググループは、<a href="www.w3.org/2001/sw/DataAccess/issues#countAggregate">集約関数</a>、および<a href="www.w3.org/2001/sw/DataAccess/issues#update">更新言語</a>を含む12の課題を先送りしました。</span></p>

<p>このドキュメントは、<a href="www.w3.org/Consortium/Patent-Policy-20040205/">2004年2月5日のW3C特許方針</a>の下で活動しているグループによって作成されました。W3Cは、このグループの成果物に関連する<a rel="disclosure" href="www.w3.org/2004/01/pp-impl/39407/status">あらゆる特許の開示の公開リスト</a>を維持し、このページには特許の開示に関する指示も含まれています。<a href="www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">不可欠な請求権</a>（Essential Claim(s)）を含んでいると思われる特許に関して実際に知っている人は、<a href="www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">W3C特許方針の6項</a>に従って情報を開示しなければなりません。</p>
</div>
<hr>

<div class="toc">
  <h2><a id="contents" name="contents">目次</a></h2>
  
  <ul class="toc">
  
    <li class="tocline1">
<a href="#introduction">1 はじめに</a> </li>
      <li class="tocline2">
<a href="#docOutline">1.1 ドキュメントの概要</a>
      <ul class="toc">
        <li class="tocline2">
<a href="#docConventions">1.2 キュメントの慣習</a>
        <ul class="toc">
          <li class="tocline2"><a href="#docNamespaces">1.2.1 名前空間</a></li>
          <li class="tocline2"><a href="#docDataDesc">1.2.2 データの記述</a></li>
          <li class="tocline2"><a href="#docResultDesc">1.2.3 結果の記述</a></li>
          <li class="tocline2"><a href="#docTerminology">1.2.4 用語</a></li>
        </ul>
      </li>
      </ul>
    </li>

    <li class="tocline1">
<a href="#basicpatterns">2 シンプルなクエリの作成</a>（参考情報）
    <ul class="toc">
      <li class="tocline2"><a href="#WritingSimpleQueries">2.1 シンプルなクエリの記述</a></li>
      <li class="tocline2"><a href="#MultipleMatches">2.2 複数マッチ</a></li>
      <li class="tocline2">
<a href="#matchingRDFLiterals">2.3 RDFリテラルのマッチング</a>
      <ul class="toc">
	<li class="tocline2"><a href="#matchLangTags">2.3.1 リテラルと言語タグとのマッチング</a></li>
	<li class="tocline2"><a href="#matchNumber">2.3.2 リテラルと数値型とのマッチング</a></li>
	<li class="tocline2"><a href="#matchArbDT">2.3.3 リテラルと任意のデータ型とのマッチング</a></li>
      </ul>
      </li>
      <li class="tocline2"><a href="#BlankNodesInResults">2.4 クエリ結果の空白ノード・ラベル</a></li>
      <li class="tocline2"><a href="#constructGraph">2.5 RDFグラフの構築</a></li>
    </ul>
    </li>

    <li class="tocline1">
<a href="#termConstraint">3 RDF用語制約</a>（参考情報）
    <ul class="toc">
      <li class="tocline2"><a href="#restrictString">3.1 文字列の値の制限</a></li>
      <li class="tocline2"><a href="#restrictNumber">3.2 数値の制限</a></li>
      <li class="tocline2"><a href="#otherTermConstraints">3.3 その他の用語制約</a></li>
    </ul>
    </li>

    <li class="tocline1">
<a href="#sparqlSyntax">4 SPARQL構文</a>
    <ul class="toc">
      <li class="tocline2">
<a href="#syntaxTerms">4.1 RDF用語構文</a>
      <ul class="toc">
	<li><a href="#QSynIRI">4.1.1 IRIの構文</a></li>
	<li><a href="#QSynLiterals">4.1.2 リテラルの構文</a></li>
	<li><a href="#QSynVariables">4.1.3 クエリ変数の構文</a></li>
	<li><a href="#QSynBlankNodes">4.1.4 空白ノードの構文</a></li>
      </ul>
      </li>
      <li class="tocline2">
<a href="#QSynTriples">4.2 トリプル・パターンの構文</a>
      <ul class="toc">
	<li class="tocline2"><a href="#predObjLists">4.2.1 述語-目的語のリスト</a></li>
	<li class="tocline2"><a href="#objLists">4.2.2 目的語のリスト</a></li>
	<li class="tocline2"><a href="#collections">4.2.3 RDFコレクション</a></li>
	<li class="tocline2"><a href="#abbrevRdfType">4.2.4 rdf:type</a></li>
      </ul>
      </li>
      
    </ul>
    </li>

    <li class="tocline1">
<a href="#GraphPattern">5 グラフ・パターン</a><ul class="toc">
    <li class="tocline2">
<a href="#BasicGraphPatterns">5.1 基本グラフ・パターン</a>
    <ul class="toc">
      <li class="tocline2"><a href="#bgpBNodeLabels">5.1.1 空白ノード・ラベル</a></li>
      <li class="tocline2"><a href="#bgpExtend">5.1.2 基本グラフ・パターン・マッチングの拡張</a></li>
    </ul>
    </li>
    <li class="tocline2">
<a href="#GroupPatterns">5.2 グループ・グラフ・パターン</a>
    <ul class="toc">
      <li class="tocline2"><a href="#emptyGroupPattern">5.2.1 空のグループ・パターン</a></li>
      <li class="tocline2"><a href="#scopeFilters">5.2.2 フィルタの範囲</a></li>
      <li class="tocline2"><a href="#groupExamples">5.2.3 グループ・グラフ・パターンの例</a></li>
    </ul>
    </li>
    </ul>
    </li>

    <li class="tocline1">
<a href="#optionals">6 オプション値の組み込み</a>
    <ul class="toc">
      <li class="tocline2"><a href="#OptionalMatching">6.1 オプションのパターン・マッチング</a></li>
      <li class="tocline2"><a href="#OptionalAndConstraints">6.2 オプションのパターン・マッチングにおける制約</a></li>
      <li class="tocline2"><a href="#MultipleOptionals">6.3 複数のオプションのグラフ・パターン</a></li>
    </ul>
    </li>
    
    <li class="tocline1"><a href="#alternatives">7 代替のマッチング</a></li>
    
    <li class="tocline1">
<a href="#rdfDataset">8 RDFデータセット</a>
    <ul class="toc">
      <li class="tocline2"><a href="#exampleDatasets">8.1 RDFデータセットの例</a></li>
      <li class="tocline2">
<a href="#specifyingDataset">8.2 RDFデータセットの指定</a>
      <ul class="toc">
        <li class="tocline2"><a href="#unnamedGraph">8.2.1 デフォルト・グラフの指定</a></li>
        <li class="tocline2"><a href="#namedGraphs">8.2.2 名前付きグラフの指定</a></li>
        <li class="tocline2"><a href="#specDataset">8.2.3 FROMとFROM NAMEDの結合</a></li>      </ul>
</li>
      <li class="tocline2">
<a href="#queryDataset">8.3 データセットのクエリ実行</a>
      <ul class="toc">
        <li class="tocline2"><a href="#accessByLabel">8.3.1 グラフ名へのアクセス</a></li>
        <li class="tocline2"><a href="#restrictByLabel">8.3.2 グラフIRIによる制限</a></li>
        <li class="tocline2"><a href="#restrictInQuery">8.3.3 ありうるグラフIRFの制限</a></li>
        <li class="tocline2"><a href="#namedAndDefaultGraph">8.3.4 名前付きグラフおよびデフォルト・グラフ</a></li>
      </ul>
</li>
    </ul>
    </li>
    
    <li class="tocline1">
<a href="#solutionModifiers">9 ソリューション・シーケンスと修飾子</a>
    <ul class="toc">
      <li class="tocline2"><a href="#modOrderBy">9.1 ORDER BY</a></li>
      <li class="tocline2"><a href="#modProjection">9.2 Projection</a></li>
      <li class="tocline2">
<a href="#modDuplicates">9.3 ソリューションの複製</a><ul class="toc">
	<li class="tocline2"><a href="#modDistinct">9.3.1 DISTINCT</a></li>	<li class="tocline2"><a href="#modReduced">9.3.2 REDUCED</a></li>
      </ul>
</li>
      <li class="tocline2"><a href="#modOffset">9.4 OFFSET</a></li>
      <li class="tocline2"><a href="#modResultLimit">9.5 LIMIT</a></li>
    </ul>
    </li>

    <li class="tocline1">
<a href="#QueryForms">10&nbsp; クエリ形式</a>
    <ul class="toc">
      <li class="tocline2"><a href="#select">10.1 SELECT</a></li>
      <li class="tocline2">
<a href="#construct">10.2 CONSTRUCT</a><ul class="toc">
	  <li class="tocline2"><a href="#tempatesWithBNodes">10.2.1 空白ノードを持つテンプレート</a></li>
      <li class="tocline2"><a href="#accessingRdfGraphs">10.2.2 RDFデータセットのグラフへのアクセス</a></li>
      <li class="tocline2"><a href="#SolModandCONSTRUCT">10.2.3 ソリューション修飾子とCONSTRUCT</a></li>
    </ul>
	</li>
    <li class="tocline2"><a href="#ask">10.3 ASK</a></li>
    <li class="tocline2">
<a href="#describe">10.4 DESCRIBE</a>（参考情報）
    <ul class="toc">
	  <li class="tocline2"><a href="#explititURIs">10.4.1 明示的なIRI</a></li>
	  <li class="tocline2"><a href="#identifyingResources">10.4.2 資源の識別</a></li>
	  <li class="tocline2"><a href="#descriptionsOfResources">10.4.3 資源の記述</a></li>
    </ul>
    </li>
  </ul>
  </li>
    
    <li class="tocline1">
<a href="#tests">11 値のテスト</a>
    <ul class="toc">
      <li class="tocline2"><a href="#operandDataTypes">11.1 オペランド・データ型</a></li>
      <li class="tocline2">
<a href="#evaluation">11.2 フィルタ評価</a>
      <ul class="toc">
	<li class="tocline2"><a href="#invocation">11.2.1 呼び出し</a></li>
	<li class="tocline2"><a href="#ebv">11.2.2 有効なブール値</a></li>
      </ul>
      </li>
      <li class="tocline2">
<a href="#OperatorMapping">11.3 演算子マッピング</a>
      <ul class="toc">
	<li class="tocline2"><a href="#operatorExtensibility">11.3.1 演算子の拡張性</a></li>
      </ul>
      </li>
      <li class="tocline2">
<a href="#SparqlOps">11.4 演算子の定義</a>
      <ul class="toc">
	<li class="tocline2"><a href="#func-bound">11.4.1 <span class="sopTOC">
	バインド</span></a></li>
	<li class="tocline2"><a href="#func-isIRI">11.4.2 <span class="sopTOC">
	isIRI</span></a></li>
	<li class="tocline2"><a href="#func-isBlank">11.4.3
	<span class="sopTOC">isBlank</span></a></li>
	<li class="tocline2"><a href="#func-isLiteral">11.4.4
	<span class="sopTOC">isLiteral</span></a></li>
	<li class="tocline2"><a href="#func-str">11.4.5 <span class="sopTOC">str</span></a></li>
	<li class="tocline2"><a href="#func-lang">11.4.6 <span class="sopTOC">
	lang</span></a></li>
	<li class="tocline2"><a href="#func-datatype">11.4.7
	<span class="sopTOC">datatype</span></a></li>
	<li class="tocline2"><a href="#func-logical-or">11.4.8
	<span class="sopTOC">logical-or</span></a></li>
	<li class="tocline2"><a href="#func-logical-and">11.4.9
	<span class="sopTOC">logical-and</span></a></li>
	<li class="tocline2"><a href="#func-RDFterm-equal">11.4.10
	<span class="sopTOC">RDFterm-equal</span></a></li>
	<li class="tocline2"><a href="#func-sameTerm">11.4.11
	<span class="sopTOC">sameTerm</span></a></li>
	<li class="tocline2"><a href="#func-langMatches">11.4.12
	<span class="sopTOC">langMatches</span></a></li>
	<li class="tocline2"><a href="#funcex-regex">11.4.13
	<span class="sopTOC">regex</span></a></li>
      </ul>
      </li>
      <li class="tocline2"><a href="#FunctionMapping">11.5 コンストラクタ関数</a></li>
      <li class="tocline2"><a href="#extensionFunctions">11.6 拡張可能な値テスト</a></li>
    </ul>
    </li>

    <li class="tocline1">
<a href="#sparqlDefinition">12 SPARQLの定義</a>
    <ul class="toc">
      <li class="tocline2">
<a href="#initDefinitions">12.1 初期定義</a>      <ul class="toc">
        <li class="tocline2"><a href="#sparqlBasicTerms">12.1.1 RDF用語</a></li>
        <li class="tocline2"><a href="#sparqlDataset">12.1.2 RDFデータセット</a></li>
        <li class="tocline2"><a href="#sparqlQueryVariables">12.1.3 クエリ変数</a></li>
        <li class="tocline2"><a href="#sparqlTriplePatterns">12.1.4 トリプル・パターン</a></li>
        <li class="tocline2"><a href="#sparqlBasicGraphPatterns">12.1.5 基本グラフ・パターン</a></li>
        <li class="tocline2"><a href="#sparqlSolutions">12.1.6 ソリューション・マッピング</a></li>
        <li class="tocline2"><a href="#sparqlSolMod">12.1.7 ソリューション・シーケンス修飾子</a></li>
      </ul>
      </li>
      <li class="tocline2">
<a href="#sparqlQuery">12.2 SPARQLクエリ</a>
        <ul class="toc">
          <li class="tocline2"><a href="#convertGraphPattern">12.2.1 グラフ・パターンの変換</a></li>
          <li class="tocline2"><a href="#sparqlAbsExamples">12.2.2 マッピングされたグラフ・パターンの例</a></li>
          <li class="tocline2"><a href="#convertSolMod">12.2.3 ソリューション修飾子の変換</a></li>
        </ul>
      </li>

      <li class="tocline2">
<a href="#BasicGraphPattern">12.3 基本グラフ・パターン</a>
      <ul class="toc">
        <li class="tocline2"><a href="#BGPsparql">12.3.1 SPARQLの基本グラフ・パターン・マッチング</a></li>
        <li class="tocline2"><a href="#BGPsparqlBNodes">12.3.2 空白ノードの処理</a></li>
      </ul>
      </li>
      <li class="tocline2"><a href="#sparqlAlgebra">12.4 SPARQL代数</a></li>
      <li class="tocline2"><a href="#sparqlAlgebraEval">12.5 SPARQL評価セマンティクス</a></li>
      <li class="tocline2"><a href="#sparqlBGPExtend">12.6 SPARQL基本グラフ・マッチングの拡張</a></li>
    </ul>
    </li>
  </ul>
</div>

<h3><a id="appendices" name="appendices">付録</a></h3>
<ul class="toc">
  <li class="tocline2">
<a href="#grammar">A SPARQL文法</a><ul class="toc">
  <li class="tocline2"><a href="#queryString">A.1 SPARQLクエリ文字列参照</a></li>
  <li class="tocline2"><a href="#codepointEscape">A.2 コードポイント・エスケープ・シーケンス</a></li>
  <li class="tocline2"><a href="#whitespace">A.3 空白</a></li>
  <li class="tocline2"><a href="#grammarComments">A.4 コメント</a></li>
  <li class="tocline2"><a href="#iriRefs">A.5 IRI参照</a></li>
  <li class="tocline2"><a href="#grammarBNodeLabels">A.6 空白ノード・ラベル</a></li>
  <li class="tocline2"><a href="#grammarEscapes">A.7 文字列中のエスケープシーケンス</a></li>
  <li class="tocline2"><a href="#sparqlGrammar">A.8 文法</a></li>
  </ul>  </li>  <li class="tocline2"><a href="#conformance">B 適合性</a></li>
  <li class="tocline2">
<a href="#security">C セキュリティに関する留意点</a>（参考情報）</li>
  <li class="tocline2"><a href="#mediaType">D インターネット・メディア・タイプ、ファイル拡張子、およびマッキントッシュ・ファイル・タイプ</a></li>
  <li class="tocline2"><a href="#references">E 参考文献</a></li>
  <li class="tocline2">
<a href="#acknowledgements">F 謝辞</a>（参考情報）</li>
  <!-- li class="tocline2"><a href="#chlog">Change Log</a></li -->
</ul>
<hr>

<h2>1 <a id="introduction" name="introduction">はじめに</a>
</h2>

<p>RDFは、ウェブ上で情報を表すための、有向性の、ラベル付けされたグラフ・データの形式です。RDFは、異なる情報源を統合する手段の提供に加え、とりわけ、個人的な情報、ソーシャル・ネットワーク、デジタル・アーティファクトに関するメタデータを表すためにしばしば使用されます。この仕様では、RDF用クエリ言語SPARQLの構文およびセマンティクスを定義しています。</p>

<p>RDF用クエリ言語SPARQLは、<cite><a href="www.w3.org/TR/rdf-dawg-uc/" class="inform">RDFデータ・アクセス・ユースケースおよび要件</a></cite>[<a href="#UCNR">UCNR</a>]でRDFデータ・アクセス・ワーキンググループが指定しているユースケースおよび要件を満たすように設計されています。</p>

<p>SPARQLクエリ言語は、次の仕様と密接に関連しています。</p>

<ul>
<li>
<a class="inform" href="www.w3.org/TR/rdf-sparql-protocol/">RDF用SPARQLプロトコル</a>[<a href="#SPROT">SPROT</a>]の仕様は、SPARQLにクエリを発行し、結果を受けるリモート・プロトコルを定義しています。</li>
<li>
<a class="inform" href="www.w3.org/TR/rdf-sparql-XMLres/">SPARQLクエリ結果XMLフォーマット</a>[<a href="#RESULTS">RESULTS</a>]の仕様は、SPARQLのSELECTとASKのクエリの結果を表すXMLドキュメント・フォーマットを定義しています。</li>
</ul>

<h3>1.1 <a id="docOutline" name="docOutline">ドキュメントの概要</a>
</h3>

<p>項の先頭で特に注記がなければ、このドキュメントのすべての項と付録は規範的です。</p>

<p>ドキュメントのこの項（<a href="#introduction">1項</a>）では、SPARQLクエリ言語の仕様を紹介します。この仕様ドキュメントの構成と、仕様で使用されている慣習を示します。</p>

<p>仕様の<a href="#basicpatterns">2項</a>では、一連のクエリとクエリ結果の例により、SPARQLクエリ言語自体を紹介します。<a href="#termConstraint">3項</a>では、クエリの結果に現れるRDF用語において制約を表現するSPARQLの性能を示す例をより多く用いて、SPARQLクエリ言語の紹介を継続して行います。</p>

<p><a href="#sparqlSyntax">4項</a>では、SPARQLクエリ言語の構文の詳細を示します。これは、言語の完全な構文への手引きであり、文法構造がどのようにIRI、空白ノード、リテラル、変数を表すかを定義します。<a href="#sparqlSyntax">4項</a>では、より冗長な表現に対する糖衣構文として役立ついくつかの文法構造の意味も定義します。</p>

<p><a href="#GraphPattern">5項</a>では、基本グラフ・パターンとグループ・グラフ・パターン、より複雑なSPARQLクエリ・パターンの構成要素を紹介します。6、7、8項では、SPARQLグラフ・パターンをより大きなグラフ・パターンに組み合わせる構成子を提示します。特に、<a href="#optionals">6項</a>では、クエリ・オプションの一部を作成する性能を紹介し、<a href="#alternatives">7項</a>では、代替グラフ・パターンの論理和を表す性能を紹介し、そして、<a href="#rdfDataset">8項</a>では、クエリの一部を特定のソース・グラフに制約する性能を紹介します。8項では、クエリに対してソース・グラフを定義するSPARQLの仕組みも提示します。</p>
 
<p><a href="#solutionModifiers">9項</a>は、順序付け、スライス、プロジェクション、制限、ソリューションのシーケンスからの重複の排除によるクエリのソリューションに影響する構成子を定義します。</p>

<p><a href="#QueryForms">10項</a>では、異なる形式の結果を生む4種類のSPARQLクエリを定義します。</p>

<p><a href="#tests">11項</a>では、SPARQLの拡張可能な値テストの枠組みを定義します。また、クエリの結果に現れる値を制約するために使用できる関数と演算子を提示します。</p>

<p><a href="#sparqlDefinition">12項</a>は、SPARQLグラフ・パターンとソリューション修飾子の評価に関する形式的な定義です。</p>

<p><a href="#grammar">付録A</a>は、EBNF表記法で示されている文法で規定されているような、SPARQLクエリ言語の構文の規範的な定義を含んでいます。</p>

<h3>1.2 <a id="docConventions" name="docConventions">キュメントの慣習</a>
</h3>

<h4>1.2.1 <a id="docNamespaces" name="docNamespaces">名前空間</a>
</h4>

<p>このドキュメントでは、特に注記がなければ、例では、次の名前空間は接頭辞バインディングを想定しています。</p>

<div style="text-align: center;">
  <table style="border-collapse: collapse; border-color: #000000" border="1" cellpadding="5">
    <tr>
      <th>接頭辞</th>
      <th>IRI</th>
    </tr>
    <tr>
      <td><code>rdf:</code></td>
      <td><code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code></td>
    </tr>
    <tr>
      <td><code>rdfs:</code></td>
      <td><code>http://www.w3.org/2000/01/rdf-schema#</code></td>
    </tr>
    <tr>
      <td><code>xsd:</code></td>
      <td><code>http://www.w3.org/2001/XMLSchema#</code></td>
    </tr>
    <tr>
      <td><code>fn:</code></td>
      <td><code>http://www.w3.org/2005/xpath-functions#</code></td>
    </tr>
  </table>
</div>

<h4>1.2.2 <a id="docDataDesc" name="docDataDesc">データの記述</a>
</h4>

<p>このドキュメントでは、各トリプルを明示的に表示するために<a class="inform" href="www.w3.org/TeamSubmission/turtle/">Turtle</a>[<a href="#TURTLE">TURTLE</a>]を使用します。Turtleでは、接頭辞を用いてIRIを省略することが認められています。</p>

<pre class="data">
@prefix dc:   &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix :     &lt;http://example.org/book/&gt; .
:book1  dc:title  &quot;SPARQL Tutorial&quot; .
</pre>

<h4>1.2.3 <a id="docResultDesc" name="docResultDesc">結果の記述</a>
</h4>

<p>結果集合は、表形式で示されます。</p>

<div class="result">
  <table class="resultTable" id="table39">
    <tr>
      <th>x</th>
      <th>y</th>
      <th>z</th>
    </tr>
    <tr>
      <td>&quot;Alice&quot;</td>
      <td><code>&lt;http://example/a&gt;</code></td>
      <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </td>
    </tr>
  </table>
</div>

<p>「バインディング」は、（<a href="#defn_QueryVariable">変数</a>、<a href="#defn_RDFTerm">RDF用語</a>）の対です。この結果集合には、<code>x</code>、<code>y</code>、<code>z</code>（列の見出しとして示されている）という3つの変数があります。各ソリューションは、表の本文の1つの列として示されています。ここでは、1つのソリューションがあり、変数<code>x</code>は<code>&quot;Alice&quot;</code>にバインドされており、変数<code>y</code>は<code>&lt;http://example/a&gt;</code>にバインドされており、変数<code>z</code>はRDF用語にバインドされていません。ソリューションでは、変数は、バインドされている必要はありません。</p>

<h4>1.2.4 <a id="docTerminology" name="docTerminology">用語</a>
</h4>

  <p>SPARQL言語には、スペースを省略するRDF URI参照のサブセットであるIRIが含まれています。SPARQLクエリでは、すべてのIRIが絶対的であることに注意してください。IRIには、フラグメント識別子[<a href="#rfc3987">RFC3987</a>、3.1項]を含むことも含まないことも可能です。IRIには、URI[<a href="#rfc3986">RFC3986</a>]とURLが含まれます。SPARQL構文の省略形（<a href="#QSynIRI">相対IRIおよび接頭辞付き名前</a>）が解決されると、絶対IRIが作成されます。</p>

<p>次の用語は、<a class="norm" href="www.w3.org/TR/2004/REC-rdf-concepts-20040210/">RDF概念および抽象構文</a> <a href="#CONCEPTS">[CONCEPTS]</a>で定義されており、SPARQLで使用されます。</p>

  <ul>
    <li>
<a class="type IRI" href="www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-URI-reference">IRI</a>（概念および抽象構文の用語「RDF URI参照」（<code>RDF URI reference</code>）に対応）</li>
    <li><a class="type literal" href="www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-literal">リテラル</a></li>
    <li><a class="type lexicalForm" href="www.w3.org/TR/rdf-concepts/#dfn-lexical-form">字句形式</a></li>
    <li><a class="type plainLiteral" href="www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-plain-literal">プレーン・リテラル</a></li>
    <li><a class="type langTag" href="www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-language-identifier">言語タグ</a></li>
    <li><a class="type typedLiteral" href="www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-typed-literal">型付きリテラル</a></li>
    <li>
<a class="type datatypeIRI" href="www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-datatype-URI">データ型URI</a>（概念および抽象構文の「データ型URI」（<code>datatype URI</code>）という用語に対応）</li>
    <li><a class="type bNode" href="www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-blank-node">空白ノード</a></li>
  </ul>

<h2>2 <a id="basicpatterns" name="basicpatterns">シンプルなクエリの作成</a>（参考情報）</h2>

    <p>SPARQLクエリのほとんどの形式には、<em>基本グラフ・パターン</em>と呼ばれる1組のトリプル・パターンが含まれています。それぞれの主語、述語、目的語が変数でありえることを除き、トリプル・パターンはRDFトリプルに類似しています。サブグラフからの<a href="#defn_RDFTerm">RDF用語</a>を変数に代替でき、結果がサブグラフに同等なRDFグラフである場合、基本グラフ・パターンはそのRDFデータのサブグラフに<em>マッチ</em>します。</p>

<h3>2.1 <a id="WritingSimpleQueries" name="WritingSimpleQueries">シンプルなクエリの記述</a>
</h3>

<p>次の例は、与えられたデータ・グラフから書名（title）を発見するためのSPARQLクエリを示しています。クエリは、次の2つで構成されています。<code>SELECT</code>句はクエリの結果に現れる変数を識別し、<code>WHERE</code>句はデータ・グラフにマッチする基本グラフ・パターンを提供します。この例の基本グラフ・パターンは、目的語の位置に1つの変数（<code>?title</code>）を持つ、1つのトリプル・のパターンから成ります。</p>

<div class="exampleGroup" id="foo">
  <p>データ:</p>
  <pre class="data">
&lt;http://example.org/book/book1&gt; &lt;http://purl.org/dc/elements/1.1/title&gt; &quot;SPARQL Tutorial&quot; .
</pre>
  <div class="queryGroup">
    <p>クエリ:</p>
    <pre class="query">
SELECT ?title
WHERE{
  &lt;http://example.org/book/book1&gt; &lt;http://purl.org/dc/elements/1.1/title&gt; ?title .
}    
</pre>
    <p>上記のデータのこのクエリには、次の1つのソリューションがあります。</p>

    <p>クエリ結果:</p>
    <div class="result">
      <table class="resultTable" id="table1">
        <tr>
          <th>title</th>
        </tr>
        <tr>
          <td>&quot;SPARQL Tutorial&quot;</td>
        </tr>
      </table>
    </div>
  </div>
</div>

<h3>2.2 <a id="MultipleMatches" name="MultipleMatches">複数マッチ</a>
</h3>
<p>クエリの結果は、クエリのグラフ・パターンがデータにマッチする方法に従った<a href="#defn_sparqlSolutionSequence">ソリューション・シーケンス</a>です。クエリに対し、0、1または複数のソリューションがありえます。</p>

<p>データ:</p>
<div class="exampleGroup">
  <pre class="data">
@prefix foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name   &quot;Johnny Lee Outlaw&quot; .
_:a  foaf:mbox   &lt;mailto:jlow@example.com&gt; .
_:b  foaf:name   &quot;Peter Goodguy&quot; .
_:b  foaf:mbox   &lt;mailto:peter@example.org&gt; .
_:c  foaf:mbox   &lt;mailto:carol@example.org&gt; .
</pre>
  <p>クエリ:</p>
  <div class="queryGroup">
    <pre class="query">
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE
  { ?x foaf:name ?name .
    ?x foaf:mbox ?mbox }
</pre>
    <p>クエリ結果:</p>
    <div class="result">
      <table class="resultTable">
        <tr>          <th>name</th>
          <th>mbox</th>        </tr>
        <tr>
          <td>&quot;Johnny Lee Outlaw&quot;</td>
          <td>&lt;mailto:jlow@example.com&gt;</td>
        </tr>
        <tr>
          <td>&quot;Peter Goodguy&quot;</td>
          <td>&lt;mailto:peter@example.org&gt;</td>
        </tr>
      </table>
    </div>
  </div>
</div>

<p>各ソリューションは、クエリ・パターンがデータにマッチするように、選択された変数をRDF用語にバインドできる1つの方法を提示します。結果集合は、すべての可能なソリューションを示します。上例では、次の2つのデータのサブセットが2つのマッチをもたらしました。</p>

<pre class="dataExcerpt untested">
 _:a foaf:name  &quot;Johnny Lee Outlaw&quot; .
 _:a foaf:box   &lt;mailto:jlow@example.com&gt; .
</pre>
<pre class="dataExcerpt untested">
 _:b foaf:name  &quot;Peter Goodguy&quot; .
 _:b foaf:box   &lt;mailto:peter@example.org&gt; .
</pre>

<p>これは、<a href="#BGPsparql">基本グラフ・パターン・マッチ</a>で、クエリ・パターンで使用されるすべての変数がすべてのソリューションにバインドされていなければなりません。</p>

<h3>2.3 <a id="matchingRDFLiterals" name="matchingRDFLiterals">RDFリテラルのマッチング</a>
</h3>

<p>次のデータには、3つのRDFリテラルが含まれています。</p>

<div class="exampleGroup">
  <pre class="data">
@prefix dt:   &lt;http://example.org/datatype#&gt; .
@prefix ns:   &lt;http://example.org/ns#&gt; .
@prefix :     &lt;http://example.org/ns#&gt; .
@prefix xsd:  &lt;<code>http://www.w3.org/2001/XMLSchema#&gt; .</code>

:x   ns:p     "cat"@en .
:y   ns:p     "42"^^xsd:integer .
:z   ns:p     "abc"^^dt:specialDatatype .
</pre>

      <p>Turtleでは<code>"cat"@en</code>が字句形式「cat」と言語<code>en</code>を持つRDFリテラルであることに注意してください。<code>"42"^^xsd:integer</code>は、データ型<code>http://www.w3.org/2001/XMLSchema#integer</code>を持つ型付きリテラルであり、<code>"abc"^^dt:specialDatatype</code>は、データ型<code>http://example.org/datatype#specialDatatype</code>を持つ型付きリテラルです。</p>

  <p>このRDFデータは、2.3.1～2.3.3項のクエリの例に用いるデータ・グラフです。</p>

  <h4>2.3.1 <a id="matchLangTags" name="matchLangTags">リテラルと言語タグとのマッチング</a>
</h4>

      <p>SPARQLの言語タグは、<a class="norm" href="www.rfc-editor.org/rfc/bcp/bcp47.txt">ベスト・コモン・プラクティス47</a>[<a href="#BCP47">BCP47</a>]で定められているように、<code>@</code>と言語タグを用いて表されます。</p>

  <p>次のクエリでは、<code>&quot;cat&quot;</code>が<code>&quot;cat&quot;@en</code>と同じRDFリテラルではないため、ソリューションはありません。</p>

  <div class="queryGroup">
    <pre class="query">
SELECT ?v WHERE { ?v ?p &quot;cat&quot; }
</pre>
    <div class="result">
      <table class="resultTable">
        <tr>
          <th>&nbsp;&nbsp; v&nbsp;&nbsp;&nbsp;&nbsp; </th>
        </tr>
      </table>
    </div>

    <p>しかし、次のクエリは、言語タグが指定されており、与えられたデータにマッチするため、変数<code>v</code>が<code>:x</code>にバインドされているソリューションが見つかるでしょう。</p>

    <pre class="query">
SELECT ?v WHERE { ?v ?p &quot;cat&quot;@en }
</pre>
    <div class="result">
      <table class="resultTable">
        <tr>
          <th>v</th>
        </tr>
        <tr>
          <td>&lt;http://example.org/ns#x&gt;</td>
        </tr>
      </table>
    </div>
  </div>
</div>

  <h4>2.3.2 <a id="matchNumber" name="matchNumber">リテラルと数値型とのマッチング</a>
</h4>

    <p>SPARQLクエリの整数は、データ型<code>xsd:integer</code>を持つRDF型付きリテラルです。例えば、<code>42</code>は、<code>"42"^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;</code>の省略形です。</p>
  <p>次のクエリのパターンには、<code>:y</code>にバインドされている変数<code>v</code>を持つソリューションがあります。</p>

  <div class="queryGroup">
    <pre class="query">
SELECT ?v WHERE { ?v ?p 42 }
</pre>
    <div class="result">
      <table class="resultTable" id="table60">
        <tr>
          <th>v</th>
        </tr>
        <tr>
          <td>&lt;http://example.org/ns#y&gt;</td>
        </tr>
      </table>
    </div>
  </div>

    <p><a href="#QSynLiterals">4.1.2項</a>では、<code>xsd:float</code>と<code>xsd:double</code>のSPARQL省略形を定義しています。</p>

  <h4>2.3.3 <a id="matchArbDT" name="matchArbDT">リテラルと任意のデータ型とのマッチング</a>
</h4>

  <p>次のクエリには、<code>:z</code>にバインドされている変数<code>v</code>を持つソリューションがあります。クエリ・プロセッサがデータ型のスペースの値を理解している必要はありません。字句形式とデータ型IRIの両方がマッチするため、リテラルはマッチします。</p>

  <div class="queryGroup">
    <pre class="query">
SELECT ?v WHERE { ?v ?p &quot;abc&quot;^^&lt;http://example.org/datatype#specialDatatype&gt; }
</pre>
    <div class="result">
      <table class="resultTable" id="table61">
        <tr>
          <th>v</th>
        </tr>
        <tr>
          <td>&lt;http://example.org/ns#z&gt;</td>
        </tr>
      </table>
    </div>
  </div>

<h3>2.4 <a id="BlankNodesInResults" name="BlankNodesInResults">クエリ結果の空白ノード・ラベル</a>
</h3>

<p>クエリの結果には、空白ノードを含むことができます。このドキュメントの例では、結果集合の空白ノードは、"_:"の後に空白ノード・ラベルが続く形で書かれています。</p>

<p>空白ノード・ラベルは結果集合（「<a class="inform" href="www.w3.org/TR/rdf-sparql-XMLres/">SPARQLクエリ結果XMLフォーマット</a>」で定められているように）で有効であり、<code>CONSTRUCT</code>クエリ形式の場合は結果グラフで有効です。結果集合内での同じラベルの使用は、同じ空白ノードを表します。</p>

<div class="exampleGroup">
  データ:
  <pre class="data">
@prefix foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name   &quot;Alice&quot; .
_:b  foaf:name   &quot;Bob&quot; .
</pre>
  <div class="queryGroup">
    クエリ:
    <pre class="query">
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?x ?name
WHERE  { ?x foaf:name ?name }
</pre>
    <div class="result">
      <table class="resultTable" id="table56">
        <tr>
          <th>x</th>
          <th>name</th>
        </tr>
        <tr>
          <td>_:c</td>
          <td>&quot;Alice&quot;</td>
        </tr>
        <tr>
          <td>_:d</td>
          <td>&quot;Bob&quot;</td>
        </tr>
      </table>
    </div>
  </div>

  <p>上記の結果は、結果におけるラベルがソリューション内のRDF用語が同じか異なるかを示すだけであるため、異なる空白ノード・ラベルでも同じく得ることができます。</p>

  <div class="result untested">
    <table class="resultTable" id="table57">
      <tr>
        <th>x</th>
        <th>name</th>
      </tr>
      <tr>
        <td>_:r</td>
        <td>&quot;Alice&quot;</td>
      </tr>
      <tr>
        <td>_:s</td>
        <td>&quot;Bob&quot;</td>
      </tr>
    </table>
  </div>
</div>

<p>これらの2つの結果は同じ情報を持っていますが、2つのソリューションでは、クエリにマッチさせるために用いられる空白ノードが異なっています。結果集合のラベル<code>_:a</code>と、同じラベルを持つデータ・グラフの空白ノードとの間に関係がある必要はありません。</p>

<p>アプリケーションの作成者は、クエリの空白ノード・ラベルがデータの特定の空白ノードを参照することを期待すべきではありません。</p>

<h3>2.5 <a id="constructGraph" name="constructGraph">RDFグラフの構築</a>
</h3>

<p>SPARQLには、いくつかの<a href="#QueryForms">クエリ形式</a>があります。<code>SELECT</code>というクエリ形式は、変数バインディングを返します。<code>CONSTRUCT</code>というクエリ形式はRDFグラフを返します。グラフは、クエリのグラフ・パターンをマッチングした結果に基づくRDFトリプルを作成するために用いられるテンプレートに基づいて構築されます。</p>

<div class="exampleGroup">
<p>データ:</p>
  <pre class="data">
@prefix org:    &lt;http://example.com/ns#&gt; .

_:a  org:employeeName   &quot;Alice&quot; .
_:a  org:employeeId     12345 .

_:b  org:employeeName   &quot;Bob&quot; .
_:b  org:employeeId     67890 .</pre>
  <div class="queryGroup">
<p>クエリ:</p>
    <pre class="query">
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX org:    &lt;http://example.com/ns#&gt;

CONSTRUCT { ?x foaf:name ?name }
WHERE  { ?x org:employeeName ?name }</pre>
<p>結果:</p>    <div class="result">
      <pre class="resultGraph">@prefix org: &lt;http://example.com/ns#&gt; .
      
_:x foaf:name &quot;Alice&quot; .
_:y foaf:name &quot;Bob&quot; .</pre>
      </div>
  </div>

  <p>これは、次のとおり、<a href="www.w3.org/TR/rdf-syntax-grammar/">RDF/XML</a>でシリアル化できます。</p>
  
  <div class="result">
      <pre class="resultGraph" style="text-align: left;">
&lt;rdf:RDF
    xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;
    xmlns:foaf=&quot;http://xmlns.com/foaf/0.1/&quot;
    &gt;
  &lt;rdf:Description&gt;
    &lt;foaf:name&gt;Alice&lt;/foaf:name&gt;
  &lt;/rdf:Description&gt;
  &lt;rdf:Description&gt;
    &lt;foaf:name&gt;Bob&lt;/foaf:name&gt;
  &lt;/rdf:Description&gt;
&lt;/rdf:RDF&gt;</pre>
  </div>
  </div>

<h2>3 <a id="termConstraint" name="termConstraint">RDF用語制約</a>（参考情報）</h2>

  <p>グラフ・パターン・マッチングはソリューション・シーケンスを作成し、その各ソリューションは、RDF用語に対する変数バインディングの集合を持ちます。SPARQLの<code>FILTER</code>は、フィルタの式が真（<code>TRUE</code>）であるものにソリューションを制限します。</p>

    <p>この項では、SPARQLの<code>FILTER</code>に関する非形式的な手引きを提供します。このセマンティクスは、<a href="#tests">11項 値のテスト</a>で定められています。この項の例では、次の1つの入力グラフを共用しています。</p>

<div class="exampleGroup">
  データ:
  <pre class="data">
@prefix dc:   &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix :     &lt;http://example.org/book/&gt; .
@prefix ns:   &lt;http://example.org/ns#&gt; .

:book1  dc:title  &quot;SPARQL Tutorial&quot; .
:book1  ns:price  42 .
:book2  dc:title  &quot;The Semantic Web&quot; .
:book2  ns:price  23 .
</pre>

  <h3>3.1 <a name="restrictString" id="restrictString">文字列の値の制限</a>
</h3>

  <p><code><a href="#funcex-regex">regex</a></code>のようなSPARQLの<code>FILTER</code>関数は、RDFリテラルをテストできます。<code>regex</code>は、言語タグを持たないプレーン・リテラルのみにマッチします。<code>regex</code>は、<a href="#func-str">str</a>関数を用いて他のリテラルの字句形式にマッチさせるために使用できます。</p>

  <p>クエリ:</p>
  <div class="queryGroup">
    <pre class="query">
PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT  ?title
WHERE   { ?x dc:title ?title
          FILTER regex(?title, &quot;^SPARQL&quot;) 
        }
</pre>
    <p>クエリ結果:</p>
    <div class="result">
      <table class="resultTable" id="table63">
        <tr>
          <th>title</th>
        </tr>
        <tr>
          <td>&quot;SPARQL Tutorial&quot;</td>
        </tr>
      </table>
    </div>
  </div>

  <p>正規表現マッチでは、「<code>i</code>」フラグを用いて大文字・小文字を区別しないようにすることができます。</p>

  <p>クエリ:</p>
  <div class="queryGroup">
    <pre class="query">
PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT  ?title
WHERE   { ?x dc:title ?title
          FILTER regex(?title, &quot;web&quot;, &quot;i&quot; ) 
        }
</pre>
    <p>クエリ結果:</p>
    <div class="result">
      <table class="resultTable" id="table64">
        <tr>
          <th>title</th>
        </tr>
        <tr>
          <td>&quot;The Semantic Web&quot;</td>
        </tr>
      </table>
    </div>
  </div>
      <p>正規表現言語は、<a href="www.w3.org/TR/xpath-functions/#regex-syntax">XQuery 1.0とXPath 2.0関数および演算子で定められており</a>、<a href="www.w3.org/TR/xmlschema-2/#regexs">XMLスキーマ正規表現</a>に基づいています。</p>

  <h3>3.2 <a name="restrictNumber" id="restrictNumber">数値の制限</a>
</h3>

  <p>SPARQLの<code>FILTER</code>は、計算式を制限できます。</p>

  <p>クエリ:</p>
  <div class="queryGroup">
    <pre class="query">
PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  ns:  &lt;http://example.org/ns#&gt;
SELECT  ?title ?price
WHERE   { ?x ns:price ?price .
          FILTER (?price &lt; 30.5)
          ?x dc:title ?title . }
</pre>
    <p>クエリ結果:</p>
    <div class="result">
      <table class="resultTable" id="table58">
        <tr>
          <th>title</th>
          <th>price</th>
        </tr>
        <tr>
          <td>&quot;The Semantic Web&quot;</td>
          <td>23</td>
        </tr>
      </table>
    </div>
  </div>
</div>

<p><code>:book2</code>のみが<code>30.5</code>未満の価格を持っているため、<code>price</code>変数を制約することで、フィルタ条件の要求に従い、<code>:book2</code>のみがクエリにマッチします。</p>

<h3>3.3 <a id="otherTermConstraints" name="otherTermConstraints">その他の用語制約</a>
</h3>

    <p><span class="type numeric">数値</span>型に加え、SPARQLは、<code>xsd:string</code>、<code>xsd:boolean</code>、<code>xsd:dateTime</code>という型をサポートしています（<a href="#operandDataTypes">11.1 オペランド・データ型</a>を参照してください）。<a href="#OperatorMapping">11.3 演算子マッピング</a>には、<code>BOUND</code>、<code>isLITERAL</code>、<code>langMATCHES</code>を含むテスト関数と、<code>STR</code>、<code>LANG</code>、<code>DATATYPE</code>を含むアクセサがリストアップされています。<a href="#FunctionMapping">11.5 コンストラクタ関数</a>には、ある型から別の型に値をキャストするためのSPARQL言語に含まれているXMLスキーマ・コンストラクタ関数がリストアップされています。</p>

<h2>4 <a id="sparqlSyntax" name="sparqlSyntax">SPARQL構文</a>
</h2>

<p>この項では、<a href="#sparqlBasicTerms">RDF用語</a>および<a href="#sparqlTriplePatterns">トリプル・パターン</a>に対してSPARQLが用いる構文をカバーしています。完全な文法は<a href="#grammar">付録A</a>で示します。</p>

<h3>4.1 <a id="syntaxTerms" name="syntaxTerms">RDF用語構文</a>
</h3>

<h4>4.1.1 <a id="QSynIRI" name="QSynIRI">IRIの構文</a>
</h4>

    <p><a href="#rIRIref">IRIref</a>生成規則は、IRI[<a href="#rfc3987">RFC3987</a>]の集合を指定します。IRIは、URI[<a href="#rfc3986">RFC3986</a>]を一般化したものであり、URIおよびURLと完全に互換性があります。<a href="#rPrefixedName">PrefixedName</a>生成規則は、接頭辞名を指定します。接頭辞名からIRIへのマッピングについて、以下で説明しています。IRI参照（相対的または絶対的なIRI）は、<a href="#rIRI_REF">IRI_REF</a>生成規則によって指定され、「&lt;」と「&gt;」の区切り記号はIRI参照の一部にはなりません。相対IRIは、[<a href="#rfc3987">RFC3987</a>]の2.2 IRI参照とIRIに対するABNFの項のirelative-refにマッチし、下記のIRIに解決されます。</p>

<div class="grammarExtract">
  文法規則:<div class="grammarTable">
    <table id="table109">
<tr>
  <td><code class="gRuleLabel">[67]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rIRIref">IRIref</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rIRI_REF">IRI_REF</a> |	<a href="#rPrefixedName">PrefixedName</a></code></td>
</tr>

<tr>
  <td><code class="gRuleLabel">[68]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rPrefixedName">PrefixedName</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rPNAME_LN">PNAME_LN</a> | <a href="#rPNAME_NS">PNAME_NS</a></code></td>
</tr>

<tr>
  <td><code class="gRuleLabel">[69]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rBlankNode">BlankNode</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rBLANK_NODE_LABEL">BLANK_NODE_LABEL</a> |	<a href="#rANON">ANON</a></code></td>
</tr>

<tr>
  <td><code class="gRuleLabel">[70]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rIRI_REF">IRI_REF</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'&lt;' ([^&lt;&gt;&quot;{}|^`\]-[#x00-#x20])* '&gt;'</span></code></td>
</tr>
<tr>
  <td><code class="gRuleLabel">[71]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rPNAME_NS">PNAME_NS</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rPN_PREFIX">PN_PREFIX</a>? ':'</code></td>
</tr>

<tr>
  <td><code class="gRuleLabel">[72]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rPNAME_LN">PNAME_LN</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rPNAME_NS">PNAME_NS</a> <a href="#rPN_LOCAL">PN_LOCAL</a></code></td>
</tr>
    </table>
  </div>
</div>

<p>SPARQL用語にはIRIが含まれていますが、RDF概念および抽象構文で定義されているRDF用語にはRDF URI参照が含まれています。「<code>&lt;</code>」、「<code>&gt;</code>」、「<code>&quot;</code>」（ダブル引用符）、スペース、「<code>{</code>」、「<code>}</code>」、「<code>|</code>」、「<code>\</code>」、「<code>^</code>」、「<code>`</code>」を含むRDF URI参照は、IRIではありません。このようなRDF URI参照で構成されたRDFステートメントに対するSPARQLクエリの動作は定められていません。</p>

<h5><a id="prefNames" name="prefNames">接頭辞名</a></h5>

<p><code>PREFIX</code>キーワードは、接頭辞ラベルをIRIに関連付けます。接頭辞名は、コロン「<code>:</code>」によって区切られた、接頭辞ラベルとローカル部分（local part）です。接頭辞名は、接頭辞に関連付けられたIRIとローカル部分とを連結することによって、IRIにマッピングされます。接頭辞ラベルまたはローカル部分は、空でありえます。先頭桁（leading digit）は、<a href="www.w3.org/TR/2006/REC-xml-names11-20060816/#NT-LocalPart">XMLローカル名</a>では認められていませんが、<a href="#rPN_LOCAL">SPARQLローカル名</a>では認められていることに注意してください。</p>

<h5><a id="relIRIs" name="relIRIs">相対IRI</a></h5>

<p>相対IRIは、<a class="norm" href="www.ietf.org/rfc/rfc3986.txt">URI（Uniform Resource Identifier）: 一般的構文</a>[<a href="#rfc3986">RFC3986</a>]にあるとおり、5.2項の基本アルゴリズムのみを用いて、基底IRIに組み合わされます。構文に基づく正規化もスキームに基づく正規化も（RFC3986の6.2.2および6.2.3項に記述されている）実行されません。IRI参照で追加的に認められている文字は、<a class="norm" href="www.ietf.org/rfc/rfc3987.txt">IRI（Internationalized Resource Identifiers）</a>[<a href="#rfc3987">RFC3987</a>]の6.5項にあるとおり、URI参照で無制限の文字が扱われているのと同じ方法で扱われます。</p>

<p><code>BASE</code>キーワードは、RFC3986の5.1.1項「コンテンツ内に組み込まれた基底URI」にあるとおり、相対IRIを解決するために用いられる基底IRIを定めます。5.1.2項「カプセル化されたエンティティーからの基底URI」は、xml:base指示子を持つSOAPエンベロープやContent-Locationヘッダーを持つマイム・マルチパート・ドキュメントのようなカプセル化されたドキュメントから、どのように基底IRIを持ってくることができるかを定めています。5.1.3「検索URIからの基底URI」で識別された「検索URI」は、特定のSPARQLクエリが検索されたURLです。上記のどれもが基底URIを指定しない場合は、デフォルト基底URI（5.1.4項「デフォルト基底URI」を参照）が用いられます。</p>

<p>次のフラグメントは、同じIRIを記述する別々の方法の一部です。</p>

<pre class="data">
&lt;http://example.org/book/book1&gt;
</pre>
<pre class="data">
BASE &lt;http://example.org/book/&gt;
&lt;book1&gt;
</pre>
<pre class="data">
PREFIX book: &lt;http://example.org/book/&gt;
book:book1</pre>

<h4>4.1.2 <a id="QSynLiterals" name="QSynLiterals">リテラルの構文</a>
</h4>

<p>リテラルの一般的な構文は、言語タグのオプション（<code>@</code>で導入される）か、データ型IRIまたは接頭辞名のオプション（<code>^^</code>で導入される）かのどちらかを持つ文字列（ダブル引用符<code>&quot;...&quot;</code>、または、シングル引用符<code>&#39;...&#39;</code>で囲まれた)です。</p>

<p>便宜上、整数を直接記述（引用符と明示的なデータ型IRIなしに）でき、これはデータ型<code>xsd:integer</code>の型付きリテラルとして解釈され、数字の中に「.」があるけれども指数がない小数は<code>xsd:decimal</code>と解釈され、指数がある数は<code>xsd:double</code>と解釈されます。型<code>xsd:boolean</code>の値は、真（<code>true</code>）または偽（<code>false</code>）と記述できます。</p>

<p>自身に引用符を含む、または、長くて改行文字を含むリテラル値の記述を容易にするために、SPARQLでは、リテラルを3つのシングル引用符またはダブル引用符で囲んだ引用構成子も提供されています。</p>

<p>SPARQLのリテラル構文の例は、次のとおりです。</p>

<ul>
  <li><code>&quot;chat&quot;</code></li>
  <li>言語タグ「fr」を持つ<code>&#39;chat&#39;@fr</code>
</li>
  <li><code>&quot;xyz&quot;^^&lt;http://example.org/ns/userDatatype&gt;</code></li>
  <li><code>&quot;abc&quot;^^appNS:appDataType</code></li>
  <li><code>'''The librarian said, &quot;Perhaps you would enjoy &#39;War and Peace&#39;.&quot;'''</code></li>
  <li>
<code>1</code>、これは<code>&quot;1&quot;^^xsd:integer</code>と同じ</li>
  <li>
<code>1.3</code>、 これは<code>&quot;1.3&quot;^^xsd:decimal</code>と同じ</li>
  <li>
<code>1.300</code>、 これは<code>&quot;1.300&quot;^^xsd:decimal</code>と同じ</li>
  <li>
<code>1.0e6</code>、 これは<code>&quot;1.0e6&quot;^^xsd:double</code>と同じ</li>
  <li>
<code>true</code>、 これは<code>&quot;true&quot;^^xsd:boolean</code>と同じ</li>
  <li>
<code>false</code>、 これは<code>&quot;false&quot;^^xsd:boolean</code>と同じ</li>
</ul>
<div class="grammarExtract">
  文法規則:<div class="grammarTable">
    <table id="table110">
      <tr>
  <td><code class="gRuleLabel">[60]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rRDFLiteral">RDFLiteral</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rString">String</a> ( <a href="#rLANGTAG">LANGTAG</a> | ( <span class="token">'^^'</span> <a href="#rIRIref">IRIref</a> ) )?</code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[61]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rNumericLiteral">NumericLiteral</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rNumericLiteralUnsigned">NumericLiteralUnsigned</a> | 
  <br>  <a href="#rNumericLiteralPositive">NumericLiteralPositive</a> | <br>
  <a href="#rNumericLiteralNegative">NumericLiteralNegative</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[62]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rNumericLiteralUnsigned">NumericLiteralUnsigned</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rINTEGER">INTEGER</a> |	<a href="#rDECIMAL">DECIMAL</a> |	<a href="#rDOUBLE">DOUBLE</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[63]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rNumericLiteralPositive">NumericLiteralPositive</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rINTEGER_POSITIVE">INTEGER_POSITIVE</a> |	
  <br>
  <a href="#rDECIMAL_POSITIVE">DECIMAL_POSITIVE</a> |	<br>
  <a href="#rDOUBLE_POSITIVE">DOUBLE_POSITIVE</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[64]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rNumericLiteralNegative">NumericLiteralNegative</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rINTEGER_NEGATIVE">INTEGER_NEGATIVE</a> |	
  <br>
  <a href="#rDECIMAL_NEGATIVE">DECIMAL_NEGATIVE</a> |	<br>
  <a href="#rDOUBLE_NEGATIVE">DOUBLE_NEGATIVE</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[65]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rBooleanLiteral">BooleanLiteral</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'true'</span> |	<span class="token">'false'</span></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[66]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rString">String</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rSTRING_LITERAL1">STRING_LITERAL1</a> | <a href="#rSTRING_LITERAL2">STRING_LITERAL2</a> | 
  <br>  <a href="#rSTRING_LITERAL_LONG1">STRING_LITERAL_LONG1</a> | <a href="#rSTRING_LITERAL_LONG2">STRING_LITERAL_LONG2</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[76]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rLANGTAG">LANGTAG</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">'@' [a-zA-Z]+ ('-' [a-zA-Z0-9]+)*</code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[77]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rINTEGER">INTEGER</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">[0-9]+</code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[78]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rDECIMAL">DECIMAL</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">[0-9]+ '.' [0-9]* | '.' [0-9]+</code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[79]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rDOUBLE">DOUBLE</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">[0-9]+ '.' [0-9]* <a href="#rEXPONENT">EXPONENT</a> |<br>
  '.' ([0-9])+ <a href="#rEXPONENT">EXPONENT</a> |<br>
  ([0-9])+ <a href="#rEXPONENT">EXPONENT</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[80]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rINTEGER_POSITIVE">INTEGER_POSITIVE</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'+'</span> <a href="#rINTEGER">INTEGER</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[81]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rDECIMAL_POSITIVE">DECIMAL_POSITIVE</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'+'</span> <a href="#rDECIMAL">DECIMAL</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[82]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rDOUBLE_POSITIVE">DOUBLE_POSITIVE</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'+'</span> <a href="#rDOUBLE">DOUBLE</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[83]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rINTEGER_NEGATIVE">INTEGER_NEGATIVE</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'-'</span> <a href="#rINTEGER">INTEGER</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[84]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rDECIMAL_NEGATIVE">DECIMAL_NEGATIVE</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'-'</span> <a href="#rDECIMAL">DECIMAL</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[85]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rDOUBLE_NEGATIVE">DOUBLE_NEGATIVE</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'-'</span> <a href="#rDOUBLE">DOUBLE</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[86]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rEXPONENT">EXPONENT</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">[eE] [+-]? [0-9]+</code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[87]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rSTRING_LITERAL1">STRING_LITERAL1</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">"'" ( ([^#x27#x5C#xA#xD]) | <a href="#rECHAR">ECHAR</a> )* "'"</code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[88]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rSTRING_LITERAL2">STRING_LITERAL2</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">'"' ( ([^#x22#x5C#xA#xD]) | <a href="#rECHAR">ECHAR</a> )* '"'</code></td>
      </tr>
    </table>
  </div>
</div>
    <p>生成規則<a href="#rINTEGER">INTEGER</a>、<a href="#rDECIMAL">DECIMAL</a>、<a href="#rDOUBLE">DOUBLE</a>、<a href="#rBooleanLiteral">BooleanLiteral</a>にマッチするトークンは、トークンの字句値と、対応するデータ型（<code>xsd:integer</code>、<code>xsd:decimal</code>、<code>xsd:double</code>、<code>xsd:boolean</code>）を持つ型付きテラルと同等です。</p>

<h4>4.1.3 <a id="QSynVariables" name="QSynVariables">クエリ変数の構文</a>
</h4>

<p>SPARQLクエリのクエリ変数は、グローバルな範囲を持っています。与えられた変数名をクエリ内の任意の場所で用いると、同じ変数を識別します。変数の前には「?」か「$」のどちらかが置かれますが、「?」や「$」は変数名の一部ではありません。クエリでは、<code>$abc</code>と<code>?abc</code>は同じ変数を識別します。<a href="#grammar">SPARQL文法</a>では、変数に対して<a href="#rVARNAME">可能な名前</a>が与えられます。</p>

<div class="grammarExtract">
  文法規則:<div class="grammarTable">
    <table id="table111">
      <tr>
        <td><code class="gRuleLabel">[44]</code></td>
  <td><code class="gRuleHead"><a href="#rVar">Var</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rVAR1">VAR1</a> | <a href="#rVAR2">VAR2</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[74]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rVAR1">VAR1</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">'?' <a href="#rVARNAME">VARNAME</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[75]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rVAR2">VAR2</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">'$' <a href="#rVARNAME">VARNAME</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[97]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rVARNAME">VARNAME</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">( <a href="#rPN_CHARS_U">PN_CHARS_U</a>  | [0-9] ) ( <a href="#rPN_CHARS_U">PN_CHARS_U</a> | [0-9] | #x00B7 | [#x0300-#x036F] | [#x203F-#x2040] )*</code></td>
      </tr>
    </table>
  </div>
</div>

<h4>4.1.4 <a id="QSynBlankNodes" name="QSynBlankNodes">空白ノードの構文</a>
</h4>

<p>グラフ・パターンの<a class="norm" href="www.w3.org/TR/rdf-concepts/#section-blank-nodes">空白ノード</a>は、問い合わされたデータの特定の空白ノードの参照としてではなく、非識別変数として機能します。</p>

    <p>空白ノードは、「<code>_:abc</code>」などのラベル形式か、省略形「<code>[]</code>」のどちらかで示されます。クエリ構文の1箇所でしか使うことができない空白ノードは<code>[]</code>で示すことができます。ユニークな空白ノードは、トリプル・パターンを形成するために用いられるでしょう。ラベル「<code>abc</code>」を持つ空白ノードに対する空白ノード・ラベルは「<code>_:abc</code>」と書かれます。同じ空白ノード・ラベルは、同じクエリ内の2つの異なる基本グラフ・パターンに使用することはできません。</p>

<p><code>[:p :v]</code>構成子は、トリプル・パターンで用いることができます。これは、すべてを含んだ述語-目的語の対の主語として用いられる空白ノード・ラベルを作成します。作成された空白ノードは、さらに他のトリプル・パターンの主語と目的語の位置でも使用できます。</p>

<p>次の2つの形式</p>

<pre class="query untested">
[ :p &quot;v&quot; ] .
</pre>
<pre class="query untested">
[] :p &quot;v&quot; .
</pre>

<p>は、ユニークな空白ノード・ラベル（ここでは「<code>b57</code>」）を割り当てると、次の記述と同等です。</p>
<pre class="query untested">
_:b57 :p &quot;v&quot; .
</pre>

<p>割り当てられたこの空白ノード・ラベルは、さらに別のトリプル・パターンの主語または目的語として使用できます。例えば、主語として用いると次のようになります。</p>

<pre class="query untested">
[ :p &quot;v&quot; ] :q &quot;w&quot; .
</pre>

<p>これは、次の2つのトリプルと同等です。</p>

<pre class="query untested">
_:b57 :p &quot;v&quot; .
_:b57 :q &quot;w&quot; .
</pre>

<p>そして、目的語として用いると次のようになります。</p>

<pre class="query untested">
:x :q [ :p &quot;v&quot; ] .
</pre>

<p>これは、次の2つのトリプルと同等です。</p>

<pre class="query untested">
:x  :q _:b57 .
_:b57 :p &quot;v&quot; .
</pre>

<p>省略化された空白ノード構文は、<a href="#predObjLists">共通の主語</a>と<a href="#objLists">共通の述語</a>に対する他の省略語と組み合わせることができます。</p>
<pre class="query untested">
  [ foaf:name  ?name ;
    foaf:mbox  &lt;mailto:alice@example.org&gt; ]
</pre>

<p>これは、あるユニークに割り当てられた空白ノード・ラベル「<code>b18</code>」に対する次の基本グラフ・パターンの記述と同じです。</p>

<pre class="query untested">
  _:b18  foaf:name  ?name .
  _:b18  foaf:mbox  &lt;mailto:alice@example.org&gt; .
</pre>
<div class="grammarExtract">
  文法規則:<div class="grammarTable">
    <table id="table112">
      <tr>
  <td><code class="gRuleLabel">[39]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rBlankNodePropertyList">BlankNodePropertyList</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'['</span><a href="#rPropertyListNotEmpty">PropertyListNotEmpty</a><span class="token">']'</span></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[69]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rBlankNode">BlankNode</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rBLANK_NODE_LABEL">BLANK_NODE_LABEL</a> |	<a href="#rANON">ANON</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[73]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rBLANK_NODE_LABEL">BLANK_NODE_LABEL</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">'_:' <a href="#rPN_LOCAL">PN_LOCAL</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[94]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rANON">ANON</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">'['  <a href="#rWS">WS</a>* ']'</code></td>
      </tr>
    </table>
  </div>
</div>

<h3>4.2 <a id="QSynTriples" name="QSynTriples">トリプル・パターンの構文</a>
</h3>

<p><a href="#defn_TriplePattern">トリプル・パターン</a>は、スペースで区切られた主語、述語、目的語のリストとして書かれます。いくつかの共通するトリプル・パターン構成子を省略して書く方法があります。</p>

<p>次の例は、同じクエリを表します。</p>

<pre class="query">
PREFIX  dc: &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT  ?title
WHERE   { &lt;http://example.org/book/book1&gt; dc:title ?title }  
</pre>
<pre class="query">
PREFIX  dc: &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  : &lt;http://example.org/book/&gt;

SELECT  $title
WHERE   { :book1  dc:title  $title }
</pre>
<pre class="query">
BASE    &lt;http://example.org/book/&gt;
PREFIX  dc: &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT  $title
WHERE   { &lt;book1&gt;  dc:title  ?title }
</pre>
<div class="grammarExtract">文法規則:<div class="grammarTable">
  <table id="table113">
    <tr>
  <td><code class="gRuleLabel">[32]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rTriplesSameSubject">TriplesSameSubject</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rVarOrTerm">VarOrTerm</a> <a href="#rPropertyListNotEmpty">PropertyListNotEmpty</a> |<br>
  <a href="#rTriplesNode">TriplesNode</a> <a href="#rPropertyList">PropertyList</a></code></td>
    </tr>
    <tr>
  <td><code class="gRuleLabel">[33]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rPropertyListNotEmpty">PropertyListNotEmpty</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rVerb">Verb</a> <a href="#rObjectList">ObjectList</a> ( <span class="token">';'</span> ( <a href="#rVerb">Verb</a> <a href="#rObjectList">ObjectList</a> )? )*</code></td>
    </tr>
    <tr>
  <td><code class="gRuleLabel">[34]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rPropertyList">PropertyList</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rPropertyListNotEmpty">PropertyListNotEmpty</a>?</code></td>
    </tr>
    <tr>
  <td><code class="gRuleLabel">[35]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rObjectList">ObjectList</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rObject">Object</a> ( <span class="token">','</span> <a href="#rObject">Object</a> )*</code></td>
    </tr>
    <tr>
  <td><code class="gRuleLabel">[37]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rVerb">Verb</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rVarOrIRIref">VarOrIRIref</a> | <span class="token">'a'</span></code></td>
    </tr>
  </table>
  </div>
</div>

<h4>4.2.1 <a id="predObjLists" name="predObjLists">述語-目的語のリスト</a>
</h4>

<p>共通の主語を持つトリプル・パターンは、主語を1度だけ記述し、「<code>;</code>」表記法を用いて1つ以上のトリプル・パターンで用いられるように記述できます。</p>

<pre class="query untested">
    ?x  foaf:name  ?name ;
        foaf:mbox  ?mbox .
</pre>
<p>これは、次のトリプル・パターンの記述と同じです。</p>

<pre class="query untested">
    ?x  foaf:name  ?name .
    ?x  foaf:mbox  ?mbox .
</pre>

<h4>4.2.2 <a id="objLists" name="objLists">目的語のリスト</a>
</h4>

<p>トリプル・パターンが主語と述語の両方を共有する場合、目的語を「<code>,</code>」で区切ることができます。</p>

<pre class="query untested">
    ?x foaf:nick  &quot;Alice&quot; , &quot;Alice_&quot; .
</pre>

<p>上記は、次のトリプル・パターンの記述と同じです。</p>

<pre class="query untested">
   ?x  foaf:nick  &quot;Alice&quot; .
   ?x  foaf:nick  &quot;Alice_&quot; .
</pre>

<p>次のように、目的語のリストを述語-目的語のリストと組み合わせることができます。</p>

<pre class="query untested">
   ?x  foaf:name ?name ; foaf:nick  &quot;Alice&quot; , &quot;Alice_&quot; .
</pre>
<p>これは、次と同等です。</p>

<pre class="query untested">
   ?x  foaf:name  ?name .
   ?x  foaf:nick  &quot;Alice&quot; .
   ?x  foaf:nick  &quot;Alice_&quot; .
</pre>

<h4>4.2.3 <a id="collections" name="collections">RDFコレクション</a>
</h4>

<p>「(element1 element2 ...)」という構文を用いてトリプル・パターンに<a class="norm" href="www.w3.org/TR/2004/REC-rdf-mt-20040210/#collections">RDFコレクション</a>を記述できます。形式「<code>()</code>」は、<code><a href="www.w3.org/1999/02/22-rdf-syntax-ns#nil">http://www.w3.org/1999/02/22-rdf-syntax-ns#nil</a></code>というIRIの代替です。<code>(1 ?x 3 4)</code>のようなコレクション要素とともに用いれば、空白ノードを持つトリプル・パターンがコレクションに割り当てられます。コレクションの先頭の空白ノードは、他のトリプル・パターンの主語または目的語として使用できます。コレクション構文で割り当てられた空白ノードは、クエリのほかの場所では出現しません。</p>

<pre class="query untested">
(1 ?x 3 4) :p &quot;w&quot; .
</pre>

<p>上記は、次に対する糖衣構文です（<code>b0</code>、<code>b1</code>、<code>b2</code>、<code>b3</code>がクエリの他のどこかで出現しないことを意味する）。</p>

<pre class="query untested">
    _:b0  rdf:first  1 ;
          rdf:rest   _:b1 .
    _:b1  rdf:first  ?x ;
          rdf:rest   _:b2 .
    _:b2  rdf:first  3 ;
          rdf:rest   _:b3 .
    _:b3  rdf:first  4 ;
          rdf:rest   rdf:nil .
    _:b0  :p         &quot;w&quot; . </pre>

<p>RDFコレクションは、入れ子にすることができ、他の構文を含むことができます。</p>

<pre class="query untested">
(1 [:p :q] ( 2 ) ) .
</pre>

<p>上記は、次に対する糖衣構文です。</p>

<pre class="query untested">
    _:b0  rdf:first  1 ;
          rdf:rest   _:b1 .
    _:b1  rdf:first  _:b2 .
    _:b2  :p         :q .
    _:b1  rdf:rest   _:b3 .
    _:b3  rdf:first  _:b4 .
    _:b4  rdf:first  2 ;
          rdf:rest   rdf:nil .
    _:b3  rdf:rest   rdf:nil .
</pre>
<div class="grammarExtract">
  文法規則:<div class="grammarTable">
    <table id="table124">
      <tr>
  <td><code class="gRuleLabel">[40]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rCollection">Collection</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'('</span> <a href="#rGraphNode">GraphNode</a>+ <span class="token">')'</span></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[92]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rNIL">NIL</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">'(' <a href="#rWS">WS</a>* ')'</code></td>
      </tr>
    </table>
  </div>
</div>

<h4>4.2.4 <a name="abbrevRdfType" id="abbrevRdfType">rdf:type</a>
</h4>

<p>キーワード「<code>a</code>」は、トリプル・パターンで述語として使用でき、<code><a href="www.w3.org/1999/02/22-rdf-syntax-ns#type">http://www.w3.org/1999/02/22-rdf-syntax-ns#type</a></code>というIRIの代替です。このキーワードは大文字・小文字を区別します。</p>

<pre class="query untested">
  ?x  a  :Class1 .
  [ a :appClass ] :p &quot;v&quot; .
</pre>

<p>上記は、次に対する糖衣構文です。</p>

<pre class="query untested">
  ?x    rdf:type  :Class1 .
  _:b0  rdf:type  :appClass .
  _:b0  :p        &quot;v&quot; .
</pre>

<h2>5 <a id="GraphPattern" name="GraphPattern">グラフ・パターン</a>
</h2>

<p>SPARQLはグラフ・パターン・マッチングを基本としています。より複雑なグラフ・パターンは、小さなパターンを様々な方法で組み合わせて作成できます。</p>

<ul>
  <li>
<a href="#BasicGraphPatterns">基本グラフ・パターン</a>、1組のトリプル・パターンがマッチしなければなりません。</li>
  <li>
<a href="#GroupPatterns">グループ・グラフ・パターン</a>、1組のグラフ・パターンがすべてマッチしなければなりません。</li>
  <li>
<a href="#optionals">オプション・グラフ・パターン</a>、追加パターンによってソリューションを拡張することができます。</li>
  <li>
<a href="#alternatives">代替グラフ・パターン</a>、2つ以上の可能なパターンを試します。</li>
  <li>
<a href="#queryDataset">名前付きグラフのパターン</a>、パターンが名前付きグラフにマッチします。</li>
</ul>

<p>この項では、論理積でパターンを組み合わせる2つの形式について説明します。それらは、トリプル・パターンを組み合わせる基本グラフ・パターンと、他のすべてのパターンを組み合わせるグループ・グラフ・パターンです。</p>

    <p>最も外側のクエリのグラフ・パターンは、クエリ・パターンと呼ばれます。これは、文法上、次の<code>GroupGraphPattern</code>で識別されます。</p>

<div class="grammarExtract">
  <div class="grammarTable">
    <table>
  <tr valign="baseline">
    <td><code class="gRuleLabel">[13]&nbsp;&nbsp;</code></td>
    <td><code class="gRuleHead"><a href="#rWhereClause">WhereClause</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code class="gRuleBody"><span class="token">'WHERE'</span>? <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
  </tr>
    </table>
  </div>
</div>

<h3>5.1 <a id="BasicGraphPatterns" name="BasicGraphPatterns">基本グラフ・パターン</a>
</h3>

<p>基本グラフ・パターンはトリプル・パターンの集合です。SPARQLのグラフ・パターン・マッチングは、マッチした基本グラフ・パターンの結果を組み合わせるという観点で定義されます。</p>

<p>フィルタの割り込みがあったトリプル・パターンのシーケンスは、1つの基本グラフ・パターンから成ります。任意のグラフ・パターンが、基本グラフ・パターンを終了させます。</p>

<h4>5.1.1 <a id="bgpBNodeLabels" name="bgpBNodeLabels">空白ノード・ラベル</a>
</h4>

<p>形式<code>_:abc</code>の空白ノードを用いるときには、空白ノードのラベルは基本グラフ・パターンで有効です。1つのラベルは、任意のクエリにおける1つの基本グラフ・パターンのみで使用できます。</p>

<h4>5.1.2 <a id="bgpExtend" name="bgpExtend">基本グラフ・パターン・マッチングの拡張</a>
</h4>

<p>SPARQLは、RDFグラフをシンプルな含意にマッチさせるために定義されます。<a href="#sparqlBGPExtend">以下の記述</a>のような、ある特定の状況が与えられれば、SPARQLを他の形式の含意に拡張できます。</p>

<h3>5.2 <a id="GroupPatterns" name="GroupPatterns">グループ・グラフ・パターン</a>
</h3>

<p>SPARQLのクエリ文字列では、グループ・グラフ・パターンは中括弧（<code>{}</code>）で区切られます。例えば、このクエリのクエリ・パターンは、1つの基本グラフ・パターンからなるグループ・グラフ・パターンです。</p>

<div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">
PREFIX foaf:&nbsp;&nbsp;&nbsp; &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?x foaf:name ?name .
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?x foaf:mbox ?mbox .
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
</pre>
</div>
</div>
<div class="exampleGroup">

  <div class="queryGroup">トリプル・パターンを2つの基本グラフ・パターンにグルーピングしたクエリから同じソリューションが得られるでしょう。例えば、次のクエリは、異なる構造を持っていますが、上記のクエリと同じソリューションをもたらすでしょう。
    <pre class="query">
PREFIX foaf:&nbsp;&nbsp;&nbsp; &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE&nbsp; { { ?x foaf:name ?name . }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { ?x foaf:mbox ?mbox . }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</pre>
</div>
</div>
<div class="grammarExtract">
  文法規則:<div class="grammarTable">
  <table id="table118">
    <tbody>
      <tr>
	<td>
	  <code class="gRuleLabel">[20]&nbsp;&nbsp;</code>
	</td>
	<td>
	  <code class="gRuleHead"><a href="#rGroupGraphPattern">GroupGraphPattern</a></code>
	</td>
	<td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
	<td>
	  <code class="gRuleBody"><span class="token">'{'</span> <a href="#rTriplesBlock">TriplesBlock</a>? ( ( <a href="#rGraphPatternNotTriples">GraphPatternNotTriples</a> | <a href="#rFilter">Filter</a> ) <span class="token">'.'</span>? <a href="#rTriplesBlock">TriplesBlock</a>? )* <span class="token">'}'</span></code>
	</td>
      </tr>
      <tr>
	<td>
	  <code class="gRuleLabel">[21]&nbsp;&nbsp;</code>
	</td>
	<td>
	  <code class="gRuleHead"><a href="#rTriplesBlock">TriplesBlock</a></code>
	</td>
	<td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
	<td>
<code class="gRuleBody"><a href="#rTriplesSameSubject">TriplesSameSubject</a> ( <span class="token">'.'</span> <a href="#rTriplesBlock">TriplesBlock</a>? )?</code>
	</td>
      </tr>
      <tr>
	<td><code class="gRuleLabel">[22]&nbsp;&nbsp;</code></td>
	<td><code class="gRuleHead"><a href="#rGraphPatternNotTriples">GraphPatternNotTriples</a></code></td>
	<td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
	<td>
	  <code class="gRuleBody"><a href="#rOptionalGraphPattern">OptionalGraphPattern</a> | <a href="#rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</a> | <a href="#rGraphGraphPattern">GraphGraphPattern</a></code>
	</td>
      </tr>
    </tbody>
  </table>
  </div>
</div>
  
<h4>5.2.1 <a name="emptyGroupPattern" id="emptyGroupPattern">空のグループ・パターン</a>
</h4>

<p>グループ・パターン</p>

<pre class="query untested">{ }</pre>

<p>は、任意のグラフ（空のグラフを含む）を、変数をバインドしない1つのソリューションにマッチさせます。例えば、</p>

<pre class="query untested">
SELECT ?x
WHERE {}
</pre>

<p>は、変数<code>x</code>がバインドされていない1つのソリューションとマッチします。</p>

<h4>5.2.2 <a name="scopeFilters" id="scopeFilters">フィルタの範囲</a>
</h4>

<p><code>FILTER</code>キーワードによって表される制約は、フィルタが出現するすべてのグループにまたがるソリューションに対する制限です。次のパターンはすべて、同じソリューションを持ちます。</p>

<div class="exampleGroup">
<div class="queryGroup">
  <pre class="query">
&nbsp;{&nbsp; ?x foaf:name ?name .
    ?x foaf:mbox ?mbox .
&nbsp;&nbsp;&nbsp; FILTER regex(?name, &quot;Smith&quot;)
 }
  </pre>
</div>
</div>

<div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">&nbsp;{&nbsp; FILTER regex(?name, &quot;Smith&quot;)
    ?x foaf:name ?name .
    ?x foaf:mbox ?mbox .
&nbsp;}
</pre>
</div>
</div>
<div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">&nbsp;{&nbsp; ?x foaf:name ?name .
&nbsp;&nbsp;&nbsp; FILTER regex(?name, &quot;Smith&quot;)
    ?x foaf:mbox ?mbox .
 }
</pre>
</div>
</div>

<h4>5.2.3 <a id="groupExamples" name="groupExamples">グループ・グラフ・パターンの例</a>
</h4>

<div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">
&nbsp; {
&nbsp;&nbsp;&nbsp; ?x foaf:name ?name .
&nbsp;&nbsp;&nbsp; ?x foaf:mbox ?mbox .
&nbsp; }</pre>
  </div>
</div>

<p>は、1つの基本グラフ・パターンからなるグループで、その基本グラフ・パターンは、2つのトリプル・パタ
ーンから構成されています。</p>

<div class="exampleGroup">
    <div class="queryGroup">
      <pre class="query">
&nbsp; {
&nbsp;&nbsp;&nbsp; ?x foaf:name ?name . FILTER regex(?name, &quot;Smith&quot;)
&nbsp;&nbsp;&nbsp; ?x foaf:mbox ?mbox .
&nbsp; }</pre>

</div>
</div>

<p>は、1つの基本グラフ・パターンとフィルタからなるグループで、その基本グラフ・パターンは、2つのトリプル・パターンから構成されています。フィルタは基本グラフ・パターンを2つの基本グラフ・パターンに分割しません。</p>

<div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">
&nbsp; {
&nbsp;&nbsp;&nbsp; ?x foaf:name ?name .
&nbsp;&nbsp;&nbsp; {}
&nbsp;&nbsp;&nbsp; ?x foaf:mbox ?mbox .
&nbsp; }</pre>
</div>
</div>

<p>は、1つのトリプル・パターンからなる基本グラフ・パターン、空のグループ、1つのトリプル・パターンからなる別の基本グラフ・パターンという、3つの要素のグループです。</p>

<h2>6 <a id="optionals" name="optionals">オプション値の組み込み</a>
</h2>

<p>基本グラフ・パターンでは、アプリケーションは、ソリューションが生成されるようにクエリ・パターンの全体がマッチしなければならないようなクエリを作成できます。少なくとも1つの基本グラフ・パターンを持つグループ・グラフ・パターンのみを含むクエリのすべてのソリューションでは、すべての変数は、あるソリューションのあるRDF用語にバインドされます。しかし、すべてのRDFグラフにおいて、正規の、完全な構成を想定することはできません。情報が利用できるソリューションに情報を追加できるクエリを持つことができると便利ですが、クエリ・パターンの一部がマッチしないという理由でソリューションを拒絶すべきではありません。オプションのマッチングは、この機能を提供します。オプション部分がマッチしない場合は、バインディングを作成しませんが、ソリューションは排除しません。</p>

<h3>6.1 <a id="OptionalMatching" name="OptionalMatching">オプションのパターン・マッチング</a>
</h3>

<p>グラフ・パターンのオプション部分は、次のグラフ・パターンに当てはまるOPTIONALキーワードで構文的に指定されます。</p>

<pre class="query untested">
<i>pattern</i> OPTIONAL { <i>pattern</i> }
</pre>
<div class="exampleGroup">

  <p>構文形式</p>

<pre class="query untested">
{ OPTIONAL { <i>pattern</i> } }
</pre>

<p>は次と同等です。</p>

<pre class="query untested">
{ { } OPTIONAL { <i>pattern</i> } }
</pre>
<div class="grammarExtract">
  文法規則:<div class="grammarTable">
    <table id="table116">
      <tr>
  <td><code class="gRuleLabel">[23]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rOptionalGraphPattern">OptionalGraphPattern</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'OPTIONAL'</span> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
      </tr>
    </table>
  </div>
</div>

<p><code>OPTIONAL</code>キーワードは左結合的で、</p>

<pre class="query untested">
<i>pattern</i> OPTIONAL { <i>pattern</i> } OPTIONAL { pattern }
</pre>

<p>次と同じです。</p>

<pre class="query untested">
{ <i>pattern</i> OPTIONAL { <i>pattern</i> } } OPTIONAL { pattern }
</pre>

  <p>オプションのマッチでは、オプションのグラフ・パターンがグラフにマッチし、その結果、1つ以上のソリューションに対し、バインディングを定義し追加するか、追加のバインディングを加えずにソリューションをそのままにします。</p>

  <p>データ:</p>
  <pre class="data">
@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix rdf:        &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .

_:a  rdf:type        foaf:Person .
_:a  foaf:name       &quot;Alice&quot; .
_:a  foaf:mbox       &lt;mailto:alice@example.com&gt; .
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  rdf:type        foaf:Person .
_:b  foaf:name       &quot;Bob&quot; .
</pre>
  <div class="queryGroup">
    クエリ:<pre class="query">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE  { ?x foaf:name  ?name .
         OPTIONAL { ?x  foaf:mbox  ?mbox }
       }
</pre>
    <p>上記のデータを用いると、クエリ結果は次の通りです。</p>

    <div class="result">
      <table class="resultTable" id="table92">
        <tr>
          <th>name</th>
          <th>mbox</th>
        </tr>
        <tr>
          <td>&quot;Alice&quot;</td>
          <td>&lt;mailto:alice@example.com&gt;</td>
        </tr>
        <tr>
          <td>&quot;Alice&quot;</td>
          <td>&lt;mailto:alice@work.example&gt;</td>
        </tr>
        <tr>
          <td>&quot;Bob&quot;</td>
          <td></td>
        </tr>
      </table>
    </div>
  </div>
</div>

<p>名前が<code>&quot;Bob&quot;</code>であるソリューションの<code>mbox</code>の値はありません。</p>

<p>このクエリはデータ内の人名を発見します。述語<code>mbox</code>と、同じ主語を持つトリプルがある場合、ソリューションにはそのトリプルの目的語も含まれるでしょう。この例では、クエリのオプションのマッチ部分では1つのトリプル・パターンのみが得られますが、一般に、オプションの部分は任意のグラフ・パターンでありえます。オプションのグラフ・パターンの全体は、クエリのソリューションに影響するように、オプションのグラフ・パターンにマッチしなければなりません。</p>

<h3>6.2 <a id="OptionalAndConstraints" name="OptionalAndConstraints">オプションのパターン・マッチングにおける制約</a>
</h3>

<p>オプションのグラフ・パターンでは、制約を付与できます。例えば、次のとおりです。</p>

<div class="exampleGroup">
  <pre class="data">@prefix dc:   &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix :     &lt;http://example.org/book/&gt; .
@prefix ns:   &lt;http://example.org/ns#&gt; .

:book1  dc:title  &quot;SPARQL Tutorial&quot; .
:book1  ns:price  42 .
:book2  dc:title  &quot;The Semantic Web&quot; .
:book2  ns:price  23 .
</pre>
  <div class="queryGroup">
    <pre class="query">
PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  ns:  &lt;http://example.org/ns#&gt;
SELECT  ?title ?price
WHERE   { ?x dc:title ?title .
          OPTIONAL { ?x ns:price ?price . FILTER (?price &lt; 30) }
        }
</pre>
    <div class="result">
      <table class="resultTable" id="table93">
        <tr>
          <th>title</th>
          <th>price</th>
        </tr>
        <tr>
          <td>&quot;SPARQL Tutorial&quot;</td>
          <td></td>
        </tr>
        <tr>
          <td>&quot;The Semantic Web&quot;</td>
          <td>23</td>
        </tr>
      </table>
    </div>
  </div>
</div>

<p>「SPARQL Tutorial」というタイトルの本には、価格が表示されません。なぜならば、オプションのグラフ・パターンが変数「<code>price</code>」を伴うソリューションをもたらさなかったからです。</p>

<h3>6.3 <a id="MultipleOptionals" name="MultipleOptionals">複数のオプションのグラフ・パターン</a>
</h3>

<p>グラフ・パターンは再帰的に定義されます。グラフ・パターンは0以上のオプションのグラフ・パターンを持つことができ、クエリ・パターンのどの部分もオプション部分を持つことができます。この例には、2つのオプションのグラフ・パターンがあります。</p>

<div class="exampleGroup">
  データ:<pre class="data">
@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       &quot;Alice&quot; .
_:a  foaf:homepage   &lt;http://work.example.org/alice/&gt; .

_:b  foaf:name       &quot;Bob&quot; .
_:b  foaf:mbox       &lt;mailto:bob@work.example&gt; .
</pre>
  <div class="queryGroup">
    クエリ:<pre class="query">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox ?hpage
WHERE  { ?x foaf:name  ?name .
         OPTIONAL { ?x foaf:mbox ?mbox } .
         OPTIONAL { ?x foaf:homepage ?hpage }
       }
</pre>
    <p>クエリ結果:</p>
    <div class="result">
      <table class="resultTable" id="table94">
        <tr>
          <th>name</th>
          <th>mbox</th>
          <th>hpage</th>
        </tr>
        <tr>
          <td>&quot;Alice&quot;</td>
          <td></td>
          <td>&lt;http://work.example.org/alice/&gt;</td>
        </tr>
        <tr>
          <td>&quot;Bob&quot;</td>
          <td>&lt;mailto:bob@work.example&gt;</td>
          <td></td>
        </tr>
      </table>
    </div>
  </div>
</div>

<h2>7 <a id="alternatives" name="alternatives">代替のマッチング</a>
</h2>

<p>SPARQLは、いくつかの代替グラフ・パターンの1つがマッチするようにグラフ・パターンを組み合わせる方法を備えています。1つ以上の代替がマッチすれば、すべてのありえるパターンのソリューションが見つかります。</p>

<p>パターン代替は、<code>UNION</code>キーワードで構文的に指定されます。</p>

<div class="exampleGroup">
  データ:<pre class="data">
@prefix dc10:  &lt;http://purl.org/dc/elements/1.0/&gt; .
@prefix dc11:  &lt;http://purl.org/dc/elements/1.1/&gt; .

_:a  dc10:title     &quot;SPARQL Query Language Tutorial&quot; .
_:a  dc10:creator   &quot;Alice&quot; .

_:b  dc11:title     &quot;SPARQL Protocol Tutorial&quot; .
_:b  dc11:creator   &quot;Bob&quot; .

_:c  dc10:title     &quot;SPARQL&quot; .
_:c  dc11:title     &quot;SPARQL (updated)&quot; .
</pre>
  <div class="queryGroup">
    クエリ:<pre class="query">
PREFIX dc10:  &lt;http://purl.org/dc/elements/1.0/&gt;
PREFIX dc11:  &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?title
WHERE  { { ?book dc10:title  ?title } UNION { ?book dc11:title  ?title } }
</pre>
    <p>クエリ結果:</p>
    <div class="result">
      <table class="resultTable" id="table97">
        <tr>
          <th>title</th>
        </tr>
        <tr>
          <td>&quot;SPARQL Protocol Tutorial&quot;</td>
        </tr>
        <tr>
          <td>&quot;SPARQL&quot;</td>
        </tr>
        <tr>
          <td>&quot;SPARQL (updated)&quot;</td>
        </tr>
        <tr>
          <td>&quot;SPARQL Query Language Tutorial&quot;</td>
        </tr>      </table>    </div>
  </div>

  <p>このクエリは、バージョン1.0、バージョン1.1のどちらの<a class="inform" href="dublincore.org/">ダブリン・コア</a>のプロパティーを用いてタイトルが記録されているかに関係なく、データ中の本のタイトルを発見します。情報の記録方法を厳密に判別するために、クエリは2つの代替に対して異なる変数を用いることができます。</p> 

  <div class="queryGroup">
    <pre class="query">
PREFIX dc10:  &lt;http://purl.org/dc/elements/1.0/&gt;
PREFIX dc11:  &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?x ?y
WHERE  { { ?book dc10:title ?x } UNION { ?book dc11:title  ?y } }
</pre>
    <div class="result">
      <table class="resultTable" id="table98">
        <tr>
          <th>x</th>
          <th>y</th>
        </tr>
        <tr>
          <td></td>
          <td>&quot;SPARQL (updated)&quot;</td>
        </tr>
        <tr>
          <td></td>
          <td>&quot;SPARQL Protocol Tutorial&quot;</td>
        </tr>        <tr>          <td>&quot;SPARQL&quot;</td>
          <td></td>
        </tr>
        <tr>
          <td>&quot;SPARQL Query Language Tutorial&quot;</td>
          <td></td>
        </tr>
      </table>
    </div>
  </div>

  <p>これは、<code>UNION</code>の左辺のソリューションにバインドされた変数<code>x</code>と、右辺のソリューションにバインドされた<code>y</code>を持った結果を返すでしょう。<code>UNION</code>パターンのどちらの部分にもマッチしない場合、グラフ・パターンはマッチしないでしょう。</p>

  <p><code>UNION</code>パターンはグラフ・パターンを組み合わせます。それぞれの代替に、1つ以上のトリプル・パターンを含むことができます。</p>

  <div class="queryGroup">
    <pre class="query">
PREFIX dc10:  &lt;http://purl.org/dc/elements/1.0/&gt;
PREFIX dc11:  &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?title ?author
WHERE  { { ?book dc10:title ?title .  ?book dc10:creator ?author }
         UNION
         { ?book dc11:title ?title .  ?book dc11:creator ?author }
       }
</pre>
    <div class="result">
      <table class="resultTable" id="table99">
        <tr>
          <th>author</th>
          <th>title</th>
        </tr>
        <tr>
          <td>&quot;Alice&quot;</td>
          <td>&quot;SPARQL Protocol Tutorial&quot;</td>
        </tr>
        <tr>
          <td>&quot;Bob&quot;</td>
          <td>&quot;SPARQL Query Language Tutorial&quot;</td>
        </tr>      </table>
    </div>
  </div>
</div>

<p>ダブリン・コアの同じバージョンのタイトルと著者の両方の述語がある場合にのみ、このクエリは本にマッチするでしょう。</p>

<div class="grammarExtract">
  文法規則:<div class="grammarTable">
    <table id="table117">
      <tr>
  <td><code class="gRuleLabel">[25]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rGroupGraphPattern">GroupGraphPattern</a> 
  <br>
  ( <span class="token">'UNION'</span> <a href="#rGroupGraphPattern">GroupGraphPattern</a> )*</code></td>
      </tr>
    </table>
  </div>
</div>

<h2>8 <a id="rdfDataset" name="rdfDataset">RDFデータセット</a>
</h2>

<p>RDFデータ・モデルは、主語、述語、目的語のトリプルから成るグラフとして情報を表します。多くのRDFデータを蓄積すると、複数のRDFグラフと各グラフに関する記録情報が保持され、それによって、アプリケーションは1つ以上のグラフの情報を含むクエリを作成できます。</p>

<p>SPARQLのクエリは、グラフのコレクションを表す<em>RDFデータセット</em>に対して実行されます。1つのRDFデータセットは、名前のない1つのグラフ（デフォルト・グラフ）と、名前付きグラフがそれぞれにIRIで識別される0以上の名前付きグラフから成ります。SPARQLのクエリは、<a href="#queryDataset">8.3 データセットのクエリ</a>の項で述べるように、クエリ・パターンの異なる部分を異なるグラフに対してマッチさせることができます。</p>

<p>RDFデータセットには、0の名前付きグラフを含むことができます。RDFデータセットには、常に1つのデフォルト・グラフが含まれます。クエリは、デフォルト・グラフのマッチングを含る必要はありません。クエリは、名前付きグラフのマッチングを含むことができるだけです。</p>

<p>基本グラフ・パターンをマッチングさせるために用いるグラフは、<i>アクティブ・グラフ</i>です。前項までは、すべてのクエリは、アクティブ・グラフとしてのRDFデータセットのデフォルト・グラフである、1つのグラフに対して実行したものを示してきました。<code>GRAPH</code>キーワードは、アクティブ・グラフを、クエリの一部に対するデータセット内のすべての名前付きグラフのうちの1つにするために用いられます。</p>

<h3>8.1 <a name="exampleDatasets" id="exampleDatasets">RDFデータセットの例</a>
</h3>

<p>RDFデータセットの定義は、名前付きグラフとデフォルト・グラフの関係を制限しません。異なるグラフで情報を繰り返すことができ、グラフ間の関係を公開できます。次の2つの有益な処理があります。</p>

<ul>
  <li>名前付きグラフに関する来歴情報を含む情報をデフォルト・グラフに持つこと</li>
  <li>名前付きグラフの情報をデフォルト・グラフに含むこと</li>
</ul>
<div class="exampleGroup">
  <b>例1:</b><pre class="data">
# <b>Default graph</b>
@prefix dc: &lt;http://purl.org/dc/elements/1.1/&gt; .

&lt;http://example.org/bob&gt;    dc:publisher  &quot;Bob&quot; .
&lt;http://example.org/alice&gt;  dc:publisher  &quot;Alice&quot; .
</pre>
  <pre class="data">
# <b>Named graph: http://example.org/bob</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name &quot;Bob&quot; .
_:a foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .
</pre>
  <pre class="data">
# <b>Named graph: http://example.org/alice</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name &quot;Alice&quot; .
_:a foaf:mbox &lt;mailto:alice@work.example.org&gt; .
</pre>
</div>

<p>この例では、デフォルト・グラフには、2つの名前付きグラフの公開者名が含まれています。名前付きグラフのトリプルは、この例のデフォルト・グラフでは表示されません。</p>

<p id="ex_2"><b>例2:</b></p>

<p>RDFデータは、グラフの<a class="norm" href="www.w3.org/TR/rdf-mt/#graphdefs">RDFマージ</a>[<a href="#RDF-MT">RDF-MT</a>]によって組み合わすことができます。RDFデータセットにおける、グラフの1つの可能な処理は、デフォルト・グラフを名前付きグラフの情報の一部またはすべてのRDFマージにすることです。</p>

<p>次の例では、名前付きグラフには、以前と同じトリプルが含まれています。RDFデータセットは、デフォルト・グラフに名前付きグラフのRDFマージを含んでおり、再ラベル付けを行って空白ノードを異なったものにしておきます。</p>

<div class="exampleGroup">
  <pre class="data">
# <b>Default graph</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:x foaf:name &quot;Bob&quot; .
_:x foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .

_:y foaf:name &quot;Alice&quot; .
_:y foaf:mbox &lt;mailto:alice@work.example.org&gt; .
</pre>
  <pre class="data">
# <b>Named graph: http://example.org/bob</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name &quot;Bob&quot; .
_:a foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .
</pre>  <pre class="data">
# <b>Named graph: http://example.org/alice</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name &quot;Alice&quot; .
_:a foaf:mbox &lt;<a href="mailto:alice@work.example">mailto:alice@work.example</a>&gt; .</pre>

  <p>RDFマージでは、マージされたグラフの空白ノードと、マージされているグラフからの空白ノードとは共有されません。</p>

</div>

<h3>8.2 <a id="specifyingDataset" name="specifyingDataset">RDFデータセットの指定</a>
</h3>

<p>SPARQLクエリは、RDFデータセットを記述するために、<code>FROM</code>句と<code>FROM NAMED</code>句を用いて、マッチングに用いるデータセットを指定できます。クエリがそのようなデータセットの記述を提供していれば、それは、データセットの記述がクエリで提供されない場合にクエリ・サービスが使用する任意のデータセットの代わりに使用しています。また、RDFデータセットは、<a class="inform" href="www.w3.org/TR/rdf-sparql-protocol/#specify-dataset">SPARQLプロトコル要求で指定</a>することもできます。その場合、プロトコルの記述により、クエリ自体のあらゆる記述は無効になります。クエリ・サービスがデータセットの記述を許容できない場合には、サービスはクエリ要求を拒否するかもしれません。</p>

<p><code>FROM</code>と<code>FROM NAMED</code>キーワードによって、クエリは参照によってRDFデータセットを指定できます。これは、データセットが、与えられたIRI（すなわち、与えられたIRI参照の絶対形式）によって識別された資源の表現から得られるグラフを含むべきであるということを示しています。いくつかの<code>FROM</code>と<code>FROM NAMED</code>句から生じるデータセットは次の通りです。</p>

<ul>
  <li>
<code>FROM</code>句で参照されたグラフのRDFマージから成るデフォルト・グラフ、および</li>
  <li>1組（IRI、グラフ）の対で、各<code>FROM NAMED</code>句から1つずつ。</li>
</ul>

<p><code>FROM</code>句はないけれども複数の<code>FROM NAMED</code>句がある場合は、データセットにはデフォルト・グラフに対する空のグラフが含まれています。</p>

<div class="grammarExtract">
  文法規則:<div class="grammarTable">
    <table id="table101">
      <tr>
  <td><code class="gRuleLabel">[9]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rDatasetClause">DatasetClause</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'FROM'</span> ( <a href="#rDefaultGraphClause">DefaultGraphClause</a> | <a href="#rNamedGraphClause">NamedGraphClause</a> )</code></td>
      </tr>      <tr>
  <td><code class="gRuleLabel">[10]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rDefaultGraphClause">DefaultGraphClause</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rSourceSelector">SourceSelector</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[11]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rNamedGraphClause">NamedGraphClause</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'NAMED'</span> <a href="#rSourceSelector">SourceSelector</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[12]&nbsp;&nbsp;</code></td>  <td><code class="gRuleHead"><a href="#rSourceSelector">SourceSelector</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rIRIref">IRIref</a></code></td>
      </tr>
    </table>
  </div>
</div>

<h4>8.2.1 <a id="unnamedGraph" name="unnamedGraph">デフォルト・グラフの指定</a>
</h4>

<p>各<code>FROM</code>句には、デフォルト・グラフを作成するために用いるグラフを示すIRIが含まれています。これは、グラフを名前付きグラフとして位置づけるものではありません。</p>

<p>この例では、RDFデータセットは、1つのデフォルト・グラフを含み、名前付きグラフを含んでいません。</p>

<div class="exampleGroup">  <pre class="data">
<b># Default graph (stored at http://example.org/foaf/aliceFoaf)
</b>@prefix  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name     &quot;Alice&quot; .
_:a  foaf:mbox     &lt;mailto:alice@work.example&gt; .
</pre>
  <div class="queryGroup">
    <pre class="query">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT  ?name
FROM    &lt;http://example.org/foaf/aliceFoaf&gt;
WHERE   { ?x foaf:name ?name }
</pre>
    <div class="result">
      <table class="resultTable" id="table102">
        <tr>
          <th>name</th>
        </tr>
        <tr>
          <td>&quot;Alice&quot;</td>
        </tr>
      </table>
    </div>
  </div>
</div>

<p>クエリが1つ以上の<code>FROM</code>句を提供し、デフォルト・グラフを示すために1つ以上のIRIを提供する場合、デフォルト・グラフは与えられたIRIによって識別される資源の表現から得られたグラフの<a class="norm" href="www.w3.org/TR/rdf-mt/#graphdefs">RDFマージ</a>に基づいています。</p>

<h4>8.2.2 <a id="namedGraphs" name="namedGraphs">名前付きグラフの指定</a>
</h4>

<p><code>FROM NAMED</code>句を用いれば、クエリは、RDFデータセットの名前付きグラフにIRIを提供できます。各IRIは、RDFデータセットの1つの名前付きグラフを提供するために用いられます。2つ以上の<code>FROM NAMED</code>句で同じIRIを用いると、データセットに現れる当該IRIを持つ1つの名前付きグラフになります。</p>

<pre class="data"><b># Graph: http://example.org/bob</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name &quot;Bob&quot; .
_:a foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .
</pre>
<pre class="data"># <b>Graph: http://example.org/alice</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name &quot;Alice&quot; .
_:a foaf:mbox &lt;mailto:alice@work.example&gt; .</pre>
<div class="queryGroup">
  <pre class="query">...
FROM NAMED &lt;http://example.org/alice&gt;
FROM NAMED &lt;http://example.org/bob&gt;
...</pre>
</div>

<p><code>FROM NAMED</code>構文は、IRIが対応するグラフを識別するということを示唆しますが、RDFデータセットのIRIとグラフとの関係は間接的です。IRIが資源を識別し、資源はグラフで（あるいは、より正確には、グラフをシリアル化したドキュメントで）表されます。<a class="inform" href="www.w3.org/TR/webarch/#intro">詳細</a>については[<a href="#WEBARCH">WEBARCH</a>]を参照してください。</p>

<h4>8.2.3 <a id="specDataset" name="specDataset">FROMとFROM NAMEDの結合</a>
</h4>

<p><code>FROM</code>句と<code>FROM NAMED</code>句は、同じクエリ内で使用できます。</p>

<div class="exampleGroup">  <pre class="data">
# <b>Default graph (stored at http://example.org/dft.ttl)
</b>@prefix dc: &lt;http://purl.org/dc/elements/1.1/&gt; .

&lt;http://example.org/bob&gt;    dc:publisher  &quot;Bob Hacker&quot; .
&lt;http://example.org/alice&gt;  dc:publisher  &quot;Alice Hacker&quot; .
</pre>  <pre class="data">
# <b>Named graph: http://example.org/bob</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name &quot;Bob&quot; .
_:a foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .
</pre>
  <pre class="data">
# <b>Named graph: http://example.org/alice</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name &quot;Alice&quot; .
_:a foaf:mbox &lt;mailto:alice@work.example.org&gt; .
</pre>
    <pre class="query">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?who ?g ?mbox
FROM &lt;http://example.org/dft.ttl&gt;
FROM NAMED &lt;http://example.org/alice&gt;
FROM NAMED &lt;http://example.org/bob&gt;
WHERE
{
   ?g dc:publisher ?who .
   GRAPH ?g { ?x foaf:mbox ?mbox }
}
</pre>
</div>

<p>このクエリに対するRDFデータセットには、1つのデフォルト・グラフと2つの名前付きグラフが含まれています。<code>GRAPH</code>キーワードに関しては、以下で説明しています。</p>

<p>データセットを構築するために必要なアクションは、データセットの記述のみでは決められません。2つの<code>FROM</code>句、または、1つの<code>FROM</code>句と1つの<code>FROM NAMED</code>句を用いてデータセットの記述にIRIが2度付与されている場合は、きっかり1回または、きっかり2回の試みでIRIに関連付けられた1つのRDFグラフを得たとは想定しません。したがって、データセットの記述に存在する2つから得られたトリプル中の空白ノードのアイデンティティに関する想定を行えません。概して、グラフの同等性に関する想定を行えません。</p>

<h3>8.3 <a id="queryDataset" name="queryDataset">データセットのクエリ実行</a>
</h3>

<p>グラフのコレクションにクエリを実行する際には、<code>GRAPH</code>キーワードを用いて、名前付きグラフに対してパターンをマッチングさせます。<code>GRAPH</code>は、IRIを提供して1つのグラフを選択するか、クエリのRDFデータセット内のすべての名前付きグラフのIRIの範囲をカバーする変数を使用できます。</p>

<p><code>GRAPH</code>を用いれば、クエリの一部で基本グラフ・パターンをマッチングさせるためのアクティブ・グラフが変更されます。<code>GRAPH</code>を用いない場合は、デフォルト・グラフは基本グラフ・パターンによってマッチングされます。</p>

<p>以下の例では、次の2つのグラフを用います。</p>

<div class="exampleGroup">
  <pre class="data">
<b># Named graph: http://example.org/foaf/aliceFoaf
</b>@prefix  foaf:     &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix  rdf:      &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix  rdfs:     &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .

_:a  foaf:name     &quot;Alice&quot; .
_:a  foaf:mbox     &lt;mailto:alice@work.example&gt; .
_:a  foaf:knows    _:b .

_:b  foaf:name     &quot;Bob&quot; .
_:b  foaf:mbox     &lt;mailto:bob@work.example&gt; .
_:b  foaf:nick     &quot;Bobby&quot; .
_:b  rdfs:seeAlso  &lt;http://example.org/foaf/bobFoaf&gt; .

&lt;http://example.org/foaf/bobFoaf&gt;
     rdf:type      foaf:PersonalProfileDocument .
</pre>
  <pre class="data">
<b># Named graph: http://example.org/foaf/bobFoaf
</b>@prefix  foaf:     &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix  rdf:      &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix  rdfs:     &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .

_:z  foaf:mbox     &lt;mailto:bob@work.example&gt; .
_:z  rdfs:seeAlso  &lt;http://example.org/foaf/bobFoaf&gt; .
_:z  foaf:nick     &quot;Robert&quot; .

&lt;http://example.org/foaf/bobFoaf&gt;
     rdf:type      foaf:PersonalProfileDocument .
</pre>
  <div class="grammarExtract">
    文法規則:<div class="grammarTable">
      <table id="table104">
        <tr>
  <td><code class="gRuleLabel">[24]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rGraphGraphPattern">GraphGraphPattern</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'GRAPH'</span> <a href="#rVarOrIRIref">VarOrIRIref</a> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
        </tr>
      </table>
    </div>
  </div>

  <h4>8.3.1 <a id="accessByLabel" name="accessByLabel">グラフ名へのアクセス</a>
</h4>

  <p>次のクエリは、データセットの各名前付きグラフにグラフ・パターンをマッチングさせ、マッチしたグラフのIRIにバインドされた<code>src</code>変数を持つソリューションを作成します。グラフ・パターンは、データセットの各名前付きグラフであるアクティブ・グラフとマッチします。</p>

  <div class="queryGroup">
    <pre class="query">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?src ?bobNick
FROM NAMED &lt;http://example.org/foaf/aliceFoaf&gt;
FROM NAMED &lt;http://example.org/foaf/bobFoaf&gt;
WHERE
  {
    GRAPH ?src
    { ?x foaf:mbox &lt;mailto:bob@work.example&gt; .
      ?x foaf:nick ?bobNick
    }
  }
</pre>

    <p>クエリの結果は、情報が発見されたグラフの名前と、Bobのnickの値を提示します。</p>

    <div class="result">      <table class="resultTable" id="table105">
        <tr>
          <th>src</th>
          <th>bobNick</th>
        </tr>
        <tr>
          <td>&lt;http://example.org/foaf/aliceFoaf&gt;</td>
          <td>&quot;Bobby&quot;</td>
        </tr>
        <tr>
          <td>&lt;http://example.org/foaf/bobFoaf&gt;</td>
          <td>&quot;Robert&quot;</td>
        </tr>
      </table>
    </div>
  </div>

  <h4>8.3.2 <a id="restrictByLabel" name="restrictByLabel">グラフIRIによる制限</a>
</h4>

  <p>クエリは、グラフIRIの提供により、特定のグラフに適用されたマッチングを制限できます。これは、IRIで名前付けされたグラフに、アクティブ・グラフを設定します。このクエリは、グラフ<code>http://example.org/foaf/bobFoaf</code>で示されているように、Bobのnickを検索します。</p>

  <div class="queryGroup">
    <pre class="query">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX data: &lt;http://example.org/foaf/&gt;

SELECT ?nick
FROM NAMED &lt;http://example.org/foaf/aliceFoaf&gt;
FROM NAMED &lt;http://example.org/foaf/bobFoaf&gt;
WHERE
  {
     GRAPH data:bobFoaf {
         ?x foaf:mbox &lt;mailto:bob@work.example&gt; .
         ?x foaf:nick ?nick }
  }
</pre>

    <p>これにより、次の1つのソリューションが得られます。</p>

    <div class="result">
      <table class="resultTable" id="table106">
        <tr>
          <th>nick</th>
        </tr>
        <tr>
          <td>&quot;Robert&quot;</td>        </tr>
      </table>
    </div>
  </div>

  <h4>8.3.3 <a id="restrictInQuery" name="restrictInQuery">ありうるグラフIRFの制限</a>
</h4>

  <p><code>GRAPH</code>句で用いられる変数は、もう1つの<code>GRAPH</code>句、または、データセットのデフォルト・グラフにマッチしたグラフ・パターンでも使用できます。</p>

  <p>次のクエリは、Bobのプロフィール・ドキュメントを発見するためにIRI <code>http://example.org/foaf/aliceFoaf</code>を持つグラフを用いており、そのグラフに別のパターンをマッチさせます。AliceのFOAFファイルからファイルの変数<code>whom</code>にマッチングさせるため用いられる空白ノードは、プロフィール・ドキュメントの空白ノードと同じではないため（異なるグラフに存在する）、2番目の<code>GRAPH</code>句のパターンは、最初の<code>GRAPH</code>句（変数<code>whom</code>）で発見されたのと同じメールボックス（変数<code>mbox</code>によって示される）を持つ人の空白ノード（変数<code>w</code>）を発見します。</p>

  <div class="queryGroup">
    <pre class="query">
PREFIX  data:  &lt;http://example.org/foaf/&gt;
PREFIX  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX  rdfs:  &lt;http://www.w3.org/2000/01/rdf-schema#&gt;

SELECT ?mbox ?nick ?ppd
FROM NAMED &lt;http://example.org/foaf/aliceFoaf&gt;
FROM NAMED &lt;http://example.org/foaf/bobFoaf&gt;
WHERE
{
  GRAPH data:aliceFoaf
  {
    ?alice foaf:mbox &lt;mailto:alice@work.example&gt; ;
           foaf:knows ?whom .
    ?whom  foaf:mbox ?mbox ;
           rdfs:seeAlso ?ppd .
    ?ppd  a foaf:PersonalProfileDocument .
  } .
  GRAPH ?ppd
  {
      ?w foaf:mbox ?mbox ;
         foaf:nick ?nick
  }
}
</pre>
    <div class="result">
      <table class="resultTable" id="table107">
        <tr>
          <th>mbox</th>
          <th>nick</th>
          <th>ppd</th>
        </tr>
        <tr>
          <td>&lt;mailto:bob@work.example&gt;</td>
          <td>&quot;Robert&quot;</td>
          <td>&lt;http://example.org/foaf/bobFoaf&gt;</td>
        </tr>
      </table>
    </div>
  </div>
</div>

<p>変数<code>nick</code>を含むパターンが<code>ppd</code>によって特定のパーソナル・プロフィール・ドキュメントに制限されているため、Bobの<code>nick</code>を示しているAliceのFOAFファイルのトリプルは、Bobにnickを提供するために用いられていません。</p>

<h4>8.3.4 <a id="namedAndDefaultGraph" name="namedAndDefaultGraph">名前付きグラフおよびデフォルト・グラフ</a>
</h4>

<p>クエリ・パターンは、デフォルト・グラフと名前付グラフの両方を含むことができます。この例では、アグリゲータは、2回の別の機会に1つのウェブ資源を読み込みました。グラフには、アグリゲータに読み込まれるたびに、ローカル・システムによってIRIが与えられます。これらのグラフはほぼ同じですが、「Bob」のEメール・アドレスが変更されました。</p>

<p>この例では、デフォルト・グラフは、来歴情報を記録するために用いられており、実際に読み込まれたRDFデータは2つの別々のグラフに保持され、システムはそれぞれに異なるIRIを与えます。RDFデータセットは、2つの名前付きグラフとそれらに関する情報で構成されます。</p>

<p>RDFデータセット:</p>

<div class="exampleGroup">
  <pre class="data">
# <b>Default graph</b>
@prefix dc: &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix g:  &lt;tag:example.org,2005-06-06:&gt; .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .

g:graph1 dc:publisher &quot;Bob&quot; .
g:graph1 dc:date &quot;2004-12-06&quot;^^xsd:date .

g:graph2 dc:publisher &quot;Bob&quot; .
g:graph2 dc:date &quot;2005-01-10&quot;^^xsd:date .</pre>
  <pre class="data">
# <b>Graph: locally allocated IRI: tag:example.org,2005-06-06:graph1</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name &quot;Alice&quot; .
_:a foaf:mbox &lt;mailto:alice@work.example&gt; .

_:b foaf:name &quot;Bob&quot; .
_:b foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .
</pre>
  <pre class="data">
# <b>Graph: locally allocated IRI: tag:example.org,2005-06-06:graph2</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name &quot;Alice&quot; .
_:a foaf:mbox &lt;mailto:alice@work.example&gt; .

_:b foaf:name &quot;Bob&quot; .
_:b foaf:mbox &lt;mailto:bob@newcorp.example.org&gt; .
</pre>

  <p>このクエリは、Eメール・アドレスを発見し、人名と情報が発見された日時を詳細化します。</p>
  <div class="queryGroup">
    <pre class="query">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?name ?mbox ?date
WHERE
  {  ?g dc:publisher ?name ;
        dc:date ?date .
    GRAPH ?g
      { ?person foaf:name ?name ; foaf:mbox ?mbox }
  }
</pre>

    <p>結果は、「Bob」のEメール・アドレスが変更されたことを示します。</p>

    <div class="result">
      <table class="resultTable" id="table108">
        <tr>
          <th>name</th>
          <th>mbox</th>
          <th>date</th>
        </tr>
        <tr>
          <td>&quot;Bob&quot;</td>
          <td>&lt;mailto:bob@oldcorp.example.org&gt;</td>
          <td>&quot;2004-12-06&quot;^^xsd:date</td>
        </tr>
        <tr>
          <td>&quot;Bob&quot;</td>
          <td>&lt;mailto:bob@newcorp.example.org&gt;</td>
          <td>&quot;2005-01-10&quot;^^xsd:date</td>
        </tr>
      </table>
    </div>
  </div>
</div>

<p>日時のデータ型に関するIRIは、結果では、明確さのために省略化されています。</p>

<h2>9 <a name="solutionModifiers" id="solutionModifiers">ソリューション・シーケンスと修飾子</a>
</h2>

<p>クエリ・パターンは、各<a href="#defn_sparqlSolutionMapping">ソリューション</a>が変数からRDF用語への部分関数である、順不同のソリューションのコレクションを作成します。次に、これらのソリューションは、シーケンス（ソリューション・シーケンス）として処理されます。最初は特に順序付けのないシーケンスで、後で、任意のシーケンス修飾子を適用して別のシーケンスを作成します。最終的に、この後者のシーケンスを用いて、<a href="#QueryForms">SPARQLクエリ形式</a>の結果の1つを生成します。</p>

<p><span class="definedTerm">ソリューション・シーケンス修飾子</span>は、次のいずれか1つです。</p>

<ul>
  <li>
<a href="#modOrderBy">Order</a>修飾子: ソリューションを順序付けします。</li>
  <li>
<a href="#modProjection">Projection</a>修飾子: ある変数を選択します。</li>
  <li>
<a href="#modDistinct">Distinct</a>修飾子: 確実にシーケンス中のソリューションをユニークにします。</li>
  <li>
<a href="#modReduced">Reduced</a>修飾子: ユニークではないソリューションの排除を許可します。</li>
  <li>
<a href="#modOffset">Offset</a>修飾子: 全体のソリューションのシーケンス中のどこからソリューションが始まるかを制御します。</li>
  <li>
<a href="#modResultLimit">Limit</a>修飾子: ソリューションの数を制限します。</li>
</ul>

<p>修飾子は、上記リストで示されている順序で適用されます。</p>

<div class="grammarExtract">
  文法規則:<div class="grammarTable">
    <table id="table125">      <tr>
  <td><code class="gRuleLabel">[5]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rSelectQuery">SelectQuery</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'SELECT'</span> ( <span class="token">
  'DISTINCT'</span> | <span class="token"> 'REDUCED'</span> )? ( <a href="#rVar">Var</a>+ | <span class="token">'*'</span> 
  ) <a href="#rDatasetClause">DatasetClause</a>* <a href="#rWhereClause">
  WhereClause</a> <a href="#rSolutionModifier">SolutionModifier</a></code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[14]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rSolutionModifier">SolutionModifier</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rOrderClause">OrderClause</a>? <a href="#rLimitOffsetClauses">
  LimitOffsetClauses</a>?</code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[15]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rLimitOffsetClauses">LimitOffsetClauses</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">( <a href="#rLimitClause">LimitClause</a> <a href="#rOffsetClause">
  OffsetClause</a>? | <a href="#rOffsetClause">OffsetClause</a> <a href="#rLimitClause">
  LimitClause</a>? )</code></td>
      </tr>
      <tr>
  <td><code class="gRuleLabel">[16]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rOrderClause">OrderClause</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'ORDER'</span> <span class="token">
  'BY'</span> <a href="#rOrderCondition">OrderCondition</a>+</code></td>
      </tr>
      </table>
  </div>
</div>

<h3>9.1 <a id="modOrderBy" name="modOrderBy">ORDER BY</a>
</h3>

<p><code>ORDER BY</code>句は、ソリューション・シーケンスの順序を定めます。</p>

<p><code>ORDER BY</code>句の後には、式と、オプションの順序修飾子（<code>ASC()</code>か<code>DESC()</code>のどちらか）で構成された順序コンパレータ（order comparator）のシーケンスが続きます。各順序付けコンパレータは、昇順（<code>ASC()</code>修飾子、または、修飾子なしで示される）か、降順（<code>DESC()</code>修飾子で示される）です。</p>

<div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?name
WHERE { ?x foaf:name ?name }
ORDER BY ?name
</pre>
  </div>
</div>
<div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">
PREFIX     :    &lt;http://example.org/ns#&gt;
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX xsd:     &lt;http://www.w3.org/2001/XMLSchema#&gt;

SELECT ?name
WHERE { ?x foaf:name ?name ; :empId ?emp }
ORDER BY DESC(?emp)
</pre>
  </div>
</div>
<div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?name
WHERE { ?x foaf:name ?name ; :empId ?emp }
ORDER BY ?name DESC(?emp)
</pre>
  </div>
</div>

<p><a href="#op_lt">「&lt;」という演算子</a>（<a href="#OperatorMapping">演算子マッピング</a>および<a href="#operatorExtensibility">11.3.1 演算子の拡張性</a>を参照）は、数値（<code>numerics</code>）、シンプルなリテラル（<code>simple literals</code>）、<code>xsd:strings</code>、<code>xsd:booleans</code>、<code>xsd:dateTimes</code>の対の相対順序を定めます。IRIの対は、<code>simple literals</code>として比較し、順序付けられます。</p>

<p>SPARQLは、次の、別の方法では順序付けられない数種のRDF用語間の順序も定めます。</p>

<ol>
  <li>（最も順序が低い） このソリューションの変数または式に割り当てられていない値</li>
  <li>空白ノード</li>
  <li>IRI</li>
  <li>RDFリテラル</li>
</ol>
    
    <p>プレーン・リテラルは、同じ字句形式の型<code>xsd:string</code>を持つRDFリテラルよりも順序が低いです。</p>

    <p>SPARQLは、可能な限りのあらゆるRDF用語の全体的な順序付けを定めるわけではありません。以下は、相対順序が定められていない対の用語のいくつかの例です。</p>

    <ul>
      <li>"a" と "a"@en_gb（シンプルなリテラルと言語タグ付きリテラル）</li>
      <li>"a"@en_gb と "b"@en_gb（言語タグを持つ2つのリテラル）</li>
      <li>"a" と "a"^^xsd:string（シンプルなリテラルとxsd:string）</li>
      <li>"a" と "1"^^xsd:integer（シンプルなリテラルとサポートされているデータ型を持つリテラル）</li>
      <li>"1"^^my:integer と "2"^^my:integer（2つのサポートされていないデータ型）</li>
      <li>"1"^^xsd:integer と "2"^^my:integer（サポートしているデータ型とサポートされていないデータ型）</li>
    </ul>

    <p>この変数バインディングのリストは、昇順です。</p>

    <div class="result">
    <table class="resultTable">
      <thead>
	<tr>
<th>RDFの用語</th>
<th>理由</th>
</tr>
      </thead>
      <tbody>
	<tr>
<td></td>
<td>バインドされていない結果が最初にソートされます。</td>
</tr>
	<tr>
<td><code>_:z</code></td>
<td>バインドされていないものの次は空白ノードです。</td>
</tr>
	<tr>
<td><code>_:a</code></td>
<td>空白ノードには相対的な順序付けがありません。</td>
</tr>
	<tr>
<td><code>&lt;http://script.example/Latin&gt;</code></td>
<td>空白ノードの次はIRIです。</td>
</tr>
	<tr>
<td><code>&lt;http://script.example/&#1050;&#1080;&#1088;&#1080;&#1083;&#1083;&#1080;&#1094;&#1072;&gt;</code></td>
<td>23番目に位置する文字「&#1050;」は、Unicodeのコードポイント0x41Aを持っており、これは0x4C（「L」）より順序が高いです。</td>
</tr>
	<tr>
<td><code>&lt;http://script.example/&#28450;&#23383;&gt;  </code></td>
<td>23番目に位置する文字「漢」は、Unicodeのコードポイント0x6F22を持っており、これは0x41A（「&#1050;」）より順序が高いです。</td>
</tr>
	<tr>
<td><code>"http://script.example/Latin"</code></td>
<td>IRIの次はシンプルなリテラルです。</td>
</tr>
	<tr>
<td><code>"http://script.example/Latin"^^xsd:string</code></td>
<td>シンプルなリテラルの次はxsd:stringです。</td>
</tr>
      </tbody>
    </table>
    </div>

<p>順序付けコンパレータに対する2つのソリューションの昇順は、ソリューションのバインディングを式に代入し、それを<a href="#op_lt">「&lt;」演算子</a>で比較することで定めることができます。降順は昇順の逆です。</p>

<p>2つのソリューションの相対順序は、シーケンス内の最初の順序付けコンパレータに対する2つのソリューションの相対順序です。ソリューション・バインディングの置換が同じRDF用語を作成するソリューションの場合は、順序は次の順序付けコンパレータに対する2つのソリューションの相対順序です。2つのソリューションに対して評価が行われた順序の式が別々のRDF用語を作成しない場合、2つのソリューションの相対順序は未定義です。</p>

<p>ソリューションのシーケンスの順序付けは、常に、その内部に同数のソリューションを持つシーケンスになります。</p>

<p>ソリューション・シーケンスで<code>CONSTRUCT</code>または<code>DESCRIBE</code>クエリに対し<code>ORDER BY</code>を使用すると、<code>SELECT</code>のみが結果のシーケンスを返すため、直接的な効果はありません。<code>LIMIT</code>や<code>OFFSET</code>と組み合わせて用いれば、<code>ORDER BY</code>は、ソリューション・シーケンスの異なる部分から生じる結果を返すために使用できます。<code>ASK</code>クエリは、<code>ORDER BY</code>、<code>LIMIT</code>、または、<code>OFFSET</code>を含みません。</p>

<div class="grammarExtract">
  文法規則:<div class="grammarTable">
    <table>
<tr>
  <td><code class="gRuleLabel">[16]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rOrderClause">OrderClause</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'ORDER'</span> <span class="token">'BY'</span> <a href="#rOrderCondition">OrderCondition</a>+</code></td>
</tr>
<tr>
  <td><code class="gRuleLabel">[17]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rOrderCondition">OrderCondition</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">   ( ( <span class="token">'ASC'</span> | <span class="token">'DESC'</span> ) <a href="#rBrackettedExpression">BrackettedExpression</a> )<br>| ( <a href="#rConstraint">Constraint</a> | <a href="#rVar">Var</a> ) </code></td>
</tr>
<tr>
  <td><code class="gRuleLabel">[18]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rLimitClause">LimitClause</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'LIMIT'</span> <a href="#rINTEGER">INTEGER</a></code></td>
</tr>
<tr>
  <td><code class="gRuleLabel">[19]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rOffsetClause">OffsetClause</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'OFFSET'</span> <a href="#rINTEGER">INTEGER</a></code></td>
</tr>

    </table>
  </div>
</div>


<h3>9.2 <a id="modProjection" name="modProjection">Projection</a>
</h3>

<p>ソリューション・シーケンスは変数のサブセットのみを含むものに変換できます。シーケンスの各ソリューションに対し、SELECTクエリ形式を用いて変数の指定選択を用いることで新しいソリューションが作成されます。</p>

<p>以下の例では、FOAFプロパティーを用いて、RDFグラフで記述された人名のみを抽出するためのクエリを示しています。</p>

<div class="exampleGroup">
  <pre class="data">
@prefix foaf:        &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       &quot;Alice&quot; .
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       &quot;Bob&quot; .
_:b  foaf:mbox       &lt;mailto:bob@work.example&gt; .
</pre>
  <div class="queryGroup">
    <pre class="query">
PREFIX foaf:       &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name
WHERE
 { ?x foaf:name ?name }
</pre>
    <div class="result">
      <table class="resultTable">
        <tr>
          <th>name</th>
        </tr>
        <tr>
          <td>&quot;Bob&quot;</td>
        </tr>
        <tr>
          <td>&quot;Alice&quot;</td>
        </tr>
      </table>
    </div>
  </div>
</div>

<h3>9.3 <a id="modDuplicates" name="modDuplicates">ソリューションの複製</a>
</h3>

<p><code>DISTINCT</code>または<code>REDUCED</code>というクエリ修飾子を用いないソリューション・シーケンスは、複製のソリューションを保持するでしょう。</p>

<div class="exampleGroup">
  <pre class="data">
@prefix  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:x    foaf:name   &quot;Alice&quot; .
_:x    foaf:mbox   &lt;mailto:alice@example.com&gt; .

_:y    foaf:name   &quot;Alice&quot; .
_:y    foaf:mbox   &lt;mailto:asmith@example.com&gt; .

_:z    foaf:name   &quot;Alice&quot; .
_:z    foaf:mbox   &lt;mailto:alice.smith@example.com&gt; .
</pre>
  <div class="queryGroup">
    <pre class="query">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name WHERE { ?x foaf:name ?name }
</pre>
    <div class="result">      <table class="resultTable">
        <tr>
          <th>name</th>
        </tr>
        <tr>
          <td>&quot;Alice&quot;</td>
        </tr>
        <tr>
          <td>&quot;Alice&quot;</td>        </tr>
        <tr>
          <td>&quot;Alice&quot;</td>
        </tr>
      </table>
    </div>
  </div>
      <p><code>DISTINCT</code>および<code>REDUCED</code>の修飾子は、クエリの結果に重複が含まれるかどうかに影響を与えます。</p>

<h4>9.3.1 <a id="modDistinct" name="modDistinct">DISTINCT</a>
</h4>

<p><code>DISTINCT</code>ソリューション修飾子は、重複するソリューションを排除します。具体的には、別のソリューションと同じRDF用語に同じ変数をバインドする各ソリューションが、ソリューション集合から排除されます。</p>

  <div class="queryGroup">
    <pre class="query">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT DISTINCT ?name WHERE { ?x foaf:name ?name }
</pre>
    <div class="result">
      <table class="resultTable">
        <tr>
          <th>name</th>
        </tr>
        <tr>
          <td>&quot;Alice&quot;</td>
        </tr>
      </table>
    </div>
  </div>

<p id="defunSELECT"><a href="#solutionModifiers">ソリューション・シーケンス修飾子の順序</a>にあるように、limitかoffsetのいずれかが適用される前に重複が排除されることに注意してください。</p>

<h4>9.3.2 <a id="modReduced" name="modReduced">REDUCED</a>
</h4>

    <p><code>DISTINCT</code>修飾子は、ソリューション集合から重複したソリューションを確実に排除しますが、<code>REDUCED</code>は、単にそれらを排除することを許可するだけです。<code>REDUCED</code>ソリューション集合の変数バインディング集合のカーディナリティーは、少なくとも1で、多くとも<code>DISTINCT</code>または<code>REDUCED</code>修飾子を用いないソリューション集合のカーディナリティーを超えません。例えば、上記のデータを用いた場合、次のクエリは、</p>

  <div class="queryGroup">
    <pre class="query">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT REDUCED ?name WHERE { ?x foaf:name ?name }
</pre>

<p>1、2（ここで示しているもの）、または、3つのソリューションを持つことができます。</p>

    <div class="result">
      <table class="resultTable">
        <tr>
          <th>name</th>
        </tr>
        <tr>
          <td>&quot;Alice&quot;</td>
        </tr>
        <tr>
          <td>&quot;Alice&quot;</td>
        </tr>
      </table>
    </div>
  </div>
</div>

<h3>9.4 <a id="modOffset" name="modOffset">OFFSET</a>
</h3>

<p><code>OFFSET</code>は、指定された数のソリューションの後でソリューションが始まるようにします。<code>OFFSET</code>を0にすれば効果はありません。</p>

<p>クエリのソリューションの異なるサブセットを選択するために<code>LIMIT</code>と<code>OFFSET</code>を用いても、<code>ORDER BY</code>を用いて順序を予測できるようにしないと、有効ではないでしょう。</p>

<div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT  ?name
WHERE   { ?x foaf:name ?name }
ORDER BY ?name
LIMIT   5
OFFSET  10</pre>
  </div>
</div>

<h3>9.5 <a id="modResultLimit" name="modResultLimit">LIMIT</a>
</h3>

<p><code>LIMIT</code>句は、返されるソリューションの数に上限を設けます。実際のソリューションの数がlimitより大きい場合は、最大で、limitの数のソリューションが返されるでしょう。</p>

<div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?name
WHERE { ?x foaf:name ?name }
LIMIT 20
</pre>
  </div>
</div>

<p><code>LIMIT</code>を0にすれば、結果を返さないでしょう。limitは負の数であってはなりません。</p>


<h2>10 <a id="QueryForms" name="QueryForms">クエリ形式</a>
</h2>

<p>SPARQLには、4つのクエリ形式があります。これらのクエリ形式は、パターン・マッチングのソリューションを用いて、結果集合またはRDFグラフを作成します。クエリ形式は、次の通りです。</p>

<blockquote>
  <dl>
    <dt><a href="#select">SELECT</a></dt>
    <dd>クエリ・パターンにバインドされた変数の、すべてまたはサブセットを返す。</dd>
    <dt><a href="#construct">CONSTRUCT</a></dt>
    <dd>1組のトリプル・テンプレートに変数を代入して構築したRDFグラフを返す。</dd>
    <dt><a href="#ask">ASK</a></dt>
    <dd>クエリ・パターンがマッチするかどうかを示すブール値を返す。</dd>
    <dt><a href="#describe">DESCRIBE</a></dt>
    <dd>発見した資源に関して記述したRDFグラフを返す。</dd>
  </dl>
</blockquote>

<p><code>SELECT</code>クエリからの結果集合、または、<code>ASK</code>クエリのブール演算結果をシリアル化するために<a class="inform" href="www.w3.org/TR/rdf-sparql-XMLres/">SPARQL変数バインディング結果XMLフォーマット</a>を使用できます。</p>

<h3>10.1 <a name="select">SELECT</a>
</h3>

<p>結果のSELECT形式は、変数とそのバインディングを直接返します。構文<code>SELECT*</code>は、クエリ中の変数のすべてを選択するための省略形です。</p>

<div class="exampleGroup">
  <pre class="data">
@prefix  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a    foaf:name   &quot;Alice&quot; .
_:a    foaf:knows  _:b .
_:a    foaf:knows  _:c .

_:b    foaf:name   &quot;Bob&quot; .

_:c    foaf:name   &quot;Clare&quot; .
_:c    foaf:nick   &quot;CT&quot; .

</pre>
  <div class="queryGroup">
    <pre class="query">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?nameX ?nameY ?nickY
WHERE
  { ?x foaf:knows ?y ;
       foaf:name ?nameX .
    ?y foaf:name ?nameY .
    OPTIONAL { ?y foaf:nick ?nickY }
  }
</pre>
    <div class="result">
      <table class="resultTable" id="table33">
        <tr>
          <th>nameX</th>
          <th>nameY</th>
          <th>nickY</th>
        </tr>
        <tr>
          <td>&quot;Alice&quot;</td>
          <td>&quot;Bob&quot;</td>
          <td></td>
        </tr>
        <tr>
          <td>&quot;Alice&quot;</td>
          <td>&quot;Clare&quot;</td>
          <td>&quot;CT&quot;</td>
        </tr>
      </table>
    </div>

    <p>結果集合は、ローカルAPIからアクセスできますが、XMLかRDFグラフのどちらかにシリアル化することも可能です。XMLフォーマットは、<a class="inform" href="www.w3.org/TR/rdf-sparql-XMLres/">SPARQLクエリ結果XMLフォーマット</a>で記述されており、次の例で示しています。</p>

    <div class="result">
      <pre class="resultSet">
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;sparql xmlns=&quot;http://www.w3.org/2005/sparql-results#&quot;&gt;
  &lt;head&gt;
    &lt;variable name=&quot;nameX&quot;/&gt;
    &lt;variable name=&quot;nameY&quot;/&gt;
    &lt;variable name=&quot;nickY&quot;/&gt;
  &lt;/head&gt;
  &lt;results&gt;
    &lt;result&gt;
      &lt;binding name=&quot;nameX&quot;&gt;
        &lt;literal&gt;Alice&lt;/literal&gt;
      &lt;/binding&gt;
      &lt;binding name=&quot;nameY&quot;&gt;
        &lt;literal&gt;Bob&lt;/literal&gt;
      &lt;/binding&gt;
   &lt;/result&gt;
    &lt;result&gt;
      &lt;binding name=&quot;nameX&quot;&gt;
        &lt;literal&gt;Alice&lt;/literal&gt;
      &lt;/binding&gt;
      &lt;binding name=&quot;nameY&quot;&gt;
        &lt;literal&gt;Clare&lt;/literal&gt;
      &lt;/binding&gt;
      &lt;binding name=&quot;nickY&quot;&gt;
        &lt;literal&gt;CT&lt;/literal&gt;
      &lt;/binding&gt;
    &lt;/result&gt;
  &lt;/results&gt;
&lt;/sparql&gt;
</pre>
    </div>
  </div>
</div>
<div class="grammarExtract">
  文法規則:<div class="grammarTable">
  <table>

<tr valign="baseline">
  <td><code class="gRuleLabel">[5]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rSelectQuery">SelectQuery</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'SELECT'</span> ( <span class="token">'DISTINCT'</span> | <span class="token"> 'REDUCED'</span> )? ( <a href="#rVar">Var</a>+ | <span class="token">'*'</span> )<br>
  <a href="#rDatasetClause">DatasetClause</a>* <a href="#rWhereClause">WhereClause</a> <a href="#rSolutionModifier">SolutionModifier</a></code></td>
</tr>

    </table>
  </div>
</div>

<h3>10.2 <a id="construct" name="construct">CONSTRUCT</a>
</h3>

<p><code>CONSTRUCT</code>クエリ形式は、グラフ・テンプレートで指定された1つのRDFグラフを返します。結果は、各クエリのソリューションをソリューション・シーケンスに取り込み、グラフ・テンプレートに変数を代入し、和集合によってトリプルを1つのRDFグラフに結合して作成されたRDFグラフです。</p>

<p>このようなインスタンス化が、主語または述語の位置にあるリテラルなどの、バインドされていない変数または不正なRDF構成子を含むトリプルを作成する場合は、そのトリプルは出力RDFグラフに含まれません。グラフ・テンプレートは、変数を持たないトリプル（基底的または明示的なトリプルとして知られる）を含むことができ、これらはCONSTRUCTクエリ形式が返した出力RDFグラフにも表示されます。</p>

<div class="exampleGroup">
  <pre class="data">
@prefix  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a    foaf:name   &quot;Alice&quot; .
_:a    foaf:mbox   &lt;mailto:alice@example.org&gt; .
</pre>
  <div class="queryGroup">
    <pre class="query">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX vcard:   &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt;
CONSTRUCT   { &lt;http://example.org/person#Alice&gt; vcard:FN ?name }
WHERE       { ?x foaf:name ?name }
</pre>

    <p>は、FOAF情報からvcardプロパティーを作成します。</p>

    <div class="result">
      <pre class="resultGraph" style="text-align:left;">@prefix vcard: &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt; .

&lt;http://example.org/person#Alice&gt; vcard:FN &quot;Alice&quot; .</pre>
    </div>
  </div>
</div>

<h3>10.2.1 <a id="tempatesWithBNodes" name="tempatesWithBNodes">空白ノードを持つテンプレート</a>
</h3>

<p>テンプレートは、空白ノードを含んだRDFグラフを作成できます。空白ノード・ラベルは、各ソリューションに対するテンプレートで有効です。同じラベルが1つのテンプレートで2回出現する場合は、各クエリ・ソリューションに対して作成された1つの空白ノードが存在するでしょうが、別のクエリ・ソリューションによって生成されたトリプルに対する別の空白ノードが存在するでしょう。</p>

<div class="exampleGroup">
  <pre class="data">
@prefix  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a    foaf:givenname   &quot;Alice&quot; .
_:a    foaf:family_name &quot;Hacker&quot; .

_:b    foaf:firstname   &quot;Bob&quot; .
_:b    foaf:surname     &quot;Hacker&quot; .
</pre>
  <div class="queryGroup">
    <pre class="query">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX vcard:   &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt;

CONSTRUCT { ?x  vcard:N _:v .
            _:v vcard:givenName ?gname .
            _:v vcard:familyName ?fname }
WHERE
 {
    { ?x foaf:firstname ?gname } UNION  { ?x foaf:givenname   ?gname } .
    { ?x foaf:surname   ?fname } UNION  { ?x foaf:family_name ?fname } .
 }</pre>

    <p>は、FOAF情報に対応するvcardプロパティーを作成します。</p>

    <div class="result">
      <pre class="resultGraph" style="text-align:left;">
@prefix vcard: &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt; .

_:v1 vcard:N         _:x .
_:x vcard:givenName  &quot;Alice&quot; .
_:x vcard:familyName &quot;Hacker&quot; .

_:v2 vcard:N         _:z .
_:z vcard:givenName  &quot;Bob&quot; .
_:z vcard:familyName &quot;Hacker&quot; .
</pre>
    </div>
  </div>
</div>

<p>テンプレートで変数<code>x</code>を用いると（この例では、データ内でラベル<code>_:a</code>と<code>_:b</code>を持つ空白ノードにバインドされているでしょう）、結果として生成されるRDFグラフの中に別の空白ノード・ラベル（<code>_:v1</code>と<code>_:v2</code>）が生成されます。</p> 

<h3>10.2.2 <a id="accessingRdfGraphs" name="accessingRdfGraphs">RDFデータセットのグラフへのアクセス</a>
</h3>

<p><code>CONSTRUCT</code>を用いて、ターゲットのRDFデータセットからグラフの部分または全体を抽出することが可能です。この最初の例は、IRIラベル<code>http://example.org/aGraph</code>を持つグラフ（それがデータセットにあれば）を返します。さもなければ、空のグラフを返します。</p>

<div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">
CONSTRUCT { ?s ?p ?o } WHERE { GRAPH &lt;http://example.org/aGraph&gt; { ?s ?p ?o } . }
</pre>
  </div>
</div>

<p>グラフへのアクセスは、他の情報を条件としている場合があります。例えば、デフォルト・グラフがデータセットの名前付きグラフに関するメタデータを含んでいる場合、次のようなクエリは、名前付きグラフに関する情報に基づく1つのグラフを抽出できます。</p>

<div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">
PREFIX  dc: &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX app: &lt;http://example.org/ns#&gt;
CONSTRUCT { ?s ?p ?o } WHERE
 {
   GRAPH ?g { ?s ?p ?o } .
   { ?g dc:publisher &lt;http://www.w3.org/&gt; } .
   { ?g dc:date ?date } .
   FILTER ( app:customDate(?date) &gt; &quot;2005-02-28T00:00:00Z&quot;^^xsd:dateTime ) .
 }
</pre>
  </div>
</div>

<p>ここでは、<code>app:customDate</code>が拡張関数を識別し、データ・フォーマットを<code>xsd:dateTime</code>というRDF用語に変えました。</p>

<div class="grammarExtract">
  文法規則:<div class="grammarTable">
  <table>

<tr valign="baseline">
  <td><code class="gRuleLabel">[6]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rConstructQuery">ConstructQuery</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'CONSTRUCT'</span> <a href="#rConstructTemplate">ConstructTemplate</a><br>
  <a href="#rDatasetClause">DatasetClause</a>* <a href="#rWhereClause">WhereClause</a> <a href="#rSolutionModifier">SolutionModifier</a></code></td>
</tr>

    </table>
  </div>
</div>

<h3>10.2.3 <a id="SolModandCONSTRUCT" name="SolModandCONSTRUCT">ソリューション修飾子とCONSTRUCT</a>
</h3>

<p>クエリのソリューション修飾子は、<code>CONSTRUCT</code>クエリの結果に影響を与えます。この例では、<code>CONSTRUCT</code>テンプレートからの出力グラフは、グラフ・パターン・マッチング2つのソリューションのみから形成されます。クエリは、ヒット率で格付けされたトップ2のサイトを持つ人々の名前を持つグラフを出力します。RDFグラフ中のトリプルは順序付けされていません。</p>

<div class="exampleGroup">
  <pre class="data">
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix site: &lt;http://example.org/stats#&gt; .

_:a foaf:name &quot;Alice&quot; .
_:a site:hits 2349 .

_:b foaf:name &quot;Bob&quot; .
_:b site:hits 105 .

_:c foaf:name &quot;Eve&quot; .
_:c site:hits 181 .
</pre>
  <div class="queryGroup">
    <pre class="query">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX site: &lt;http://example.org/stats#&gt;

CONSTRUCT { [] foaf:name ?name }
WHERE
{ [] foaf:name ?name ;
     site:hits ?hits .
}
ORDER BY desc(?hits)
LIMIT 2
</pre>
    <div class="result">
      <pre class="resultGraph">
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .
_:x foaf:name &quot;Alice&quot; .
_:y foaf:name &quot;Eve&quot; .
</pre>    </div>
  </div>
</div>

<h3>10.3 <a id="ask" name="ask">ASK</a>
</h3>

<p>アプリケーションは、クエリ・パターンにソリューションがあるか否かをテストするために<code>ASK</code>形式を使用できます。ありえるクエリのソリューションに関する情報は返さず、ソリューションが存在しているか否かのみです。</p>

<div class="exampleGroup">
  <pre class="data">
@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       &quot;Alice&quot; .
_:a  foaf:homepage   &lt;http://work.example.org/alice/&gt; .

_:b  foaf:name       &quot;Bob&quot; .
_:b  foaf:mbox       &lt;mailto:bob@work.example&gt; .
</pre>
  <div class="queryGroup">
    <pre class="query">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
ASK  { ?x foaf:name  &quot;Alice&quot; }
</pre>
    <div class="result">
      <pre class="resultAsk">
yes
</pre>
    </div>

    <p>この結果集合の<a class="inform" href="www.w3.org/TR/rdf-sparql-XMLres/">SPARQLクエリ結果XMLフォーマット</a>の形式は、次のようになります。</p>

    <div class="result">
      <pre class="resultSet">
&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;sparql xmlns=&quot;http://www.w3.org/2005/sparql-results#&quot;&gt;
  &lt;head&gt;&lt;/head&gt;
  &lt;results&gt;
    &lt;boolean&gt;true&lt;/boolean&gt;
  &lt;/results&gt;
&lt;/sparql&gt;
</pre>
    </div>
  </div>

  <p>同じデータを用いた場合、次の例は、Aliceの<code>mbox</code>が記述されていないため、マッチを返しません。</p>

  <div class="queryGroup">
    <pre class="query">
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
ASK  { ?x foaf:name  &quot;Alice&quot; ;
          foaf:mbox  &lt;mailto:alice@work.example&gt; }
</pre>
    <div class="result">
      <pre class="resultAsk">
no
</pre>
    </div>
  </div>
</div>
<div class="grammarExtract">
  文法規則:<div class="grammarTable">
    <table id="table126">
      <tr>
  <td><code class="gRuleLabel">[8]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rAskQuery">AskQuery</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'ASK'</span> <a href="#rDatasetClause">DatasetClause</a>* <a href="#rWhereClause">WhereClause</a></code></td>
      </tr>
    </table>
  </div>
</div>

<h3>10.4 <a id="describe" name="describe">DESCRIBE</a>（参考情報）</h3>

<p><code>DESCRIBE</code>形式は、資源に関するRDFデータを含んだ1つの結果RDFグラフを返します。SPARQLのクエリではこのデータは規定されておらず、この場合には、クエリのクライアントがデータ情報源内のRDFの構造を知っている必要があるでしょうが、その代わりにSPARQLクエリ・プロセッサがこのデータを決定します。クエリ・パターンを用いて結果集合を作成します。<code>DESCRIBE</code>形式は、IRIで直接指定された任意の資源と一緒に、識別された各資源をソリューションに取り込み、ターゲットのRDFデータセットを含んでいる利用可能な任意の情報から得られる「記述」を持ってくることによって、1つのRDFグラフを組み立てます。記述はクエリ・サービスが決定します。<code>DESCRIBE *</code>という構文は、クエリ内のすべての変数を記述するための省略形です。</p>

<h4>10.4.1 <a id="explititURIs" name="explititURIs">明示的なIRI</a>
</h4>

<p><code>DESCRIBE</code>句自身がIRIを取り込んで資源を識別することができます。最もシンプルな<code>DESCRIBE</code>クエリは、次のような<code>DESCRIBE</code>句内にIRIのみがあるものです。</p>

<div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">
DESCRIBE &lt;http://example.org/&gt;
</pre>
  </div>
</div>

<h4>10.4.2 <a id="identifyingResources" name="identifyingResources">資源の識別</a>
</h4>

<p>記述される資源は、クエリ変数へのバインディングから結果集合に取り込むこともできます。これによって、次のような、資源がIRIによって識別されるのか、データセットの空白ノードによって識別されるのかの記述が可能になります。</p>
<div class="exampleGroup">
  <div class="queryGroup">    <pre class="query">
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
DESCRIBE ?x
WHERE    { ?x foaf:mbox &lt;mailto:alice@org&gt; }
</pre>
  </div>
</div>

<p>プロパティー<code>foaf:mbox</code>は、FOAF語彙では、逆関数プロパティーであると定義されています。そういうものとして処理すると、このクエリは、高々1人の人物に関する情報を返すでしょう。しかし、クエリ・パターンに複数のソリューションがある場合は、それぞれに対するRDFデータは、すべてのRDFグラフ記述の和集合です。</p>

<div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
DESCRIBE ?x
WHERE    { ?x foaf:name &quot;Alice&quot; }
</pre>
  </div>
</div>

<p>次のように、1つ以上のIRIまたは変数を作成できます。</p>

<div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
DESCRIBE ?x ?y &lt;http://example.org/&gt;
WHERE    {?x foaf:knows ?y}
</pre>
  </div>
</div>

<h4>10.4.3 <a id="descriptionsOfResources" name="descriptionsOfResources">資源の記述</a>
</h4>

<p>返されるRDFは、情報の発行者が決定します。これは、サービスが資源について有する有益な情報です。他の資源に関する情報を含むことができます。例えば、本のRDFデータには、著者に関する詳細を含むこともできます。</p>

<p>次のようなシンプルなクエリは、</p>

<div class="exampleGroup">
  <div class="queryGroup">
    <pre class="query">
PREFIX ent:  &lt;http://org.example.com/employees#&gt;
DESCRIBE ?x WHERE { ?x ent:employeeId &quot;1234&quot; }
</pre>

    <p>下記のような、従業員の記述や、何らかの他の潜在的に役に立つ詳細情報を返すかもしれません。</p>

    <div class="result">
      <pre class="resultGraph">
@prefix foaf:   &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix vcard:  &lt;http://www.w3.org/2001/vcard-rdf/3.0&gt; .
@prefix exOrg:  &lt;http://org.example.com/employees#&gt; .
@prefix <code>rdf:    &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix owl:    &lt;http://www.w3.org/2002/07/owl#&gt;</code>

_:a     exOrg:employeeId    &quot;1234&quot; ;
       
        <code>foaf:mbox_sha1sum   &quot;ABCD1234&quot; ;</code>
        vcard:N
         [ vcard:Family       &quot;Smith&quot; ;
           vcard:Given        &quot;John&quot;  ] .

<code>foaf:mbox_sha1sum  rdf:type  owl:InverseFunctionalProperty .</code></pre>
    </div>
  </div>
</div>

<p>これには、<a href="www.w3.org/TR/vcard-rdf" class="inform">vcard</a>語彙vcard:Nに対する空白ノード・<span class="closure">クロージャ</span>が含まれいます。どのような情報を返すかを決定できる他のメカニズムには、Concise Bounded Descriptions[<a href="#CBD">CBD</a>]などもあります。</p>

<p>FOAFなどの語彙では、通常は、資源は空白ノードであるため、InverseFunctionalPropertyである<code>foaf:mbox_sha1sum</code>などのノードを識別するのに十分な情報や、名前やその他の詳細データといった情報を返すのが適切でしょう。例では、WHERE句に対するマッチが返されましたが、これは必須ではありません。</p>

<div class="grammarExtract">
  文法規則:<div class="grammarTable">
    <table id="table87">
      <tr>
  <td><code class="gRuleLabel">[7]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a href="#rDescribeQuery">DescribeQuery</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'DESCRIBE'</span> ( <a href="#rVarOrIRIref">VarOrIRIref</a>+ | <span class="token">'*'</span> )<br>
  <a href="#rDatasetClause">DatasetClause</a>* <a href="#rWhereClause">WhereClause</a>? <a href="#rSolutionModifier">SolutionModifier</a></code></td>
      </tr>
    </table>
  </div>
</div>

<h2>11 <a id="tests" name="tests">値のテスト</a>
</h2>

    <p>SPARQLの<code>FILTER</code>は、与えられた<a href="#rExpression">式</a>に従ってグラフ・パターン・マッチのソリューションを制限します。具体的には、<code>FILTER</code>は、式に代入したときに、偽（<code>false</code>）の有効なブール値になったり、エラーを起こしたりするソリューションを排除します。有効なブール値は<a href="#ebv">11.2.2 <em>有効なブール値</em></a>の項で定義されており、エラーはXQuery1.0: XMLクエリ言語[<a href="#XQUERY">XQUERY</a>]の<a class="norm" href="www.w3.org/TR/2007/REC-xquery-20070123/#dt-type-error">2.3.1, <em>エラーの種類</em></a>の項で定義されています。これらのエラーは、<code>FILTER</code>の評価以外には影響を与えません。</p>

  <div class="exampleGroup">
    <p>RDFリテラルは、<a>データ型IRI</a>を持つことができます。</p>
  <pre class="data">@prefix a:          &lt;http://www.w3.org/2000/10/annotation-ns#&gt; .
@prefix dc:         &lt;http://purl.org/dc/elements/1.1/&gt; .

_:a   a:annotates   &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
_:a   dc:date       &quot;2004-12-31T19:00:00-05:00&quot; .

_:b   a:annotates   &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
_:b   dc:date       &quot;2004-12-31T19:01:00-05:00&quot;^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .</pre>

    <p>最初の<code>dc:date</code>トリプルの目的語には、型情報が全くありません。2番目のものには、<code>xsd:dateTime</code>というデータ型があります。</p>

    <p>SPARQLの式は文法に従って構築され、関数（IRIによって名前が付けられる）と演算子関数へのアクセスを提供します（SPARQL文法のキーワードとシンボルで呼び出される）。SPARQLの演算子は、型付リテラルの値を比較するために使用できます。</p>

  <div class="queryGroup">
  <pre class="query">
PREFIX a:      &lt;http://www.w3.org/2000/10/annotation-ns#&gt;
PREFIX dc:     &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX xsd:    &lt;http://www.w3.org/2001/XMLSchema#&gt;

SELECT ?annot
WHERE { ?annot  a:annotates  &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
        ?annot  dc:date      ?date .
        FILTER ( ?date &gt; &quot;2005-01-01T00:00:00Z&quot;^^xsd:dateTime ) }</pre>
</div>
</div>

    <p>SPARQLの演算子は、<a href="#OperatorMapping">11.3項</a>に記載されており、文法上の生成規則に関連付けられています。</p>

    <p>さらに、SPARQLは、<a href="#FunctionMapping">11.5項</a>に記載している、XPathキャスト関数のサブセットを含む、任意の関数を呼び出す能力を提供します。これらの関数は、名前（IRI）によってSPARQLクエリの中に呼び出されます。例えば次のとおりです。</p>

  <pre class="query untested">... FILTER ( xsd:dateTime(?date) &lt; xsd:dateTime(&quot;2005-01-01T00:00:00Z&quot;) ) ...</pre>

    <p>この項では、次の表記上の規定を用いています。</p>

    <ul>
      <li>XPath演算子は接頭辞<code>op:</code>でラベル付けされています。XPath演算子には名前空間がなく、<code>op:</code>はラベル付け上の慣習です。</li>
      <li>この仕様で紹介された演算子は、<span class="SPARQLoperator">SPARQLoperatorクラス</span>を用いて示されます。</li>
    </ul>

    <h3>11.1 <a id="operandDataTypes" name="operandDataTypes">オペランド・データ型</a>
</h3>

    <p>SPARQLの関数と演算子は、RDF用語とSPARQL変数を演算します。これらの関数および演算子のサブセットは、<a class="norm" href="www.w3.org/TR/xpath-functions/">XQuery 1.0とXPath 2.0関数および演算子</a>[<a href="#FUNCOP">FUNCOP</a>]から持って来たもので、XMLスキーマ<a href="www.w3.org/TR/xpath20/#dt-typed-value">型付き値</a>の引数を持っており、型を返します。これらの関数と演算子に引数として渡されたRDF型付きリテラル（<code class="type typedLiteral">typed literals</code>）は、字句形式（<code class="type lexicalForm">lexical form</code>）の<a href="www.w3.org/TR/xpath20/#dt-string-value">文字列の値</a>を持つXMLスキーマの型付き値と、<span class="type datatypeIRI">datatype IRI</span>（データ型IRI）に対応する<a href="www.w3.org/TR/xmlschema-2/#dt-atomic">アトミックなデータ型</a>にマッピングされます。返された型付き値は、同様にRDFの型付きリテラル（<code class="type typedLiteral">typed literals</code>）にマッピングし返されます。</p>

    <p>SPARQLには、RDF用語の特定のサブセットに基づいて演算する付加的な演算子があります。型について述べるときには、次の用語は、XMLスキーマ[<a class="norm" href="#XSDT">XSDT</a>]の<span class="type datatypeIRI">データ型IRI</span>に対応する型付きリテラル（<code class="type typedLiteral">typed literal</code>）を表します。</p>

    <ul>
      <li><code><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-integer">xsd:integer</a></code></li>
      <li>
<code><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-decimal">xsd:decimal</a></code><!-- and derived types:<ul>
	  <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-nonPositiveInteger">xsd:nonPositiveInteger</a></code></li>
	  <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-negativeInteger">xsd:negativeInteger</a></code></li>
	  <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-long">xsd:long</a></code></li>
	  <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-int">xsd:int</a></code></li>
	  <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-short">xsd:short</a></code></li>
	  <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-byte">xsd:byte</a></code></li>
	  <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-nonNegativeInteger">xsd:nonNegativeInteger</a></code></li>
	  <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-unsignedLong">xsd:unsignedLong</a></code></li>
	  <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-unsignedInt">xsd:unsignedInt</a></code></li>
	  <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-unsignedShort">xsd:unsignedShort</a></code></li>
	  <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-unsignedByte">xsd:unsignedByte</a></code></li>
	  <li><code><a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-positiveInteger">xsd:positiveInteger</a></code></li>
	</ul> -->
</li>
      <li><code><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-float">xsd:float</a></code></li>
      <li><code><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-double">xsd:double</a></code></li>
      <li><code><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-string">xsd:string</a></code></li>
      <li><code><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-boolean">xsd:boolean</a></code></li>
      <li><code><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-dateTime">xsd:dateTime</a></code></li>
    </ul>

    <p>次の用語は、SPARQL値テストに用いられる付加的な型を識別します。</p>

    <ul>
      <li>
<span class="type numeric">数値</span>は、データ型<code>xsd:integer</code>、<code>xsd:decimal</code>、<code>xsd:float</code>、および、<code>xsd:double</code>を持つ型付きリテラル（<code class="type typedLiteral">typed literals</code>）を表します。</li>
      <li>
<span class="type simpleLiteral">シンプルなリテラル</span>は、言語タグ（<code class="type langTag">language tag</code>）を持たないプレーン・リテラル（<code class="type plainLiteral">plain literal</code>）を表します。</li>
      <li>
<span class="type RDFterm">RDF用語</span>は、<code class="type IRI">IRI</code>、リテラル（<code class="type literal">literal</code>）、および、空白ノード（<code class="type bNode">blank node</code>）の型を表します。</li>
      <li>
<span class="type variable">変数</span>は、SPARQL変数を表します。</li>
    </ul>

  <!-- blockquote>
    <dl>
      <dt class="type numeric">numeric</dt> <dd><code class="type typedLiteral">typed literals</code> with datatypes <code>xsd:integer</code>, <code>xsd:decimal</code>, <code>xsd:float</code>, and <code>xsd:double</code></dd>
      <dt></dt>
      <dt class="type simpleLiteral">simple literal</dt> <dd>a <code class="type plainLiteral">plain literal</code> with no <code class="type langTag">language tag</code>.</dd>
      <dt class="type RDFterm">RDF term</dt> <dd>the types <code class="type IRI">IRI</code>, <code class="type literal">literal</code>, and <code class="type bNode">blank node</code></dd>
      <dt class="type variable">variable</dt> <dd>a SPARQL variable</dd>

    </dl>
  </blockquote -->

    <p>次の型は、<span class="type numeric">数値</span>の型から得られ、<span class="type numeric">数値</span>引数を取る関数と演算子に対する有効な引数です。</p>

    <ul>
      <li><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-nonPositiveInteger"><code>xsd:nonPositiveInteger</code></a></li>
      <li><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-negativeInteger"><code>xsd:negativeInteger</code></a></li>
      <li><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-long"><code>xsd:long</code></a></li>
      <li><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-int"><code>xsd:int</code></a></li>
      <li><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-short"><code>xsd:short</code></a></li>
      <li><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-byte"><code>xsd:byte</code></a></li>
      <li><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-nonNegativeInteger"><code>xsd:nonNegativeInteger</code></a></li>
      <li><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-unsignedLong"><code>xsd:unsignedLong</code></a></li>
      <li><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-unsignedInt"><code>xsd:unsignedInt</code></a></li>
      <li><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-unsignedShort"><code>xsd:unsignedShort</code></a></li>
      <li><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-unsignedByte"><code>xsd:unsignedByte</code></a></li>
      <li><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-positiveInteger"><code>xsd:positiveInteger</code></a></li>
    </ul>

    <p>SPARQLの言語拡張は、付加的な型をXMLスキーマ・データ型から得られるものとして扱うことができます。</p>

    <h3>11.2 <a id="evaluation" name="evaluation">フィルタ評価</a>
</h3>

    <p>SPARQLは、XQuery<a href="www.w3.org/TR/xquery/#mapping" class="norm">演算子マッピング</a>で定義された関数と演算子のサブセットを提供します。XQuery 1.0の<a href="www.w3.org/TR/xquery/#id-expression-processing" class="norm">2.2.3 式の処理</a>の項では、XPath関数の呼び出しについて説明しています。次の規則は、XQueryとSPARQLのデータと実行モデルの違いを調整します。</p>

    <ul>
      <li>XPath/XQueryとは異なり、SPARQL関数はノード・シーケンスを処理しません。XPath関数のセマンティクスを解釈するときには、それぞれの引数が1つのノードのシーケンスであると想定します。</li>
      <li>間違った型の引数で呼び出された関数は<a href="www.w3.org/TR/xquery/#dt-type-error" class="norm">型エラー</a>を起こすでしょう。有効なブール値引数（下記の演算子マッピング・テーブルで「xsd:boolean (EBV)」とラベル付けされている）は、11.2.2項の<a href="#ebv">EBV規則</a>を用いて<code>xsd:boolean</code>に強制変換されます。</li>
      <li>
<a href="#func-bound">BOUND</a>は別として、任意の引数がバインドされていなければ、すべての関数と演算子はRDF用語に基づいて演算し、型エラーを起こすでしょう。</li>
      <li>エラーに遭遇した<a href="#func-logical-or">論理OR</a>（<code>||</code>）または<a href="#func-logical-and">論理AND</a>（<code>&amp;&amp;</code>）を除く任意の式は、エラーを起こすでしょう。</li>
      <li>1つの辺のみでエラーに遭遇した<a href="#func-logical-or">論理OR</a>は、もう一方の辺がTRUEであるならTRUEを、FALSEであるならエラーを返します。</li>
      <li>1つの辺のみでエラーに遭遇した<a href="#func-logical-and">論理AND</a>は、もう一方の辺がTRUEであるならエラーを、FALSEであるならFALSEを返します。</li>
      <li>両方の辺でエラーに遭遇した<a href="#func-logical-or">論理OR</a>または<a href="#func-logical-and">論理AND</a>は、どちらかのエラーを起こします。</li>
    </ul>

    <p>真（<span class="truth">T</span>）、偽（<span class="truth">F</span>）、エラー（<span class="truth error">E</span>）に対する論理ANDと論理ORの真理値表は次の通りです。</p>

    <table id="truthTable" class="truthTable">
      <thead>
	<tr>
<th>A</th>
<th>B</th>
<th>A || B</th>
<th>A &amp;&amp; B</th>
</tr>
      </thead>
      <tbody>
	<tr>
<th>T</th>
<th>T</th>
<td>T</td>
<td>T</td>
</tr>
	<tr>
<th>T</th>
<th>F</th>
<td>T</td>
<td>F</td>
</tr>
	<tr>
<th>F</th>
<th>T</th>
<td>T</td>
<td>F</td>
</tr>
	<tr>
<th>F</th>
<th>F</th>
<td>F</td>
<td>F</td>
</tr>
      </tbody>
      <tbody>
	<tr>
<th>T</th>
<th><span class="error">E</span></th>
<td>T</td>
<td><span class="error">E</span></td>
</tr>
	<tr>
<th><span class="error">E</span></th>
<th>T</th>
<td>T</td>
<td><span class="error">E</span></td>
</tr>
	<tr>
<th>F</th>
<th><span class="error">E</span></th>
<td><span class="error">E</span></td>
<td>F</td>
</tr>
	<tr>
<th><span class="error">E</span></th>
<th>F</th>
<td><span class="error">E</span></td>
<td>F</td>
</tr>
	<tr>
<th><span class="error">E</span></th>
<th><span class="error">E</span></th>
<td><span class="error">E</span></td>
<td><span class="error">E</span></td>
</tr>
      </tbody>
    </table>

    <h4>11.2.1 <a id="invocation" name="invocation">呼び出し</a>
</h4>

    <p>SPARQLは、引数のリストに<a>関数</a>と<a>演算子</a>を呼び出すための構文を定義しています。これらは、次の通りに呼び出されます。</p>

    <ul>
      <li>引数式は評価され、引数値を作成します。引数評価の順序は定義されません。</li>
      <li>数値引数は、その関数または演算子の予期される型に合うように必要に応じて入力が促されます。</li>
      <li>関数または演算子は、引数値で呼び出されます。</li>
    </ul>

    <p>これらのステップのどれかが失敗すれば、呼び出しはエラーを起こします。エラーの影響は、<a href="#evaluation">フィルタ評価</a>で定義されています。</p>

    <h4>11.2.2 <a id="ebv" name="ebv">有効なブール値</a>（EBV）</h4>

    <p>有効なブール値は、<a href="#func-logical-and">論理AND</a>、<a href="#func-logical-or">論理OR</a>、および<a class="norm" href="www.w3.org/TR/xpath-functions/#func-not">fn:not</a>の論理関数に対する引数を計算するために用いられ、また、<code>FILTER</code>式の結果の評価も行います。</p>

    <p>XQueryの<a href="www.w3.org/TR/xquery/#id-ebv">有効なブール値</a>の規則は、XPathの<a href="www.w3.org/TR/xpath-functions/#func-boolean">fn:boolean</a>の定義に依存しています。以下の規則は、SPARQLのクエリに存在している引数の型に適用された<code>fn:boolean</code>の規則を反映しています。</p>

    <ul>
      <li>型が<code>xsd:boolean</code>または<span class="type ">数値</span>（numeric）である任意のリテラルのEBVは、字句形式がそのデータ型（例えば、"abc"^^xsd:integer）に対して偽である場合は、偽です。</li>
      <li>引数が<code>xsd:boolean</code>の<span class="type datatype">データ型</span>を持つ<span class="type typedLiteral">型付きリテラル</span>である場合、EBVはその引数の値です。</li>
      <li>引数が<span class="type plainLiteral">プレーン・リテラル</span>または、<code>xsd:string</code>の<span class="type datatype">データ型</span>を持つ<span class="type typedLiteral">型付きリテラル</span>である場合、オペランド値に0の長さがあるならEBVは偽で、そうれなければEBVは真です。</li>
      <li>引数が、<span class="type numeric">数値</span>型、または<span class="type numeric">数値</span>型から得られたデータ型を持つ<span class="type typedLiteral">型付きリテラル</span>である場合、オペランド値がNaNであるか数値上0と等しいならEBVは偽で、そうでなければ、EBVは真です。</li>
      <li>バインドされていない引数を含む他のすべての引数は、型エラーを起こします。</li>
    </ul>

    <p>真（<code>true</code>）のEBVは、<code>xsd:boolean</code>のデータ型および「真」の字句値を持つ<span class="type typedLiteral">型付きリテラル</span>として表され、
偽（false）のEBVは、<code>xsd:boolean</code>のデータ型および「偽」の字句値を持つ<span class="type typedLiteral">型付きリテラル</span>として表されます。</p>

    <h3>11.3 <a id="OperatorMapping" name="OperatorMapping">演算子マッピング</a>
</h3>

    <p>SPARQLの文法は、一連の演算子を識別し（例えば、<span class="token">&amp;&amp;</span>、<span class="token">*</span>、<span class="token">isIRI</span>）、制約を構築するために用いられます。以下のテーブルは、これらのそれぞれの文法上の生成規則と、<a class="norm" href="www.w3.org/TR/xpath-functions/">XQuery 1.0とXPath 2.0関数および演算子</a>[<a href="#FUNCOP">FUNCOP</a>]、または<a href="#SparqlOps">11.4項</a>のSPARQL演算子のいずれかによって定義されている適切なオペランドおよび演算子関数とを関連付けます。一連のパラメータに対する演算子定義を選択する際には、最も明確なパラメータを持つ定義が適用されます。例えば、<code>xsd:integer = xsd:signedInt</code>を評価する際には、2つの<span class="type RDFterm">RDF用語</span>を持つ<code>=</code>に対する定義ではなく、2つの数値（<code>numeric</code>）パラメータを持つ<code>=</code>に対する定義が適用されます。表は、最も実行可能性のある候補が最も明確になるように配列されています。適切なオペランドなしに呼び出された演算子は、型エラーになります。</p>

    <p>SPARQLは、XPathの数値型昇格（numeric type promotion）に対するスキームと、数値演算子への引数に対する部分型置換（subtype substitution）に従います。<span class="type numeric">数値</span>オペランド（<code>xsd:integer</code>、<code>xsd:decimal</code>、<code>xsd:float</code>、<code>xsd:double</code>、および<span class="type numeric">数値</span>型から得られた型）の<a href="www.w3.org/TR/xpath20/#mapping">XPath演算子マッピング</a>規則は、SPARQL演算子にも適用されます（<a class="norm" href="www.w3.org/TR/xpath20/#promotion">数値型昇格</a>および<a class="norm" href="www.w3.org/TR/xpath20/#dt-subtype-substitution">部分型置換</a>の定義に関しては、<a class="norm" href="www.w3.org/TR/xpath20/">XMLパス言語（XPath）2.0</a>[<a href="#XPATH20">XPATH20</a>]を参照してください)。演算子の一部は、入れ子にされた関数式、例えば<code>fn:not(op:numeric-equal(A, B))</code>に関連しています。XPathの定義によって、<code>fn:not</code>および<code>op:numeric-equal</code>は、引数がエラーである場合にはエラーを起こします。</p>

    <p><code>fn:compare</code>の照合順序は、<a href="www.w3.org/TR/xpath-functions/#collations">XPathで定義され</a>、<code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>で識別されます。この照合順序は、コードポイント値に基づく文字列の比較を可能にします。コードポイント文字列の同等性は、RDF用語の同等性でテストできます。</p>

    <table summary="SPARQL Unary Operators" class="FAndOTable">
      <caption>SPARQL単項演算子</caption>
      <tbody>
	<tr>
<th class="major" scope="col">演算子</th>
	  <th class="major" scope="col">型（A）</th>
<th class="major" scope="col">関数</th>
<th class="major" scope="col">結果の型</th>
</tr>
	<tr><th colspan="4" class="subHeading" scope="col">XQuery単項演算子</th></tr>
	<tr>
<th scope="row">
<a href="#rUnaryExpression" title="UnaryExpression"><span class="FAOTtoken">!</span> A</a>
	  </th>
	  <td>xsd:boolean <a href="#ebv-arg">(EBV)</a>
</td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(A)</td>
<td>xsd:boolean</td>
</tr>
	<tr>
<th scope="row">
<a href="#rUnaryExpression" title="UnaryExpression"><span class="FAOTtoken">+</span> A</a>
	  </th>
	  <td><span class="type numeric">数値</span></td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-unary-plus">op:numeric-unary-plus</a>(A)</td>
<td><span class="type numeric">数値</span></td>
</tr>
	<tr>
<th scope="row">
<a href="#rUnaryExpression" title="UnaryExpression"><span class="FAOTtoken">-</span> A</a>
	  </th>
	  <td><span class="type numeric">数値</span></td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-unary-minus">op:numeric-unary-minus</a>(A)</td>
<td><span class="type numeric">数値</span></td>
</tr>


	<tr><th colspan="5" class="subHeading" scope="col">SPARQLテスト（<a href="#SparqlOps">11.4項</a>で定義されている）</th></tr>

	<tr>
<th scope="row">
<a href="#rBuiltInCall" title="CallExpression"><span class="FAOTtoken">BOUND</span></a>(A)
	  </th>
	  <td><span class="type variable">変数</span></td>
<td class="xpathOp">
<a href="#func-bound" class="SPARQLoperator">bound</a>(A)</td>
<td>xsd:boolean</td>
</tr>
	<tr>
<th scope="row">
<a href="#rBuiltInCall" title="CallExpression"><span class="FAOTtoken">isIRI</span></a>(A)<br><a href="#rBuiltInCall" title="CallExpression"><span class="FAOTtoken">isURI</span></a>(A)
	  </th>
	  <td><span class="type RDFterm">RDF用語</span></td>
<td class="xpathOp">
<a href="#func-isIRI" class="SPARQLoperator">isIRI</a>(A)</td>
<td>xsd:boolean</td>
</tr>
	<tr>
<th scope="row">
<a href="#rBuiltInCall" title="CallExpression"><span class="FAOTtoken">isBLANK</span></a>(A)
	  </th>
	  <td><span class="type RDFterm">RDF用語</span></td>
<td class="xpathOp">
<a href="#func-isBlank" class="SPARQLoperator">isBlank</a>(A)</td>
<td>xsd:boolean</td>
</tr>
	<tr>
<th scope="row">
<a href="#rBuiltInCall" title="CallExpression"><span class="FAOTtoken">isLITERAL</span></a>(A)
	  </th>
	  <td><span class="type RDFterm">RDF用語</span></td>
<td class="xpathOp">
<a href="#func-isLiteral" class="SPARQLoperator">isLiteral</a>(A)</td>
<td>xsd:boolean</td>
</tr>
	<tr><th colspan="5" class="subHeading" scope="col">SPARQLアクセサ（<a href="#SparqlOps">11.4項</a>で定義されている）</th></tr>
	<tr>
<th scope="row">
<a href="#rBuiltInCall" title="CallExpression"><span class="FAOTtoken">STR</span></a>(A)
	  </th>
	  <td><span class="type literal">リテラル</span></td>
<td class="xpathOp">
<a href="#func-str" class="SPARQLoperator">str</a>(A)</td>
<td><span class="type simpleLiteral">シンプルなリテラル</span></td>
</tr>
	<tr>
<th scope="row">
<a href="#rBuiltInCall" title="CallExpression"><span class="FAOTtoken">STR</span></a>(A)
	  </th>
	  <td><span class="type IRI">IRI</span></td>
<td class="xpathOp">
<a href="#func-str" class="SPARQLoperator">str</a>(A)</td>
<td><span class="type simpleLiteral">シンプルなリテラル</span></td>
</tr>
	<tr>
<th scope="row">
<a href="#rBuiltInCall" title="CallExpression"><span class="FAOTtoken">LANG</span></a>(A)
	  </th>
	  <td><span class="type literal">リテラル</span></td>
<td class="xpathOp">
<a href="#func-lang" class="SPARQLoperator">lang</a>(A)</td>
<td><span class="type simpleLiteral">シンプルなリテラル</span></td>
</tr>

	<tr>
<th scope="row">
<a href="#rBuiltInCall" title="CallExpression"><span class="FAOTtoken">DATATYPE</span></a>(A)
	  </th>
	  <td><span class="type typedLiteral">型付きリテラル</span></td>
<td class="xpathOp">
<a href="#func-datatype" class="SPARQLoperator">datatype</a>(A)</td>
<td><span class="type IRI">IRI</span></td>
</tr>
	<tr>
<th scope="row">
<a href="#rBuiltInCall" title="CallExpression"><span class="FAOTtoken">DATATYPE</span></a>(A)
	  </th>
	  <td><span class="type simpleLiteral">シンプルなリテラル</span></td>
<td class="xpathOp">
<a href="#func-datatype" class="SPARQLoperator">datatype</a>(A)</td>
<td><span class="type IRI">IRI</span></td>
</tr>
      </tbody>
    </table>

    <table summary="SPARQL Binary Operators" class="FAndOTable">
      <caption>SPARQL二項演算子</caption>
      <tbody>
	<tr>
<th class="major" scope="col">演算子</th>
	  <th class="major" scope="col">型（A）</th>
<th class="major" scope="col">型（B）</th>
<th class="major" scope="col">関数</th>
<th class="major" scope="col">結果の型</th>
</tr>
	<tr><th colspan="5" class="subHeading" scope="col">論理結合子（<a href="#SparqlOps">11.4項</a>で定義されている）</th></tr>

	<tr>
<th><a href="#rConditionalOrExpression" title="ConditionalOrExpression">A <span class="FAOTtoken">||</span> B</a></th>
	  <td>xsd:boolean <a href="#ebv-arg">(EBV)</a>
</td>
<td>xsd:boolean <a href="#ebv-arg">(EBV)</a>
</td>
<td class="sparqlOp">
<a href="#func-logical-or" class="SPARQLoperator">logical-or</a>(A, B)</td>
<td>xsd:boolean</td>
</tr>
	<tr>
<th><a href="#rConditionalAndExpression" title="ConditionalAndExpression">A <span class="FAOTtoken">&amp;&amp;</span> B</a></th>
	  <td>xsd:boolean <a href="#ebv-arg">(EBV)</a>
</td>
<td>xsd:boolean <a href="#ebv-arg">(EBV)</a>
</td>
<td class="sparqlOp">
<a href="#func-logical-and" class="SPARQLoperator">logical-and</a>(A, B)</td>
<td>xsd:boolean</td>
</tr>

	<tr><th colspan="5" class="subHeading" scope="col">XPathテスト</th></tr>

	<!-- eq -->
	<tr>
<th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a></th>
	  <td><span class="type numeric">数値</span></td>
<td><span class="type numeric">数値</span></td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(A, B)</td>
<td>xsd:boolean</td>
</tr>
	<tr>
<th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a></th>
	  <td><span class="type simpleLiteral">シンプルなリテラル</span></td>
<td><span class="type simpleLiteral">シンプルなリテラル</span></td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(A, B), 0)</td>
<td>xsd:boolean</td>
</tr>
	<tr>
<th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a></th>
	  <td>xsd:string</td>
<td>xsd:string</td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), 0)</td>
<td>xsd:boolean</td>
</tr>
	<tr>
<th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a></th>
	  <td>xsd:boolean</td>
<td>xsd:boolean</td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-boolean-equal">op:boolean-equal</a>(A, B)</td>
<td>xsd:boolean</td>
</tr>
	<tr>
<th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a></th>
	  <td>xsd:dateTime</td>
<td>xsd:dateTime</td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-dateTime-equal">op:dateTime-equal</a>(A, B)</td>
<td>xsd:boolean</td>
</tr>


	<!-- ne -->
	<tr>
<th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a></th>
	  <td><span class="type numeric">数値</span></td>
<td><span class="type numeric">数値</span></td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(A, B))</td>
<td>xsd:boolean</td>
</tr>
	<tr>
<th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a></th>
	  <td><span class="type simpleLiteral">シンプルなリテラル</span></td>
<td><span class="type simpleLiteral">シンプルなリテラル</span></td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(A, B), 0))</td>
<td>xsd:boolean</td>
</tr>
	<tr>
<th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a></th>
	  <td>xsd:string</td>
<td>xsd:string</td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), 0))</td>
<td>xsd:boolean</td>
</tr>
	<!-- tr><th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a></th>
	  <td><span class="type simpleLiteral">simple literal</span></td><td><span class="type simpleLiteral">simple literal</span></td><td class="sparqlOp"><a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="http://www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(A, B), 0))</td><td>xsd:boolean</td></tr -->
	<tr>
<th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a></th>
	  <td>xsd:boolean</td>
<td>xsd:boolean</td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-boolean-equal">op:boolean-equal</a>(A, B))</td>
<td>xsd:boolean</td>
</tr>
	<tr>
<th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a></th>
	  <td>xsd:dateTime</td>
<td>xsd:dateTime</td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-dateTime-equal">op:dateTime-equal</a>(A, B))</td>
<td>xsd:boolean</td>
</tr>

	<!-- lt -->
	<tr id="op_lt">
<th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;</span> B</a></th>
	  <td><span class="type numeric">数値</span></td>
<td><span class="type numeric">数値</span></td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-less-than">op:numeric-less-than</a>(A, B)</td>
<td>xsd:boolean</td>
</tr>
	<tr>
<th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;</span> B</a></th>
	  <td><span class="type simpleLiteral">シンプルなリテラル</span></td>
<td><span class="type simpleLiteral">シンプルなリテラル</span></td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(A, B), -1)</td>
<td>xsd:boolean</td>
</tr>
	<tr>
<th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;</span> B</a></th>
	  <td>xsd:string</td>
<td>xsd:string</td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), -1)</td>
<td>xsd:boolean</td>
</tr>
	<tr>
<th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;</span> B</a></th>	  <td>xsd:boolean</td>
<td>xsd:boolean</td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-boolean-less-than">op:boolean-less-than</a>(A, B)</td>
<td>xsd:boolean</td>
</tr>
	<tr>
<th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;</span> B</a></th>
	  <td>xsd:dateTime</td>
<td>xsd:dateTime</td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-dateTime-less-than">op:dateTime-less-than</a>(A, B)</td>
<td>xsd:boolean</td>
</tr>

	<!-- gt -->
	<tr>
<th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;</span> B</a></th>
	  <td><span class="type numeric">数値</span></td>
<td><span class="type numeric">数値</span></td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-greater-than">op:numeric-greater-than</a>(A, B)</td>
<td>xsd:boolean</td>
</tr>
	<tr>
<th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;</span> B</a></th>
	  <td><span class="type simpleLiteral">シンプルなリテラル</span></td>
<td><span class="type simpleLiteral">シンプルなリテラル</span></td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(A, B), 1)</td>
<td>xsd:boolean</td>
</tr>
	<tr>
<th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;</span> B</a></th>
	  <td>xsd:string</td>
<td>xsd:string</td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), 1)</td>
<td>xsd:boolean</td>
</tr>
	<tr>
<th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;</span> B</a></th>
	  <td>xsd:boolean</td>
<td>xsd:boolean</td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-boolean-greater-than">op:boolean-greater-than</a>(A, B)</td>
<td>xsd:boolean</td>
</tr>
	<tr>
<th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;</span> B</a></th>
	  <td>xsd:dateTime</td>
<td>xsd:dateTime</td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-dateTime-greater-than">op:dateTime-greater-than</a>(A, B)</td>
<td>xsd:boolean</td>
</tr>

	<!-- le -->
	<tr>
<th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;=</span> B</a></th>
	  <td><span class="type numeric">数値</span></td>
<td><span class="type numeric">数値</span></td>
<td class="xpathOp">
<a href="#func-logical-or" class="SPARQLoperator">logical-or</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-less-than">op:numeric-less-than</a>(A, B), <a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(A, B))</td>
<td>xsd:boolean</td>
</tr>
	<tr>
<th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;=</span> B</a></th>
	  <td><span class="type simpleLiteral">シンプルなリテラル</span></td>
<td><span class="type simpleLiteral">シンプルなリテラル</span></td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(A, B), 1))</td>
<td>xsd:boolean</td>
</tr>
	<tr>
<th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;=</span> B</a></th>
	  <td>xsd:string</td>
<td>xsd:string</td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), 1))</td>
<td>xsd:boolean</td>
</tr>
	<tr>
<th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;=</span> B</a></th>
	  <td>xsd:boolean</td>
<td>xsd:boolean</td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-boolean-greater-than">op:boolean-greater-than</a>(A, B))</td>
<td>xsd:boolean</td>
</tr>
	<tr>
<th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;=</span> B</a></th>
	  <td>xsd:dateTime</td>
<td>xsd:dateTime</td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-dateTime-greater-than">op:dateTime-greater-than</a>(A, B))</td>
<td>xsd:boolean</td>
</tr>

	<!-- ge -->
	<tr>
<th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;=</span> B</a></th>
	  <td><span class="type numeric">数値</span></td>
<td><span class="type numeric">数値</span></td>
<td class="xpathOp">
<a href="#func-logical-or" class="SPARQLoperator">logical-or</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-greater-than">op:numeric-greater-than</a>(A, B), <a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(A, B))</td>
<td>xsd:boolean</td>
</tr>
	<tr>
<th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;=</span> B</a></th>
	  <td><span class="type simpleLiteral">シンプルなリテラル</span></td>
<td><span class="type simpleLiteral">シンプルなリテラル</span></td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(A, B), -1))</td>
<td>xsd:boolean</td>
</tr>
	<tr>
<th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;=</span> B</a></th>
	  <td>xsd:string</td>
<td>xsd:string</td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), -1))</td>
<td>xsd:boolean</td>
</tr>
	<tr>
<th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;=</span> B</a></th>
	  <td>xsd:boolean</td>
<td>xsd:boolean</td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-boolean-less-than">op:boolean-less-than</a>(A, B))</td>
<td>xsd:boolean</td>
</tr>
	<tr>
<th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;=</span> B</a></th>
	  <td>xsd:dateTime</td>
<td>xsd:dateTime</td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-dateTime-less-than">op:dateTime-less-than</a>(A, B))</td>
<td>xsd:boolean</td>
</tr>

	<tr><th colspan="5" class="subHeading" scope="col">XPath計算</th></tr>

	<tr>
<th scope="row"><a href="#rMultiplicativeExpression" title="MultiplicativeExpression">A <span class="FAOTtoken">*</span> B</a></th>	  <td><span class="type numeric">数値</span></td>
<td><span class="type numeric">数値</span></td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-multiply">op:numeric-multiply</a>(A, B)</td>
<td><span class="type numeric">数値</span></td>
</tr>
	<tr>
<th scope="row"><a href="#rMultiplicativeExpression" title="MultiplicativeExpression">A <span class="FAOTtoken">/</span> B</a></th>
	  <td><span class="type numeric">数値</span></td>
<td><span class="type numeric">数値</span></td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-divide">op:numeric-divide</a>(A, B)</td>
<td>
<span class="type numeric">数値</span>; but xsd:decimal if both operands are xsd:integer</td>
</tr>

	<tr>
<th scope="row"><a href="#rAdditiveExpression" title="AdditiveExpression">A <span class="FAOTtoken">+</span> B</a></th>
	  <td><span class="type numeric">数値</span></td>
<td><span class="type numeric">数値</span></td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-add">op:numeric-add</a>(A, B)</td>
<td><span class="type numeric">数値</span></td>
</tr>
	<tr>
<th scope="row"><a href="#rAdditiveExpression" title="AdditiveExpression">A <span class="FAOTtoken">-</span> B</a></th>
	  <td><span class="type numeric">数値</span></td>
<td><span class="type numeric">数値</span></td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-subtract">op:numeric-subtract</a>(A, B)</td>
<td><span class="type numeric">数値</span></td>
</tr>


	<tr><th colspan="5" class="subHeading" scope="col">SPARQLテスト（<a href="#SparqlOps">11.4項</a>で定義されている）</th></tr>

	<tr>
<th><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a></th>
	  <td><span class="type RDFterm">RDF用語</span></td>
<td><span class="type RDFterm">RDF用語</span></td>
<td class="xpathOp">
<a href="#func-RDFterm-equal" class="SPARQLoperator">RDFterm-equal</a>(A, B)</td>
<td>xsd:boolean</td>
</tr>
	<tr>
<th><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a></th>
	  <td><span class="type RDFterm">RDF用語</span></td>
<td><span class="type RDFterm">RDF用語</span></td>
<td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a href="#func-RDFterm-equal" class="SPARQLoperator">RDFterm-equal</a>(A, B))</td>
<td>xsd:boolean</td>
</tr>
	<tr>
<th scope="row">
<a href="#rBuiltInCall" title="CallExpression"><span class="FAOTtoken">sameTERM</span></a>(A)
	  </th>
	  <td><span class="type RDFterm">RDF用語</span></td>
<td><span class="type RDFterm">RDF用語</span></td>
<td class="xpathOp">
<a href="#func-sameTerm" class="SPARQLoperator">sameTerm</a>(A, B)</td>
<td>xsd:boolean</td>
</tr>

	<tr>
<th scope="row">
<a href="#rBuiltInCall" title="CallExpression"><span class="FAOTtoken">langMATCHES</span></a>(A, B)
	  </th>
	  <td><span class="type simpleLiteral">シンプルなリテラル</span></td>
<td><span class="type simpleLiteral">シンプルなリテラル</span></td>
<td class="xpathOp">
<a href="#func-langMatches" class="SPARQLoperator">langMatches</a>(A, B)</td>
<td>xsd:boolean</td>
</tr>

	<tr>
<th>
<a href="#rRegexExpression" title="Regular Expression"><span class="FAOTtoken">REGEX</span></a>(STRING, PATTERN)</th>
	  <td><span class="type simpleLiteral">シンプルなリテラル</span></td>
<td><span class="type simpleLiteral">シンプルなリテラル</span></td>
<td class="sparqlOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-matches">fn:matches</a>(STRING, PATTERN)</td>
<td>xsd:boolean</td>
</tr>
      </tbody>
  </table>

    <table summary="SPARQL Trinary Operators" class="FAndOTable">
      <caption>SPARQL三項演算子</caption>      <tbody>
	<tr>
<th class="major" scope="col">演算子</th>
	  <th class="major" scope="col">型（A）</th>
<th class="major" scope="col">型（B）</th>
<th class="major" scope="col">型（C）</th>
<th class="major" scope="col">関数</th>
<th class="major" scope="col">結果の型</th>
</tr>
	<tr><th colspan="6" class="subHeading" scope="col">SPARQLテスト（<a href="#SparqlOps">11.4項</a>で定義されている）</th></tr>
	<tr>
<th>
<a href="#rRegexExpression" title="Regular Expression"><span class="FAOTtoken">REGEX</span></a>(STRING, PATTERN, FLAGS)</th>
	  <td><span class="type simpleLiteral">シンプルなリテラル</span></td>
<td><span class="type simpleLiteral">シンプルなリテラル</span></td>
<td><span class="type simpleLiteral">シンプルなリテラル</span></td>
<td class="sparqlOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-matches">fn:matches</a>(STRING, PATTERN, FLAGS)</td>
<td>xsd:boolean</td>
</tr>
	<!-- tr><td colspan="5">The <code>fn:matches</code> function is defined in XPath. Its use in SPARQL and an example invocation are described in <a href="#funcex-regex">section 11.4.12</a>.</td></tr -->
      </tbody>
    </table>

    <p><a id="ebv-arg" name="ebv-arg"></a>「(EBV)」と共にマーク付けされたxsd:boolean関数の引数は、<a href="#ebv">その引数の有効なブール値</a>の評価によるxsd:booleanに強制されます。</p>

    <h4>11.3.1 <a id="operatorExtensibility" name="operatorExtensibility">演算子の拡張性</a>
</h4>

    <p>SPARQLの言語拡張は、演算子と演算子関数の間の付加的な関連付けを提供でき、これは、上記の表に列を加えることに等しいです。付加的な演算子は、上記で定義したセマンティクスにおける型エラー以外の結果に代わる結果をもたらさないかもしれません。この規則の結果は、SPARQLの拡張が<em>少なくとも</em>同じソリューションを未拡張の実装として作成し、いくつかのクエリに対し、より多くのソリューションを作成するかもしれないというものです。</p>

    <p>「&lt;」演算子の追加マッピングは、特に、<a href="#modOrderBy"><code>ORDER BY</code></a>句で用いられるときに、オペランドの相対的な順序付けを制御すると予想されます。</p>

    <h3>11.4 <a id="SparqlOps" name="SparqlOps">演算子の定義</a>
</h3>

    <p>この項では、SPARQLクエリ言語で導入された演算子を定義します。例では、適切な文法構造によって呼び出される際の演算子の動作を示しています。</p>

    <h4>11.4.1 <a id="func-bound" name="func-bound" class="SPARQLoperator">バインド</a>
</h4>

  <pre class="prototype">
 <code class="return" title="return">xsd:boolean</code>&nbsp;&nbsp;&nbsp;<code class="operator" title="operator">bound</code> (<code class="parm type" title="paramter type">variable</code> <code class="parm name" title="parameter name">var</code>)
</pre>

    <p><code>var</code>が値にバインドされている場合は、真（true）を返します。そうでない場合は、偽（false）を返します。NaNまたはINFの値を持つ変数は、バインドされているとみなされます。</p>

  <div class="exampleGroup">
  <p>データ:</p>

  <pre class="data">
@prefix foaf:        &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix dc:          &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix xsd:          &lt;http://www.w3.org/2001/XMLSchema#&gt; .

_:a  foaf:givenName  "Alice".

_:b  foaf:givenName  "Bob" .
_:b  dc:date         "2005-04-04T04:04:04Z"^^xsd:dateTime .</pre>

  <div class="queryGroup">
  <pre class="query">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX xsd:   &lt;http://www.w3.org/2001/XMLSchema#&gt;SELECT ?name
 WHERE { ?x foaf:givenName  ?givenName .
         OPTIONAL { ?x dc:date ?date } .
         FILTER ( bound(?date) ) }
</pre>

  <p>クエリ結果:</p>

  <div class="result">
      <table class="resultTable">
        <tbody>
          <tr>
            <th>givenName</th>
          </tr>

          <tr>
            <td>"Bob&quot;</td>
          </tr>
        </tbody>
      </table>
  </div>
</div>

    <p>変数を導入する<a><code class="term">OPTIONAL</code></a><a>グラフ・パターン</a>を指定し、変数がバインドされていない（<a><code class="term">not</code></a> <a><code class="term">bound</code></a>）ことを確認するテストを行うことによってグラフ・パターンが表されて<em>いない</em>ことをテストできます。これは論理プログラミングでは、<em>失敗による否定</em>（Negation as Failure）と呼ばれます。</p>

  <div class="queryGroup">

  <p>このクエリは、名前（<code>name</code>）を持つが、日付（<code>date</code>）の表現を持た<em>ない</em>人にマッチします。</p>

  <pre class="query">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT ?name
 WHERE { ?x foaf:givenName  ?name .
         OPTIONAL { ?x dc:date ?date } .
         FILTER (!bound(?date)) }</pre>

  <p>クエリ結果:</p>

  <div class="result">
      <table class="resultTable">
        <tbody>
          <tr>
            <th>name</th>
          </tr>

          <tr>
            <td>"Alice&quot;</td>
          </tr>
        </tbody>
      </table>
  </div>
</div>
</div>

  <p>Bobの<code>dc:date</code>は既知であったため、<code>"Bob"</code>はクエリのソリューションにはなりませんでした。</p>

    <h4>11.4.2 <a id="func-isIRI" name="func-isIRI" class="SPARQLoperator">isIRI</a>
</h4>

  <pre class="prototype">
 <code class="return" title="return">xsd:boolean</code>&nbsp;&nbsp;&nbsp;<code class="operator" title="operator">isIRI</code> (<code class="parm type" title="paramter type">RDF term</code> <code class="parm name" title="parameter name">term</code>)
 <code class="return" title="return">xsd:boolean</code>&nbsp;&nbsp;&nbsp;<code class="operator" title="operator">isURI</code> (<code class="parm type" title="paramter type">RDF term</code> <code class="parm name" title="parameter name">term</code>)
</pre>

    <p>用語（<code>term</code>）が<span class="type IRI">IRI</span>である場合は、真（<code>true</code>）を返します。そうでない場合は、偽（<code>false</code>）を返します。<code class="operator" title="operator">isURI</code>は、<code class="operator" title="operator">isIRI</code>演算子の別のスペルです。</p>

  <div class="exampleGroup">
  <pre class="data">
@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice".
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       "bob@work.example" .
</pre>

  <div class="queryGroup">

  <p>このクエリは、名前（<code>name</code>）と、IRIである<code>mbox</code>を持つ人にマッチします。</p>

  <pre class="query">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
 WHERE { ?x foaf:name  ?name ;
            foaf:mbox  ?mbox .
         FILTER isIRI(?mbox) }
</pre>

  <p>クエリ結果:</p>

  <div class="result">
      <table class="resultTable">
        <tbody>
          <tr>
            <th>name</th>
            <th>mbox</th>
          </tr>

          <tr>
            <td>"Alice"</td>
            <td>&lt;mailto:alice@work.example&gt;</td>
          </tr>
        </tbody>
      </table>
  </div>
</div>
</div>

    <h4>11.4.3 <a id="func-isBlank" name="func-isBlank" class="SPARQLoperator">isBlank</a>
</h4>

  <pre class="prototype">
 <code class="return" title="return">xsd:boolean</code>&nbsp;&nbsp;&nbsp;<code class="operator" title="operator">isBlank</code> (<code class="parm type" title="paramter type">RDF term</code> <code class="parm name" title="parameter name">term</code>)
</pre>

    <p>用語（<code>term</code>）が<span class="type bNode">空白ノード</span>である場合は、真（<code>true</code>）を返します。そうでない場合は、偽（<code>false</code>）を返します。</p>

  <div class="exampleGroup">
  <pre class="data">@prefix a:          &lt;http://www.w3.org/2000/10/annotation-ns#&gt; .
@prefix dc:         &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a   a:annotates   &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
_:a   dc:creator    &quot;Alice B. Toeclips&quot; .

_:b   a:annotates   &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
_:b   dc:creator    _:c .
_:c   foaf:given    &quot;Bob&quot;.
_:c   foaf:family   &quot;Smith&quot;.</pre>

  <div class="queryGroup">

  <p>このクエリは、名前を表すためにFOAF語彙の述語を用いている<code>dc:creator</code>を持つ人にマッチします。</p>

  <pre class="query">PREFIX a:      &lt;http://www.w3.org/2000/10/annotation-ns#&gt;PREFIX dc:     &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?given ?family
 WHERE { ?annot  a:annotates  &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
         ?annot  dc:creator   ?c .
         OPTIONAL { ?c  foaf:given   ?given ; foaf:family  ?family } .
         FILTER isBlank(?c)
       }</pre>

  <p>クエリ結果:</p>

  <div class="result">
      <table class="resultTable">
        <tbody>          <tr>
            <th>given</th>
            <th>family</th>
          </tr>

          <tr>
            <td>"Bob"</td>
            <td>"Smith"</td>
          </tr>
        </tbody>
      </table>
  </div>
</div>
</div>

    <p>この例では、<code>foaf:knows</code>という述語の目的語が2つありましたが、たった1つの（<code>_:c</code>）が空白ノードでした。</p>

    <h4>11.4.4 <a id="func-isLiteral" name="func-isLiteral" class="SPARQLoperator">isLiteral</a>
</h4>

  <pre class="prototype">
 <code class="return" title="return">xsd:boolean</code>&nbsp;&nbsp;&nbsp;<code class="operator" title="operator">isLiteral</code> (<code class="parm type" title="paramter type">RDF term</code> <code class="parm name" title="parameter name">term</code>)
</pre>

    <p>用語（<code>term</code>）が<span class="type literal">リテラル</span>である場合、真（<code>true</code>）を返します。そうでない場合は、偽（<code>false</code>）を返します。</p>

  <div class="exampleGroup">
  <pre class="data">
@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice".
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       "bob@work.example" .
</pre>

  <div class="queryGroup">

  <p>このクエリは、名前（<code>name</code>）と、リテラルである<code>mbox</code>を持つ人にマッチする点を除いて、<a href="#func-isIRI">11.4.2</a>のものと類似しています。これは、エラーのあるデータを探すために使用できるでしょう（<code>foaf:mbox</code>は、目的語として1つのIRIのみを持っているはずです）。</p>

  <pre class="query">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
 WHERE { ?x foaf:name  ?name ;
           foaf:mbox  ?mbox .
         FILTER isLiteral(?mbox) }
</pre>

  <p>クエリ結果:</p>

  <div class="result">
      <table class="resultTable">
        <tbody>
          <tr>
            <th>name</th>
            <th>mbox</th>
          </tr>
          <tr>
            <td>"Bob"</td>
            <td>"bob@work.example"</td>
          </tr>
        </tbody>
      </table>
  </div>
</div>
</div>

    <h4>11.4.5 <a id="func-str" name="func-str" class="SPARQLoperator">str</a>
</h4>

  <pre class="prototype">
 <code class="return" title="return"><span class="type simpleLiteral">simple literal</span></code>&nbsp;&nbsp;&nbsp;<code class="operator" title="operator">str</code> (<code class="parm type" title="paramter type"><span class="type literal">literal</span></code> <code class="parm name" title="parameter name">ltrl</code>)
 <code class="return" title="return"><span class="type simpleLiteral">simple literal</span></code>&nbsp;&nbsp;&nbsp;<code class="operator" title="operator">str</code> (<code class="parm type" title="paramter type"><span class="type IRI">IRI</span></code> <code class="parm name" title="parameter name">rsrc</code>)
</pre>

    <p><code>ltrl</code>（<span class="type literal">リテラル</span>）の字句形式を返し、<code>rsrc</code>（<span class="type IRI">IRI</span>）コードポイント表現を返します。これは、IRIの部分、例えば、ホスト名を調べるのに役に立ちます。</p>

  <div class="exampleGroup">
  <pre class="data">
@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice".
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       &lt;mailto:bob@home.example&gt; .
</pre>

  <div class="queryGroup">

  <p>このクエリは、次のとおり、自分達のfoafプロフィールで<code>work.example</code>のアドレスを使用する人々の集合を選び出します。</p>

  <pre class="query">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
 WHERE { ?x foaf:name  ?name ;
            foaf:mbox  ?mbox .
         FILTER regex(str(?mbox), &quot;@work.example&quot;) }</pre>

  <p>クエリ結果:</p>

  <div class="result">
      <table class="resultTable">
        <tbody>
          <tr>
            <th>name</th>
            <th>mbox</th>
          </tr>

          <tr>
            <td>"Alice"</td>
            <td>&lt;mailto:alice@work.example&gt;</td>
          </tr>
        </tbody>
      </table>
  </div>
</div>
</div>

    <h4>11.4.6 <a id="func-lang" name="func-lang" class="SPARQLoperator">lang</a>
</h4>

  <pre class="prototype">
 <code class="return" title="return"><span class="type simpleLiteral">simple literal</span></code>&nbsp;&nbsp;&nbsp;<code class="operator" title="operator">lang</code> (<code class="parm type" title="paramter type"><span class="type literal">literal</span></code> <code class="parm name" title="parameter name">ltrl</code>)
</pre>

    <p><code>ltrl</code>の言語タグ（<code class="type langTag">language tag</code>）（それがある場合）を返します。<code>ltrl</code>に言語タグ（<code class="type langTag">language tag</code>）がない場合は、<code>""</code>を返します。RDFデータ・モデルが空の言語タグ（<code class="type langTag">language tag</code>）を持つリテラルを含んでいないことに注意してください。</p>

  <div class="exampleGroup">
  <pre class="data">
@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Robert"@EN.
_:a  foaf:name       "Roberto"@ES.
_:a  foaf:mbox       &lt;mailto:bob@work.example&gt; .
</pre>

  <div class="queryGroup">

  <p>このクエリは、スペイン語の<code>foaf:name</code>と<code>foaf:mbox</code>を発見します。</p>

  <pre class="query">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
 WHERE { ?x foaf:name  ?name ;
            foaf:mbox  ?mbox .
         FILTER ( lang(?name) = "ES" ) }</pre>

  <p>クエリ結果:</p>

  <div class="result">
      <table class="resultTable">
        <tbody>
          <tr>
            <th>name</th>
            <th>mbox</th>
          </tr>

          <tr>
            <td>"Roberto"@ES</td>
            <td>&lt;mailto:bob@work.example&gt;</td>
          </tr>
        </tbody>
      </table>
  </div>
</div>
</div>

    <h4>11.4.7 <a id="func-datatype" name="func-datatype" class="SPARQLoperator">datatype</a>
</h4>

  <pre class="prototype">
 <code class="return" title="return"><span class="type IRI">IRI</span></code>&nbsp;&nbsp;&nbsp;<code class="operator" title="operator">datatype</code> (<code class="parm type" title="paramter type"><span class="type typedLiteral">typed literal</span></code> <code class="parm name" title="parameter name">typedLit</code>)
 <code class="return" title="return"><span class="type IRI">IRI</span></code>&nbsp;&nbsp;&nbsp;<code class="operator" title="operator">datatype</code> (<code class="parm type" title="paramter type"><span class="type simpleLiteral">simple literal</span></code> <code class="parm name" title="parameter name">simpleLit</code>)
</pre>
    <p><code>typedLit</code>のデータ型IRI（<code class="type datatypeIRI">datatype IRI</code>）を返し、パラメータが<span class="type simpleLiteral">シンプルなリテラル</span>である場合は、<code>xsd:string</code>を返します。</p>

  <div class="exampleGroup">
  <pre class="data">
@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix eg:         &lt;http://biometrics.example/ns#&gt; .
@prefix xsd:        &lt;http://www.w3.org/2001/XMLSchema#&gt; .

_:a  foaf:name       "Alice".
_:a  eg:shoeSize     "9.5"^^xsd:float .

_:b  foaf:name       "Bob".
_:b  eg:shoeSize     "42"^^xsd:integer .
</pre>

  <div class="queryGroup">

  <p>このクエリは、整数であるshoeSizeを持つすべての人の<code>foaf:name</code>と<code>foaf:shoeSize</code>を発見します。</p>

  <pre class="query">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX xsd:  &lt;http://www.w3.org/2001/XMLSchema#&gt;
PREFIX eg:   &lt;http://biometrics.example/ns#&gt;
SELECT ?name ?shoeSize
 WHERE { ?x foaf:name  ?name ; eg:shoeSize  ?shoeSize .
         FILTER ( datatype(?shoeSize) = xsd:integer ) }</pre>

  <p>クエリ結果:</p>

  <div class="result">
      <table class="resultTable">
        <tbody>
          <tr>
            <th>name</th>
            <th>shoeSize</th>
          </tr>

          <tr>
            <td>"Bob"</td>
            <td>42</td>
          </tr>        </tbody>
      </table>
  </div>
</div>
</div>

    <h4>11.4.8 <a id="func-logical-or" name="func-logical-or" class="SPARQLoperator">logical-or</a>
</h4>

  <pre class="prototype">
 <code class="return" title="return">xsd:boolean</code>&nbsp;&nbsp;&nbsp;<code class="parm type" title="paramter type">xsd:boolean</code> <code class="parm name" title="parameter name">left</code> <code class="operator" title="operator">||</code> <code class="parm type" title="parameter type">xsd:boolean</code> <code class="parm name" title="parameter name">right</code>
</pre>

    <p>左（<code>left</code>）と右（<code>right</code>）の論理和（<code>OR</code>）を返します。<code class="SPARQLoperator">logical-or</code>がその引数の<a href="#ebv">有効なブール値</a>に基づいて演算を行うことに注意してください。</p>

    <p>注意: <code>||</code>演算子のエラーの処理に関しては、11.2項の<a href="#evaluation">フィルタ評価</a>を参照してください。</p>

    <h4>11.4.9 <a id="func-logical-and" name="func-logical-and" class="SPARQLoperator">logical-and</a>
</h4>

  <pre class="prototype">
 <code class="return" title="return">xsd:boolean</code>&nbsp;&nbsp;&nbsp;<code class="parm type" title="paramter type">xsd:boolean</code> <code class="parm name" title="parameter name">left</code> <code class="operator" title="operator">&amp;&amp;</code> <code class="parm type" title="parameter type">xsd:boolean</code> <code class="parm name" title="parameter name">right</code>
</pre>

    <p>左（<code>left</code>）と右（<code>right</code>）の論理積（<code>AND</code>）を返します。<code class="SPARQLoperator">logical-and</code>がその引数の<a href="#ebv">有効なブール値</a>に基づいて演算することに注意してください。</p>

    <p>注意: <code>&amp;&amp;</code>演算子のエラーの処理に関しては、11.2項の<a href="#evaluation">フィルタ評価</a>を参照してください。</p>

    <h4>11.4.10 <a id="func-RDFterm-equal" name="func-RDFterm-equal" class="SPARQLoperator">RDFterm-equal</a>
</h4>

  <pre class="prototype">
 <code class="return" title="return">xsd:boolean</code>&nbsp;&nbsp;&nbsp;<code class="parm type" title="paramter type">RDF term</code> <code class="parm name" title="parameter name">term1</code> <code class="operator" title="operator">=</code> <code class="parm type" title="parameter type">RDF term</code> <code class="parm name" title="parameter name">term2</code>
</pre>

    <p><a class="norm" href="www.w3.org/TR/rdf-concepts/">RDF（Resource Description Framework）:  概念および抽象構文</a>[<a href="#CONCEPTS">CONCEPTS</a>]で定義されているとおり、<code>term1</code>と<code>term2</code>が同じRDF用語<sup><a href="#func-RDFterm-equal-foot1" class="footnote">*</a></sup>でない場合は、TRUEを返します。両方の引数がリテラルであるけれども同じRDF用語ではない場合は、型エラーを起こし、そうでない場合は、FALSEを返します。次のいずれかが真である場合は、<code>term1</code>と<code>term2</code>は同じです。</p>

    <ul>
      <li>
<code class="parm name" title="parameter name">term1</code>と<code class="parm name" title="parameter name">term2</code>は、[<a href="#CONCEPTS">CONCEPTS</a>]の<a href="www.w3.org/TR/rdf-concepts/#section-Graph-URIref">6.4 RDF URI参照</a>で定義されているとおり、同等な<span class="IRI type">IRI</span>です。</li>
      <li>
<code class="parm name" title="parameter name">term1</code>と<code class="parm name" title="parameter name">term2</code>は、[<a href="#CONCEPTS">CONCEPTS</a>]の<a class="norm" href="www.w3.org/TR/rdf-concepts/#section-Literal-Equality">6.5.1 リテラルの同等性</a>で定義されているとおり、同等な<span class="literal type">リテラル</span>です。</li>
      <li>
<code class="parm name" title="parameter name">term1</code>と<code class="parm name" title="parameter name">term2</code>は、[<a href="#CONCEPTS">CONCEPTS</a>]の<a class="norm" href="www.w3.org/TR/rdf-concepts/#section-blank-nodes">6.6 空白ノード</a>で述べられているとおり、同じ空白ノードです。</li>
    </ul>

  <div class="exampleGroup">
  <pre class="data">
@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice".
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Ms A.".
_:b  foaf:mbox       &lt;mailto:alice@work.example&gt; .
</pre>

  <div class="queryGroup">

  <p>このクエリは、複数の<code>foaf:name</code>トリプルを持つ人を発見します。</p>

  <pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name1 ?name2
 WHERE { ?x foaf:name  ?name1 ;
            foaf:mbox  ?mbox1 .
         ?y foaf:name  ?name2 ;
            foaf:mbox  ?mbox2 .
         FILTER (?mbox1 = ?mbox2 &amp;&amp; ?name1 != ?name2)
       }
</pre>

  <p>クエリ結果:</p>

  <div class="result">
      <table class="resultTable">
        <tbody>
          <tr>
            <th>name1</th>
            <th>name2</th>
          </tr>

          <tr>
            <td>"Alice"</td>
            <td>"Ms A."</td>
          </tr>

          <tr>
            <td>"Ms A."</td>
            <td>"Alice"</td>
          </tr>        </tbody>
      </table>
  </div>
</div>
</div>

    <p>元日（2004年か2005年）にアノテーションを付与されたドキュメントに関するこのクエリは、RDF用語は同じではありませんが、同等な値を持っています。</p>

  <div class="exampleGroup">
  <pre class="data">@prefix a:          &lt;http://www.w3.org/2000/10/annotation-ns#&gt; .
@prefix dc:         &lt;http://purl.org/dc/elements/1.1/&gt; .

_:b   a:annotates   &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
_:b   dc:date       &quot;2004-12-31T19:00:00-05:00&quot;^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .</pre>

  <div class="queryGroup">
  <pre class="query">
PREFIX a:      &lt;http://www.w3.org/2000/10/annotation-ns#&gt;
PREFIX dc:     &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX xsd:    &lt;http://www.w3.org/2001/XMLSchema#&gt;

SELECT ?annotates
WHERE { ?annot  a:annotates  ?annotates .
        ?annot  dc:date      ?date .
        FILTER ( ?date = xsd:dateTime(&quot;2005-01-01T00:00:00Z&quot;) ) }</pre>

  <div class="result">
      <table class="resultTable">
        <tbody>
          <tr>
            <th>annotates</th>
          </tr>

          <tr>
            <td>&lt;http://www.w3.org/TR/rdf-sparql-query/&gt;</td>
          </tr>
        </tbody>
      </table>
  </div>
</div>
</div>

    <p><sup id="func-RDFterm-equal-foot1" class="footnote">*</sup> 2つの型付きリテラルにRDFterm-equalを呼び出すことで、同等な値をテストします。拡張された実装には、付加的なデータ型のサポートがあるかもしれません。未サポートのデータ型（および、異なる字句形式とデータ型IRI）の同等性をテストするクエリを処理する実装はエラーを返し、値が同等かどうかを決定できなかったことを示します。例えば、<span class="queryExcerpt untested"><code>"iiii"^^my:romanNumeral = "iv"^^my:romanNumeral</code></span>か<span class="queryExcerpt untested"><code>"iiii"^^my:romanNumeral != "iv"^^my:romanNumeral</code></span>のいずれかのテストを行った場合、未拡張の実装にエラーが生じます。</p>

    <h4>11.4.11 <a id="func-sameTerm" name="func-sameTerm" class="SPARQLoperator">sameTerm</a>
</h4>

  <pre class="prototype">
 <code class="return">xsd:boolean</code>&nbsp;&nbsp;&nbsp;<code class="operator">sameTerm</code> (<code class="parm type"><span class="type RDFterm">RDF term</span></code> <code class="parm name">term1</code>, <code class="parm type"><span class="type RDFterm">RDF term</span></code> <code class="parm name">term2</code>)
</pre>

    <p><a class="norm" href="www.w3.org/TR/rdf-concepts/">RDF（Resource Description Framework）:  概念および抽象構文</a>[<a href="#CONCEPTS">CONCEPTS</a>]で定義されているとおり、<code>term1</code>と<code>term2</code>が同じRDF用語である場合は、TRUEを返し、そうでない場合は、FALSEを返します。</p>

  <div class="exampleGroup">
  <pre class="data">
@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice".
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Ms A.".
_:b  foaf:mbox       &lt;mailto:alice@work.example&gt; .
</pre>
  <div class="queryGroup">

  <p>このクエリは、複数の<code>foaf:name</code>トリプルを持つ人を発見します。</p>

  <pre class="query">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name1 ?name2
 WHERE { ?x foaf:name  ?name1 ;
            foaf:mbox  ?mbox1 .
         ?y foaf:name  ?name2 ;
            foaf:mbox  ?mbox2 .
         FILTER (sameTerm(?mbox1, ?mbox2) &amp;&amp; !sameTerm(?name1, ?name2))
       }
</pre>

  <p>クエリ結果:</p>

  <div class="result">
      <table class="resultTable">
        <tbody>
          <tr>
            <th>name1</th>
            <th>name2</th>
          </tr>

          <tr>
            <td>"Alice"</td>
            <td>"Ms A."</td>
          </tr>

          <tr>
            <td>"Ms A."</td>
            <td>"Alice"</td>
          </tr>
        </tbody>
      </table>
  </div>
</div>
</div>

    <p><code class="operatro">RDFterm-equal</code>とは異なり、<code class="operatro">sameTerm</code>は、未サポートのデータ型を持つ非同等な<span class="type typedLiteral">型付きリテラル</span>をテストするために使用できます。</p>

  <div class="exampleGroup">  <pre class="data">@prefix :          &lt;http://example.org/WMterms#&gt; .
@prefix t:         &lt;http://example.org/types#&gt; .
_:c1  :label        "Container 1" .
_:c1  :weight       "100"^^t:kilos .
_:c1  :displacement  "100"^^t:liters .

_:c2  :label        "Container 2" .
_:c2  :weight       "100"^^t:kilos .
_:c2  :displacement  "85"^^t:liters .

_:c3  :label        "Container 3" .
_:c3  :weight       "85"^^t:kilos .
_:c3  :displacement  "85"^^t:liters .</pre>

  <div class="queryGroup">
  <pre class="query">
PREFIX  :      &lt;http://example.org/WMterms#&gt;
PREFIX  t:     &lt;http://example.org/types#&gt;

SELECT ?aLabel1 ?bLabel
WHERE { ?a  :label        ?aLabel .
        ?a  :weight       ?aWeight .
        ?a  :displacement ?aDisp .

        ?b  :label        ?bLabel .
        ?b  :weight       ?bWeight .
        ?b  :displacement ?bDisp .
        FILTER ( sameTerm(?aWeight, ?bWeight) &amp;&amp; !sameTerm(?aDisp, ?bDisp) }</pre>

  <div class="result">
      <table class="resultTable">
        <tbody>
          <tr>
            <th>aLabel</th>
            <th>bLabel</th>
          </tr>

          <tr>
            <td>"Container 1"</td>
            <td>"Container 2"</td>
          </tr>
          <tr>
            <td>"Container 2"</td>
            <td>"Container 1"</td>
          </tr>
        </tbody>
      </table>
  </div>
</div>
</div>

    <p><code>"100"^^t:kilos = "85"^^t:kilos</code>のテストが、その生成されうるソリューションを排除して、エラーをもたらすため、同じ重さの箱のテストは「=」演算子（<a href="#func-RDFterm-equal" class="SPARQLoperator">RDFterm-equal</a>）でも行えます。</p>

   <h4>11.4.12 <a id="func-langMatches" name="func-langMatches" class="SPARQLoperator">langMatches</a>
</h4>

  <pre class="prototype">
 <code class="return">xsd:boolean</code>&nbsp;&nbsp;&nbsp;<code class="operator">langMatches</code> (<code class="parm type"><span class="type simpleLiteral">simple literal</span></code> <code class="parm name">language-tag</code>, <code class="parm type"><span class="type simpleLiteral">simple literal</span></code> <code class="parm name">language-range</code>)
</pre>

    <p><code>language-tag</code>（最初の引数）が、[<a href="#rfc4647">RFC4647</a>]の3.3.1項で定義されている基本的なフィルタリング・スキームで<code>language-range</code>（2番目の引数）にマッチする場合は、真（<code>true</code>）を返します。<code>language-range</code>は、[<a href="#rfc4647">RFC4647</a>]の2.1.項の<a class="norm" href="www.ietf.org/rfc/rfc4647.txt">言語タグのマッチング</a>にあるとおりの基本言語の範囲です。「*」の<code>language-range</code>は、任意の空でない<code>language-tag</code>文字列にマッチします。</p>

  <div class="exampleGroup">
  <pre class="data">
@prefix dc:       &lt;http://purl.org/dc/elements/1.1/&gt; .

_:a  dc:title         "That Seventies Show"@en .
_:a  dc:title         "Cette S&eacute;rie des Ann&eacute;es Soixante-dix"@fr .
_:a  dc:title         "Cette S&eacute;rie des Ann&eacute;es Septante"@fr-BE .
_:b  dc:title         "Il Buono, il Bruto, il Cattivo" .
</pre>

  <div class="queryGroup">

  <p>このクエリでは、英語で「That Seventies Show」として知られているショーに対するフランス語のタイトルを発見するために、<code>langMatches</code>と<code>lang</code>（<a href="#func-lang">11.2.3.8項</a>で述べた）を使用しています。</p>

  <pre class="query">
PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT ?title
 WHERE { ?x dc:title  "That Seventies Show"@en ;
            dc:title  ?title .
         FILTER langMatches( lang(?title), "FR" ) }</pre>

  <p>クエリ結果:</p>

  <div class="result">
      <table class="resultTable">
        <tbody>
          <tr>
            <th>title</th>
          </tr>
          <tr> <td>"Cette S&eacute;rie des Ann&eacute;es Soixante-dix"@fr</td> </tr>
          <tr> <td>"Cette S&eacute;rie des Ann&eacute;es Septante"@fr-BE</td> </tr>
        </tbody>
      </table>
  </div>
</div>

  <div class="queryGroup">

  <p>成句的表現<code>langMatches( lang( ?v ), "*" )</code>は、<code>lang( ?v )</code>が空の文字列を返すため、言語タグなしではリテラルにマッチしないでしょう。そのため、</p>

  <pre class="query add">
PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT ?title
 WHERE { ?x dc:title  ?title .
         FILTER langMatches( lang(?title), "*" ) }</pre>

  <p>は、言語タグを持つタイトルのすべてを報告するでしょう。</p>

  <div class="result add">
      <table class="resultTable">
        <tbody>
          <tr>
            <th>title</th>
          </tr>
          <tr> <td>"That Seventies Show"@en</td> </tr>
          <tr> <td>"Cette S&eacute;rie des Ann&eacute;es Soixante-dix"@fr</td> </tr>
          <tr> <td>"Cette S&eacute;rie des Ann&eacute;es Septante"@fr-BE</td> </tr>
        </tbody>
      </table>
  </div>
</div>
</div>

    <h4>11.4.13 <a id="funcex-regex" name="funcex-regex" class="SPARQLoperator">regex</a>
</h4>

  <pre class="prototype">
 <code class="return">xsd:boolean</code>&nbsp;&nbsp;&nbsp;<code class="operator">regex</code> (<code class="parm type"><span class="type simpleLiteral">simple literal</span></code> <code class="parm name">text</code>, <code class="parm type"><span class="type simpleLiteral">simple literal</span></code> <code class="parm name">pattern</code>)
 <code class="return">xsd:boolean</code>&nbsp;&nbsp;&nbsp;<code class="operator">regex</code> (<code class="parm type"><span class="type simpleLiteral">simple literal</span></code> <code class="parm name">text</code>, <code class="parm type"><span class="type simpleLiteral">simple literal</span></code> <code class="parm name">pattern</code>, <code class="parm type"><span class="type simpleLiteral">simple literal</span></code> <code class="parm name">flags</code>)
</pre>

    <p>正規表現パターン（<code>pattern</code>）に対してテキスト（<code>text</code>）をマッチさせるためにXPath <a class="norm" href="www.w3.org/TR/xpath-functions/#func-matches">fn:matches</a>関数を呼び出します。正規表現言語は、XQuery 1.0とXPath 2.0関数および演算子の<a class="norm" href="www.w3.org/TR/xpath-functions/#regex-syntax">7.6.1 正規表現構文</a>[<a href="#FUNCOP">FUNCOP</a>]の項で定義されています。</p>

  <div class="exampleGroup">
  <pre class="data">
@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice"._:b  foaf:name       "Bob" .
</pre>

  <div class="queryGroup">
  <pre class="query">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name
 WHERE { ?x foaf:name  ?name
         FILTER regex(?name, "^ali", "i") }
</pre>

  <p>クエリ結果:</p>

  <div class="result">
      <table class="resultTable">
        <tbody>
          <tr>
            <th>name</th>
          </tr>

          <tr>
            <td>"Alice"</td>
          </tr>
        </tbody>
      </table>
  </div>
</div>
</div>

    <h3>11.5 <a id="FunctionMapping" name="FunctionMapping" class="FAndOTable">コンストラクタ関数</a>
</h3>

    <p>SPARQLは、<a class="norm" href="www.w3.org/TR/xpath-functions/">XQuery 1.0とXPath 2.0関数および演算子</a>[<a href="#FUNCOP">FUNCOP</a>]の<a class="norm" href="www.w3.org/TR/xpath-functions/#casting-from-primitive-to-primitive">17.1 プリミティブ型からプリミティブ型へのキャスティング</a>で定義されているXPathコンストラクタ関数のサブセットをインポートします。SPARQLコンストラクタは、RDFデータ・モデルが規定している<a href="#operandDataTypes">SPARQLオペランド・データ型</a>と<a href="#operandDataTypes">付加的なデータ型</a>のXPathコンストラクタのすべてを含んでいます。SPARQLのキャスティングは、情報源の型のオペランドにターゲット型に対するコンストラクタ関数を呼び出すことによって実行されます。</p>

    <p>XPathは、1つのXMLスキーマ・データ型から別のデータ型へのキャストのみを定義しています。残りのキャストは、次の通り定義されています。</p>

    <ul>
      <li>
<span class="IRI type">IRI</span>を<code>xsd:string</code>にキャストすると、そのIRIを構成するコードポイントの字句値を持つ<span class="IRI typedLiteral">型付きリテラル</span>、および<code>xsd:string</code>のデータ型が作成されます。</li>
      <li>
<span class="simpleLiteral type">シンプルなリテラル</span>のXMLスキーマ・データ型へのキャスティングは、ターゲットのデータ型にリテラルの字句値と等しい<a href="www.w3.org/TR/xpath20/#dt-string-value">文字列値</a>を持つ<code>xsd:string</code>をキャストしたときの生成物であると定義されます。</li>
    </ul>

    <p>次の表では、キャスティング操作が常に許されるもの（<span class="castY">Y</span>）、決して許されないもの（<span class="castN">N</span>）、字句値次第のもの（<span class="castM">M</span>）にまとめています。例えば、<code>xsd:string</code>（最初の行）から<code>xsd:float</code>（2番目の列）へのキャスティング操作は、字句値（<span class="castM">M</span>）次第です。</p>

<blockquote>
<p>bool = <a class="norm" href="www.w3.org/TR/xmlschema-2/#boolean">xsd:boolean</a><br>
dbl = <a class="norm" href="www.w3.org/TR/xmlschema-2/#double">xsd:double</a><br>
flt = <a class="norm" href="www.w3.org/TR/xmlschema-2/#float">xsd:float</a><br>
dec = <a class="norm" href="www.w3.org/TR/xmlschema-2/#decimal">xsd:decimal</a><br>
int = <a class="norm" href="www.w3.org/TR/xmlschema-2/#integer">xsd:integer</a><br>
dT = <a class="norm" href="www.w3.org/TR/xmlschema-2/#dateTime">xsd:dateTime</a><br>
str = <a class="norm" href="www.w3.org/TR/xmlschema-2/#string">xsd:string</a><br><span class="rdfDM">IRI</span> = <span class="type IRI">IRI</span><br>
<span class="rdfDM">ltrl</span> = <code class="type simpleLiteral">simple literal</code></p>
</blockquote>

<table class="casting" summary="Casting table" border="1" cellpadding="1">
<col width="13%" span="1">
<col width="11%" span="1">
<col width="11%" span="1">
<col width="11%" span="1">
<col width="11%" span="1">
<col width="11%" span="1">
<col width="11%" span="1">
<col width="11%" span="1">
<!-- col width="3%" span="1" / -->
<!-- col width="3%" span="1" / -->
<!-- col width="3%" span="1" / -->
<thead>
<tr>
<th><span class="cancast" title="From\To">From \ To</span></th>
<th><span class="cancast" title="string">str</span></th>
<th><span class="cancast" title="float">flt</span></th>
<th><span class="cancast" title="double">dbl</span></th>
<th><span class="cancast" title="decimal">dec</span></th>
<th><span class="cancast" title="integer">int</span></th>
<th><span class="cancast" title="dateTime">dT</span></th>
<th><span class="cancast" title="boolean">bool</span></th>
<!-- th><span class="cancast rdfDM" title="IRI">IRI</span></th -->
<!-- th><span class="cancast rdfDM" title="Literal">ltrl</span></th -->
<!-- th><span class="cancast rdfDM" title="bNode">BN</span></th -->
</tr>
</thead>
<tbody>
<tr>
<th><span class="cancast" title="string">str</span></th>
<td class="castY" align="center" valign="middle"><span class="cancast" title="Cast string to string? Yes">Y</span></td>
<td class="castM" align="center" valign="middle"><span class="cancast" title="Cast string to float? Maybe">M</span></td>
<td class="castM" align="center" valign="middle"><span class="cancast" title="Cast string to double? Maybe">M</span></td>
<td class="castM" align="center" valign="middle"><span class="cancast" title="Cast string to decimal? Maybe">M</span></td>
<td class="castM" align="center" valign="middle"><span class="cancast" title="Cast string to integer? Maybe">M</span></td>
<td class="castM" align="center" valign="middle"><span class="cancast" title="Cast string to dateTime? Maybe">M</span></td>
<td class="castM" align="center" valign="middle"><span class="cancast" title="Cast string to boolean? Maybe">M</span></td>
<!-- td class="castY" align="center" valign="middle"><span class="cancast rdfDM" title="Cast string to IRI? Yes">Y</span></td -->
<!-- td class="castY" align="center" valign="middle"><span class="cancast rdfDM" title="Cast string to Literal? Yes">Y</span></td -->
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast string to bNode? No">N</span></td -->
</tr>
<tr>
<th><span class="cancast" title="float">flt</span></th>
<td class="castY" align="center" valign="middle"><span class="cancast" title="Cast float to string? Yes">Y</span></td>
<td class="castY" align="center" valign="middle"><span class="cancast" title="Cast float to float? Yes">Y</span></td>
<td class="castY" align="center" valign="middle"><span class="cancast" title="Cast float to double? Yes">Y</span></td>
<td class="castM" align="center" valign="middle"><span class="cancast" title="Cast float to decimal? Maybe">M</span></td>
<td class="castM" align="center" valign="middle"><span class="cancast" title="Cast float to integer? Maybe">M</span></td>
<td class="castN" align="center" valign="middle"><span class="cancast" title="Cast float to dateTime? No">N</span></td>
<td class="castY" align="center" valign="middle"><span class="cancast" title="Cast float to boolean? Yes">Y</span></td>
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast float to IRI? No">N</span></td -->
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast float to Literal? No">N</span></td -->
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast float to bNode? No">N</span></td -->
</tr>
<tr>
<th><span class="cancast" title="double">dbl</span></th>
<td class="castY" align="center" valign="middle"><span class="cancast" title="Cast double to string? Yes">Y</span></td>
<td class="castY" align="center" valign="middle"><span class="cancast" title="Cast double to float? Yes">Y</span></td>
<td class="castY" align="center" valign="middle"><span class="cancast" title="Cast double to double? Yes">Y</span></td>
<td class="castM" align="center" valign="middle"><span class="cancast" title="Cast double to decimal? Maybe">M</span></td>
<td class="castM" align="center" valign="middle"><span class="cancast" title="Cast double to integer? Maybe">M</span></td>
<td class="castN" align="center" valign="middle"><span class="cancast" title="Cast double to dateTime? No">N</span></td>
<td class="castY" align="center" valign="middle"><span class="cancast" title="Cast double to boolean? Yes">Y</span></td>
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast double to IRI? No">N</span></td -->
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast double to Literal? No">N</span></td --><!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast double to bNode? No">N</span></td -->
</tr>
<tr>
<th><span class="cancast" title="decimal">dec</span></th>
<td class="castY" align="center" valign="middle"><span class="cancast" title="Cast decimal to string? Yes">Y</span></td>
<td class="castY" align="center" valign="middle"><span class="cancast" title="Cast decimal to float? Yes">Y</span></td>
<td class="castY" align="center" valign="middle"><span class="cancast" title="Cast decimal to double? Yes">Y</span></td>
<td class="castY" align="center" valign="middle"><span class="cancast" title="Cast decimal to decimal? Yes">Y</span></td>
<td class="castY" align="center" valign="middle"><span class="cancast" title="Cast decimal to integer? Yes">Y</span></td>
<td class="castN" align="center" valign="middle"><span class="cancast" title="Cast decimal to dateTime? No">N</span></td>
<td class="castY" align="center" valign="middle"><span class="cancast" title="Cast decimal to boolean? Yes">Y</span></td>
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast decimal to IRI? No">N</span></td -->
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast decimal to Literal? No">N</span></td -->
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast decimal to bNode? No">N</span></td -->
</tr>
<tr>
<th><span class="cancast" title="integer">int</span></th>
<td class="castY" align="center" valign="middle"><span class="cancast" title="Cast integer to string? Yes">Y</span></td>
<td class="castY" align="center" valign="middle"><span class="cancast" title="Cast integer to float? Yes">Y</span></td>
<td class="castY" align="center" valign="middle"><span class="cancast" title="Cast integer to double? Yes">Y</span></td>
<td class="castY" align="center" valign="middle"><span class="cancast" title="Cast integer to decimal? Yes">Y</span></td>
<td class="castY" align="center" valign="middle"><span class="cancast" title="Cast integer to integer? Yes">Y</span></td>
<td class="castN" align="center" valign="middle"><span class="cancast" title="Cast integer to dateTime? No">N</span></td>
<td class="castY" align="center" valign="middle"><span class="cancast" title="Cast integer to boolean? Yes">Y</span></td>
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast integer to IRI? No">N</span></td -->
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast integer to Literal? No">N</span></td -->
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast integer to bNode? No">N</span></td -->
</tr>
<tr>
<th><span class="cancast" title="dateTime">dT</span></th>
<td class="castY" align="center" valign="middle"><span class="cancast" title="Cast dateTime to string? Yes">Y</span></td>
<td class="castN" align="center" valign="middle"><span class="cancast" title="Cast dateTime to float? No">N</span></td>
<td class="castN" align="center" valign="middle"><span class="cancast" title="Cast dateTime to double? No">N</span></td>
<td class="castN" align="center" valign="middle"><span class="cancast" title="Cast dateTime to decimal? No">N</span></td>
<td class="castN" align="center" valign="middle"><span class="cancast" title="Cast dateTime to integer? No">N</span></td>
<td class="castY" align="center" valign="middle"><span class="cancast" title="Cast dateTime to dateTime? Yes">Y</span></td>
<td class="castN" align="center" valign="middle"><span class="cancast" title="Cast dateTime to boolean? No">N</span></td>
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast dateTime to IRI? No">N</span></td -->
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast dateTime to Literal? No">N</span></td -->
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast dateTime to bNode? No">N</span></td -->
</tr>
<tr>
<th><span class="cancast" title="boolean">bool</span></th>
<td class="castY" align="center" valign="middle"><span class="cancast" title="Cast boolean to string? Yes">Y</span></td>
<td class="castY" align="center" valign="middle"><span class="cancast" title="Cast boolean to float? Yes">Y</span></td>
<td class="castY" align="center" valign="middle"><span class="cancast" title="Cast boolean to double? Yes">Y</span></td>
<td class="castY" align="center" valign="middle"><span class="cancast" title="Cast boolean to decimal? Yes">Y</span></td>
<td class="castY" align="center" valign="middle"><span class="cancast" title="Cast boolean to integer? Yes">Y</span></td>
<td class="castN" align="center" valign="middle"><span class="cancast" title="Cast boolean to dateTime? No">N</span></td>
<td class="castY" align="center" valign="middle"><span class="cancast" title="Cast boolean to boolean? Yes">Y</span></td>
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast boolean to IRI? No">N</span></td -->
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast boolean to Literal? No">N</span></td -->
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast boolean to bNode? No">N</span></td -->
</tr>
<tr>
<th><span class="cancast rdfDM" title="IRI">IRI</span></th>
<td class="castY" align="center" valign="middle"><span class="cancast rdfDM" title="Cast IRI to string? Yes">Y</span></td>
<td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast IRI to float? No">N</span></td>
<td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast IRI to double? No">N</span></td>
<td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast IRI to decimal? No">N</span></td>
<td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast IRI to integer? No">N</span></td>
<td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast IRI to dateTime? No">N</span></td>
<td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast IRI to boolean? No">N</span></td>
<!-- td class="castY" align="center" valign="middle"><span class="cancast rdfDM" title="Cast IRI to IRI? Yes">Y</span></td -->
<!-- td class="castY" align="center" valign="middle"><span class="cancast rdfDM" title="Cast IRI to Literal? Yes">Y</span></td -->
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast IRI to bNode? No">N</span></td -->
</tr>
<tr>
<th><span class="cancast rdfDM" title="Literal">ltrl</span></th>
<td class="castY" align="center" valign="middle"><span class="cancast rdfDM" title="Cast Literal to string? Yes">Y</span></td>
<td class="castM" align="center" valign="middle"><span class="cancast rdfDM" title="Cast Literal to float? No">M</span></td>
<td class="castM" align="center" valign="middle"><span class="cancast rdfDM" title="Cast Literal to double? No">M</span></td>
<td class="castM" align="center" valign="middle"><span class="cancast rdfDM" title="Cast Literal to decimal? No">M</span></td>
<td class="castM" align="center" valign="middle"><span class="cancast rdfDM" title="Cast Literal to integer? No">M</span></td>
<td class="castM" align="center" valign="middle"><span class="cancast rdfDM" title="Cast Literal to dateTime? No">M</span></td>
<td class="castM" align="center" valign="middle"><span class="cancast rdfDM" title="Cast Literal to boolean? No">M</span></td>
<!-- td class="castY" align="center" valign="middle"><span class="cancast rdfDM" title="Cast Literal to IRI? Yes">Y</span></td -->
<!-- td class="castY" align="center" valign="middle"><span class="cancast rdfDM" title="Cast Literal to Literal? Yes">Y</span></td -->
<!-- td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast Literal to bNode? No">N</span></td -->
</tr>
<!-- tr>
<th><span class="cancast rdfDM" title="bNode">BN</span></th>
<td class="castY" align="center" valign="middle"><span class="cancast rdfDM" title="Cast bNode to string? Yes">Y</span></td>
<td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast bNode to float? No">N</span></td>
<td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast bNode to double? No">N</span></td>
<td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast bNode to decimal? No">N</span></td>
<td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast bNode to integer? No">N</span></td>
<td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast bNode to dateTime? No">N</span></td>
<td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast bNode to boolean? No">N</span></td>
<td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast bNode to IRI? No">N</span></td>
<td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast bNode to Literal? No">N</span></td>
<td class="castY" align="center" valign="middle"><span class="cancast rdfDM" title="Cast bNode to bNode? Yes">Y</span></td>
</tr -->
</tbody>
</table>

  <h3>11.6 <a id="extensionFunctions" name="extensionFunctions">拡張可能な値テスト</a>
</h3>

    <p><a href="#rPrimaryExpression">PrimaryExpression</a>の文法規則は、IRIで指定された拡張関数への呼び出しでありえます。拡張関数は、RDF用語のいくつかを引数と見なして、RDF用語を返します。これらの関数のセマンティクスは、関数を識別するIRIによって識別されます。</p>

    <p>拡張関数を用いるSPARQLクエリは、相互運用性を制限する可能性があります。</p>

  <p>例として、<code class="function">func:even</code>と呼ばれる関数を取り上げます。</p>

  <pre class="prototype">
 <code class="return">xsd:boolean</code>&nbsp;&nbsp;&nbsp;<code class="function">func:even</code> (<code class="parm type"><span class="type numeric">numeric</span></code> <code class="parm name">value</code>)
</pre>

  <div class="exampleGroup">
  <div class="queryGroup">

  <p>この関数は、次のとおり、そういうものとしてFILTERに呼び出されるでしょう。</p>

  <pre class="query">
PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX func: &lt;http://example.org/functions#&gt;
SELECT ?name ?id
WHERE { ?x foaf:name  ?name ;
           func:empId   ?id .
        FILTER (func:even(?id)) }</pre>
</div>
</div>

    <p>2番目の例では、2つの地点の間の距離を計算する関数<code>aGeo:distance</code>について考えてみます。ここでは、これをグルノーブル（Grenoble）付近の場所を発見するために用います。</p>

  <pre class="prototype">
 <code class="return">xsd:double</code>&nbsp;&nbsp;&nbsp;<code class="function">aGeo:distance</code> (<code class="parm type"><span class="type numeric">numeric</span></code> <code class="parm name">x1</code>, <code class="parm type"><span class="type numeric">numeric</span></code> <code class="parm name">y1</code>, <code class="parm type"><span class="type numeric">numeric</span></code> <code class="parm name">x2</code>, <code class="parm type"><span class="type numeric">numeric</span></code> <code class="parm name">y2</code>)
</pre>

  <div class="exampleGroup">
  <div class="queryGroup">
  <pre class="query">
PREFIX aGeo: &lt;http://example.org/geo#&gt;

SELECT ?neighbor
WHERE { ?a aGeo:placeName &quot;Grenoble&quot; .
        ?a aGeo:location ?axLoc .
        ?a aGeo:location ?ayLoc .
        ?b aGeo:placeName ?neighbor .
        ?b aGeo:location ?bxLoc .
        ?b aGeo:location ?byLoc .

        FILTER ( aGeo:distance(?axLoc, ?ayLoc, ?bxLoc, ?byLoc) &lt; 10 ) .
      }
</pre>
</div>
</div>

  <p>拡張関数は、コアSPARQL仕様でサポートされていないアプリケーション・データ型をテストするために用いられるかもしれず、例えばこれは、別の日付フォーマットからXSD dateTime RDF用語へのデータ型フォーマット間の変換であるかもしれません。</p>

  <h2>12 <a name="sparqlDefinition" id="sparqlDefinition">SPARQLの定義</a>
</h2>

<p>この項では、クエリ文字列とRDFデータセットを前提に、グラフ・パターンとソリューション修飾子の評価のに対する正しい行動を定義します。これは、SPARQL実装がここで定義されたプロセスを使用しなければならないということを意味しません。</p>

  <p>SPARQLを実行した結果は、SPARQLクエリを文字列として開始し、その文字列を抽象構文形式に変え、次に、その抽象構文をSPARQLの代数の演算子で構成されるSPARQL抽象クエリに変える、という一連のステップで定義されます。その後、この抽象クエリは、RDFデータセットで評価されます。</p>

<h3>12.1 <a id="initDefinitions" name="initDefinitions">初期定義</a>
</h3>


  <h4>12.1.1 <a id="sparqlBasicTerms" name="sparqlBasicTerms">RDF用語</a>
</h4>

  <p>SPARQLは、IRI[<a href="#rfc3987">RFC3987</a>]の用語で定義されています。IRIは、スペースを省略するRDF URI参照のサブセットです。</p>

  <div class="defn">
    <b>定義:</b> <a id="defn_RDFTerm" name="defn_RDFTerm">RDF用語</a>

    <p>IをすべてのIRIの集合とする。<br>
RDF-Lをすべての<a class="norm" href="www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-literal">RDFリテラル</a>の集合とする。<br>RDF-BをすべてのRDFグラフにおける<a class="norm" href="www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-blank-node">空白ノード</a>の集合とする。</p>

    <p><span class="definedTerm">RDF用語</span>の集合、RDF-Tは、I union RDF-L union RDF-Bです。</p>
  </div>

  <p><span class="definedTerm">RDF用語</span>のこの定義は、<a class="norm" href="www.w3.org/TR/2004/REC-rdf-concepts-20040210/#section-data-model">RDFデータ・モデル</a>のいくつかの基本的な概念をまとめていますが、RDF URI参照ではなくIRIを参照言するように<a href="www.w3.org/TR/rdf-concepts/#section-Graph-URIref">更新</a>されています。</p>

  <h4>12.1.2 <a id="sparqlDataset" name="sparqlDataset">RDFデータセット</a>
</h4>

<div class="defn">
  <b>定義:</b> <a id="defn_RDFDataset" name="defn_RDFDataset">RDFデータセット</a><p>
RDFデータセットは以下の集合です。<br>
  { G, (&lt;u<sub>1</sub>&gt;, G<sub>1</sub>), (&lt;u<sub>2</sub>&gt;, G<sub>2</sub>), . . .
  (&lt;u<sub>n</sub>&gt;, G<sub>n</sub>) }<br>
ここでは、Gと各G<sub>i</sub>はグラフであり、各&lt;u<sub>i</sub>&gt;はIRIです。各&lt;u<sub>i</sub>&gt;はdistinctです。</p>

  <p>Gはデフォルト・グラフと呼ばれます。（&lt;u<sub>i</sub>&gt;, G<sub>i</sub>）は名前付きグラフと呼ばれます。</p>
</div>

  <div class="defn">
    <b>定義:</b> <a id="defn_ActiveGraph" name="defn_ActiveGraph">アクティブ・グラフ</a>
    <p><b>アクティブ・グラフ</b>は、基本グラフパターン・マッチングに用いられるデータセットのグ
ラフです。</p>
  </div>

  <h4>12.1.3 <a id="sparqlQueryVariables" name="sparqlQueryVariables">クエリ変数</a>
</h4>

  <div class="defn">
    <b>定義:</b> <a id="defn_QueryVariable" name="defn_QueryVariable">クエリ変数</a>

    <p><span class="definedTerm">クエリ変数</span>は、Vが無限であり、RDF-Tと互いに素な集合Vのメンバーです。</p>
  </div>

  <h4>12.1.4 <a id="sparqlTriplePatterns" name="sparqlTriplePatterns">トリプル・パターン</a>
</h4>

  <div class="defn">
    <b>定義:</b> <a id="defn_TriplePattern" name="defn_TriplePattern">トリプル・パターン</a>

    <p><span class="definedTerm">トリプル・パターン</span>は、次の集合のメンバーです。<br>
    (RDF-T union V) x (I union V) x (RDF-T union V)</p>
  </div>

  <p>トリプル・パターンのこの定義には、リテラルの主語が含まれています。<a href="www.w3.org/2000/03/rdf-tracking/#rdfms-literalsubjects">これは、RDF-コアで注記されています。</a></p>

  <pre id="body">
「[RDFコア・ワーキンググループは]リテラルが主語であってはならない理由がないことを
承知していると述べました。そして、より制限のない憲章を持つ将来のWGは、ステートメン
トの主語としてのリテラルを許容するように構文を拡張するかもしれません。」
</pre>

  <p>RDFグラフはリテラルの主語を含まないかもしれないため、リテラルを主語として持つ任意のSPARQLトリプル・パターンは、どんなRDFグラフにもマッチしないでしょう。</p>
  
  <h4>12.1.5 <a id="sparqlBasicGraphPatterns" name="sparqlBasicGraphPatterns">基本グラフ・パターン</a>
</h4>

  
<div class="defn">
    <b>定義:</b> <a id="defn_BasicGraphPattern" name="defn_BasicGraphPattern">基本グラフ・パターン</a>

    <p><span class="definedTerm">基本グラフ・パターン</span>は、<a href="#defn_TriplePattern">トリプル・パターン</a>の集合です。</p>
  </div>

  <p>空のグラフ・パターンは、空集合である基本グラフ・パターンです。</p>

<h4>12.1.6 <a name="sparqlSolutions" id="sparqlSolutions">ソリューション・マッピング</a>
</h4>

  <p>ソリューション・マッピングは、1組の変数から1組のRDF用語へのマッピングです。我々は、それが明確である場合に「ソリューション」という用語を使用します。</p>

  <div class="defn">
    <b>定義: <a id="defn_sparqlSolutionMapping" name="defn_sparqlSolutionMapping">ソリューション・マッピング</a></b>

<p><b>ソリューション・マッピング</b>、&mu;は、部分関数&mu; : V -&gt; Tです。</p>

    <p>&mu;の定義域、dom(&mu;)は、&mu;が定義されている場合のVのサブセットです。</p>
  </div>
  <div class="defn">
    <b>定義: 
    <a id="defn_sparqlSolutionSequence" name="defn_sparqlSolutionSequence">ソリューション・シーケンス</a></b>
    
    <p><b>ソリューション・シーケンス</b>は、ソリューションのリストで、順不同でありえます。</p>
  </div>

<h4>12.1.7 <a name="sparqlSolMod" id="sparqlSolMod">ソリューション・シーケンス修飾子</a>
</h4>

<div class="defn">
    <b>定義:</b> 
    <a id="defn_SolutionModifier" name="defn_SolutionModifier">ソリューション・シーケンス修飾子</a>

    <p><span class="definedTerm">ソリューション・シーケンス修飾子</span>は、次のうちの1つです。</p>
    <ul>
      <li>
      <a href="#defn_algOrdered">
      Order By</a>修飾子: ソリューションを順序付けします。</li>
      <li>
      <a href="#defn_algProjection">
      Projection</a>修飾子: ある変数を選択します。</li>
      <li>
      <a href="#defn_algDistinct">
      Distinct</a>修飾子: シーケンス中のソリューションを確実にユニークにします。</li>
      <li>
      <a href="#defn_algReduced">
      Reduced</a>修飾子: ユニークではないソリューションの排除を許可します。</li>
      <li>
      <a href="#defn_algSlice">
      Offset</a>修飾子: 全体のソリューションのシーケンスの中でどこからソリューションが始まるかを制御します。</li>
      <li>
      <a href="#defn_algSlice">
      Limit</a>修飾子: ソリューションの数を制限します。</li>
    </ul>
  </div>

<h3>12.2 <a id="sparqlQuery" name="sparqlQuery">SPARQLクエリ</a>
</h3>

<p>この項は、SPARQLクエリ文字列内のグラフ・パターンとソリューション修飾子をSPARQL代数式に変換するプロセスを定義します。</p>

<p>SPARQLクエリ文字列を分析し、4項で示したIRIとトリプル・パターンに省略形を適用した後に、次の表で構成される抽象構文木があります。</p>

<table class="plain">  <tbody>
  <tr>
    <th>パターン</th>
    <th>修飾子</th>
    <th>クエリ形式</th>
  </tr>
  <tr>
    <td>RDF terms</td>
    <td>DISTINCT</td>
    <td>SELECT</td>
  </tr>
  <tr>
    <td>triple patterns</td>
    <td>REDUCED</td>
    <td>CONSTRUCT</td>
  </tr>
  <tr>
    <td>Basic graph patterns</td>
    <td>PROJECT</td>
    <td>DESCRIBE</td>
  </tr>
  <tr>
    <td>Groups</td>
    <td>ORDER BY</td>
    <td>ASK</td>  </tr>
  <tr>
    <td>OPTIONAL</td>
    <td>LIMIT</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>UNION</td>
    <td>OFFSET</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>GRAPH</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td>FILTER</td>
    <td>&nbsp;</td>
    <td>&nbsp;</td>
  </tr>  </tbody>
</table>

<p>このような抽象構文木を変換した結果は、次の表の符号をSPARQL代数で用いるSPARQLクエリです。</p>

<table class="plain">
  <tbody>
  <tr>
    <th>グラフ・パターン</th>
    <th>ソリューション修飾子</th>
  </tr>
  <tr>
    <td>BGP </td>
    <td>ToList</td>
  </tr>
  <tr>
    <td>Join</td>
    <td>OrderBy</td>
  </tr>
  <tr>
    <td>LeftJoin</td>
    <td>Project</td>
  </tr>
  <tr>
    <td>Filter</td>
    <td>Distinct</td>
  </tr>
  <tr>
    <td>Union</td>
    <td>Reduced</td>
  </tr>
  <tr>
    <td>Graph</td>
    <td>Slice</td>
  </tr>
  </tbody>
</table>

  <p><i>Slice</i>は、OFFSETとLIMITを組み合わせたものです。<i>mod</i>は、ソリューション修飾子のうちの1つです。</p>

<p><i>ToList</i>はグラフ・パターン・マッチングの結果からシーケンスへの変換が起こる場合に用いられます。</p>

	<div class="defn">
    <b>定義:</b> <a id="defn_SPARQLQuery" name="defn_SPARQLQuery">
    SPARQLクエリ</a>

    <p>以下の場合、<span class="definedTerm">SPARQL抽象クエリ</span>はタプル（E, DS, R）です。</p>

    <ul>
      <li>Eが<a href="#sparqlAlgebra">SPARQL代数</a>式である</li>
      <li>DSが<a href="#defn_RDFDataset">RDFデータセット</a>である</li>
      <li>Rが<a href="#QueryForms"><span style="background-position: 0% 0%">クエリ形式</span></a>である</li>
    </ul>
	</div>

    <h4>12.2.1 <a id="convertGraphPattern" name="convertGraphPattern">グラフ・パターンの変換</a>
</h4>

<p>この項では、SPARQLグラフ・パターンをSPARQL代数式に変換するプロセスについて述べます。IRIとトリプル・パターンの構文上の省略形を変換した後に、構文形式を再帰的に処理して代数式にします。</p>

<div class="wgNote">ワーキンググループは、単純化のステップが適用される時点で、OPTIONALにおいて、二重に入れ子になったフィルタとパターンを伴ったクエリのあいまいな変換が生じるということを指摘します。 

<pre><code>OPTIONAL { { ... FILTER ( ... ?x ... ) } }.</code>.</pre>

<p>次の2つの規範的でないテストケースでこれを例証します。</p>

<ul>
<li>
<a href="www.w3.org/2001/sw/DataAccess/tests/data-r2/optional-filter/manifest#dawg-optional-filter-005-not-simplified">単純化は、すべての変換の後に適用される</a>か、まったく適用されない。</li>

<li>
<a href="www.w3.org/2001/sw/DataAccess/tests/data-r2/optional-filter/manifest#dawg-optional-filter-005-simplified">単純化は、変換の間に適用される</a>。</li>
</ul>


</div>

<p>まず最初に、<a href="#sparqlSyntax">4項</a>で示したIRIとトリプル・パターンの省略形を拡張してください。</p>
  
<p><code class="gRuleBody"><a href="#rWhereClause">WhereClause</a></code>は、次の形式から成る<code class="gRuleBody"><a href="#rGroupGraphPattern">GroupGraphPattern</a></code>で構成されています。</p>

<ul>
  <li><code class="gRuleBody"><a href="#rTriplesBlock">TriplesBlock</a></code></li>
  <li><code class="gRuleBody"><a href="#rFilter">Filter</a></code></li>  <li><code class="gRuleBody"><a href="#rOptionalGraphPattern">OptionalGraphPattern</a></code></li>
  <li><code class="gRuleBody"><a href="#rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</a></code></li>
  <li><code class="gRuleBody"><a href="#rGraphGraphPattern">GraphGraphPattern</a></code></li>
</ul>

<p>それぞれは、次の手順で変換されます。</p>

<p><b>Transform(syntax form)</b></p>
<blockquote>
  <p>形式が<code class="gRuleBody"><a href="#rTriplesBlock">TriplesBlock</a></code>である場合</p>
</blockquote>
<pre class="codeBlock">The result is BGP(list of triple patterns)</pre>

  <blockquote>
    <p>形式が<code class="gRuleBody">
    <a href="#rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</a></code>である場合</p>
</blockquote>

  <pre class="codeBlock">Let A := undefined

For each element G in the GroupOrUnionGraphPattern
    If A is undefined
        A := Transform(G)
    Else
        A := Union(A, Transform(G))
The result is A
</pre>


   <blockquote>
     <p>形式が<code class="gRuleBody"><a href="#rGraphGraphPattern">GraphGraphPattern</a></code>である場合</p>
</blockquote>

  <pre class="codeBlock">
If the form is GRAPH IRI GroupGraphPattern
    The result is Graph(IRI, Transform(GroupGraphPattern))
If the form is GRAPH Var GroupGraphPattern
    The result is Graph(Var, Transform(GroupGraphPattern))</pre>

  <blockquote>
    <p>形式が<code class="gRuleBody"><a href="#rGroupGraphPattern">GroupGraphPattern</a></code>である場合</p>
    <blockquote>
      <p>次のシンボルを導入します。</p>
      <ul>
        <li>Join(Pattern, Pattern)</li>
        <li>LeftJoin(Pattern, Pattern, expression)</li>
        <li>Filter(expression, Pattern)</li>
      </ul>
    </blockquote>
</blockquote>

  <pre class="codeBlock">
Let FS := the empty set
Let G := the empty pattern, Z, a basic graph pattern which is the empty set.
For each element E in the GroupGraphPattern
   If E is of the form FILTER(expr)
       FS := FS set-union {expr}   If E is of the form OPTIONAL{P}
   Then
       Let A := Transform(P)
       If A is of the form Filter(F, A2)
           G := LeftJoin(G, A2, F)
       else 
           G := LeftJoin(G, A, true)
   If E is any other form:
      Let A := Transform(E)
      G := Join(G, A)
   
  
If FS is not empty:
  Let X := Conjunction of expressions in FS
  G := Filter(X, G)

The result is G.
</pre>

<p>単純化のステップ</p>

<p>1つのグラフ・パターン（フィルタではない）のグループは、join(Z, A)になり、Aで置き換えることができます。空のグラフ・パターンZは、joinと同値です。</p>

  <pre class="codeBlock">
Replace join(Z, A) by A
Replace join(A, Z) by A
</pre>

  <h4>12.2.2 <a id="sparqlAbsExamples" name="sparqlAbsExamples">マッピングされたグラフ・パターンの例</a>
</h4>

  <p>書き換えの例の2番目の形式は、1番目のものに単純化のステップで削除した空のグループのjoinを付けたものです。</p>

<p>例: 1つのトリプル・パターンから成る1つの基本グラフ・パターンを持つグループ</p>

  <div class="algExample">
    <div class="algExample1">
      { ?s ?p ?o }
    </div>

    <div class="algExample2">
      Join(Z,
      BGP(?s ?p ?o) )</div>
    <div class="algExample2">
      BGP(?s ?p ?o)</div>
  </div>

<p>例: 2つのトリプル・パターンから成る1つの基本グラフ・パターンを持つグループ</p>

  <div class="algExample">
    <div class="algExample1">
      { ?s :p1 ?v1 ; :p2 ?v2 }
    </div>

    <div class="algExample2">
      BGP( ?s :p1 ?v1 .?s :p2 ?v2 )
    </div>
  </div>

<p>例: 2つの基本グラフ・パターンの和集合から成るグループ</p>

  <div class="algExample">
    <div class="algExample1">
      { { ?s :p1 ?v1 } UNION {?s :p2 ?v2 } }
    </div>

    <div class="algExample2">
      Union(Join(Z, BGP(?s :p1 ?v1)),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p2 ?v2)) )
    </div>

    <div class="algExample2">
      Union( BGP(?s :p1 ?v1) , BGP(?s :p2 ?v2) )
    </div>
  </div>

<p>例: 1つの和集合と1つの基本グラフ・パターンの和集合から成るグループ</p>

  <div class="algExample">
    <div class="algExample1">
      { { ?s :p1 ?v1 } UNION {?s :p2 ?v2 } UNION {?s :p3 ?v3 } }
    </div>

    <div class="algExample2">
      Union(<br>
&nbsp;&nbsp;&nbsp; Union( Join(Z, BGP(?s :p1 ?v1)),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p2 ?v2))) 
      ,<br>
&nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p3 ?v3)) )</div>

    <div class="algExample2">
      Union( <br>
&nbsp;&nbsp;&nbsp; Union( BGP(?s :p1 ?v1) ,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BGP(?s :p2 ?v2),<br>
&nbsp;&nbsp;&nbsp; BGP(?s :p3 ?v3))</div>
  </div>

<p>例: 1つの基本グラフ・パターンと1つのオプションのグラフ・パターンから成るグループ</p>

  <div class="algExample">
    <div class="algExample1">
      { ?s :p1 ?v1 OPTIONAL {?s :p2 ?v2 } }
    </div>

    <div class="algExample2">
      LeftJoin(<br>
&nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p1 ?v1)),<br>
&nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p2 ?v2)) ),<br>
&nbsp;&nbsp;&nbsp; true)    </div>

    <div class="algExample2">
      LeftJoin(BGP(?s :p1 ?v1), BGP(?s :p2 ?v2), true)
    </div>  </div>

<p>例: 1つの基本グラフ・パターンと2つのオプションのグラフ・パターンから成るグループ</p>

  <div class="algExample">
    <div class="algExample1">
      { ?s :p1 ?v1 OPTIONAL {?s :p2 ?v2 } OPTIONAL { ?s :p3 ?v3 } }
    </div>

    <div class="algExample2">
      LeftJoin(<br>
           &nbsp;&nbsp;&nbsp; LeftJoin(<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BGP(?s :p1 ?v1),<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BGP(?s :p2 ?v2),<br>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              true) ,<br>
           &nbsp;&nbsp;&nbsp; BGP(?s :p3 ?v3),<br>
           &nbsp;&nbsp;&nbsp; true)
    </div>
  </div>

<p>例: 1つの基本グラフ・パターンとフィルタを持つ1つのオプションのグラフ・パターンから成るグループ</p>

  <div class="algExample">
    <div class="algExample1">
      { ?s :p1 ?v1 OPTIONAL {?s :p2 ?v2 FILTER(?v1&lt;3) } }
    </div>
    <div class="algExample2">
      LeftJoin(<br>
&nbsp;&nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p1 ?v1)),<br>
&nbsp;&nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p2 ?v2)),<br>&nbsp;&nbsp;&nbsp;&nbsp; (?v1&lt;3) )
    </div>

    <div class="algExample2">
      LeftJoin(<br>
&nbsp;&nbsp;&nbsp; BGP(?s :p1 ?v1) ,<br>
&nbsp;&nbsp;&nbsp; BGP(?s :p2 ?v2) ,<br>
&nbsp;&nbsp; (?v1&lt;3) )
    </div>
  </div>
<p>例: 1つの和集合のグラフ・パターンと1つのオプションのグラフ・パターンから成るグループ</p>

  <div class="algExample">
    <div class="algExample1">
      { {?s :p1 ?v1} UNION {?s :p2 ?v2} OPTIONAL {?s :p3 ?v3} }
    </div>
    <div class="algExample2">
      LeftJoin(<br>
        &nbsp;        Union(BGP(?s :p1 ?v1),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BGP(?s :p2 ?v2)) ,<br>
        &nbsp;
        BGP(?s :p3 ?v3) ,<br>
        &nbsp;
        true )
    </div>
  </div>

<p>例: 1つの基本グラフ・パターン、1つのフィルタ、および1つのオプションのグラフ・パターンから成るグループ</p>

  <div class="algExample">
    <div class="algExample1">
      { ?s :p1 ?v1 FILTER (?v1 &lt; 3 ) OPTIONAL {?s :p2 ?v2} } }</div>

    <div class="algExample2">
      Filter( ?v1 &lt; 3 ,<br>
              &nbsp;
              LeftJoin( BGP(?s :p1 ?v1), BGP(?s :p2 ?v2), true) ,<br>
             &nbsp;
             )
    </div>  </div>

  <h4>12.2.3 <a id="convertSolMod" name="convertSolMod">ソリューション修飾子の変換</a>
</h4>

  <p>ステップ1 : ToList</p>

  <p>ToListは、多重集合を、同じ要素とカーディナリティーを持つシーケンスに変えます。シーケンスに対する暗黙的な順序付けはありません。同じものが隣接している必要はありません。</p>

  <blockquote>
    <p>Let M := ToList(Pattern)</p>
  </blockquote>
  <p>ステップ2 : ORDER BY</p>

  <p>クエリ文字列にORDER BY句がある場合、</p>

  <blockquote>
    <p>M := OrderBy(M, list of order comparators)</p>
  </blockquote>

  <p>ステップ3 : Projection</p>

  <blockquote>
    <p>M := Project(M, vars)</p>
  </blockquote>

  <p>ここでは、varsは、SELECT句で記述された変数の集合であるか、SELECT *が用いられた場合には、クエリ中のすべての名前付き変数です。</p>

  <p>ステップ4 : DISTINCT</p>

  <p>クエリがDISTINCTを含んでいる場合、</p>

  <blockquote>
    <p>M := Distinct(M)</p>
  </blockquote>

  <p>ステップ5 : REDUCED</p>

  <p>クエリがREDUCEDを含んでいる場合、</p>
  <blockquote>
    <p>M := Reduced(M)</p>
  </blockquote>

  <p>ステップ6 : OFFSETとLIMIT</p>

  <p>クエリが「OFFSET開始」または「LIMITの長さ」を含んでいる場合、</p>

  <blockquote>
    <p>M := Slice(M, start, length)</p>
    <blockquote>
      <p>start defaults to 0</p>
      <p>length defaults to (size(M)-start).</p>
    </blockquote>
  </blockquote>
  <p>全般的な抽象クエリはMです。</p>

  <h3>12.3 <a id="BasicGraphPattern" name="BasicGraphPattern">基本グラフ・パターン</a>
</h3>

<p>グラフ・パターンをマッチさせるときには、可能なソリューションは、<i>バッグ</i>（bag）としても知られている<i><a href="en.wikipedia.org/w/index.php?title=Multiset&amp;oldid=163605900">多重集合</a></i>[<a href="#multiset">multiset</a>]を形成します。多重集合は、各要素が1回以上出現しうる要素の順不同のコレクションです。これは、多重集合内の集合の各要素の出現回数を示す、1組の要素とカーディナリティー関数で記述されます。</p>

 <p>ソリューション・マッピングを、&#956;と記述し、</p>

<p>dom(μ<sub>0</sub>)が空の集合であるようなマッピングを、&mu;<sub>0</sub>と記述します。</p>

  <p>カーディナリティー1を持つ、空のマッピング&mu;<sub>0,</sub>からきっかり成る多重集合を、&Omega;<sub>0</sub>と記述します。これは、joinと同値です。</p>

  <p>RDF用語t : { (x, t) }に対するソリューション・マッピング変数xを、&mu;(?x-&gt;t)と記述します。</p>

  <p>きっかり&mu;(?x-&gt;t)から成る多重集合、つまり、カーディナリティー1を持つ{ { (x, t) } }を、&Omega;(?x-&gt;t)と記述します。</p>

  <div class="defn">
    <b>定義: <a id="defn_algCompatibleMapping" name="defn_algCompatibleMapping">互換マッチング</a></b>

    <p>2つのソリューション・マッピング&mu;<sub>1</sub>と&mu;<sub>2</sub>は、dom(&mu;<sub>1</sub>)およびdom(&mu;<sub>2</sub>)のすべての変数vに対し、&mu;<sub>1</sub>(v) = &mu;<sub>2</sub>(v)である場合、互換性があります。</p>

  </div>

    <p>&mu;<sub>1</sub>と&mu;<sub>2</sub>に互換性がある場合、&mu;<sub>1</sub> <i>set-union</i>（和集合） &mu;<sub>2</sub>もマッピングです。&mu;<sub>1</sub> <i>set-union</i> &mu;<sub>2</sub>を、merge(&mu;<sub>1</sub>, &mu;<sub>2</sub>)と記述します。</p>

  <p>マッピング&#937;の多重集合におけるソリューション・マッピング&mu;のカーディナリティーを、card[&Omega;](&mu;)と記述します。</p>

  <h4>12.3.1 <a id="BGPsparql" name="BGPsparql">SPARQLの基本グラフ・パターン・マッチング</a>
</h4>

  <p>基本グラフ・パターンは、SPARQLパターン・マッチングの基礎を形成します。基本グラフ・パターンは、クエリの当該部分に対するアクティブ・グラフにマッチングします。変数と空白ノードの両方を用語に置き換えることによって、インスタンスの2つの概念を示し、基本グラフ・パターンをインスタンス化できます。空白ノードは、<a href="www.w3.org/TR/rdf-mt#definst">RDFインスタンス・マッピング</a>&nbsp;&#963;を用いて空白ノードからRDF用語に置き換えられ、変数は、ソリューション・マッピングによってクエリ変数からRDF用語に置き換えられます。</p>

<div class="defn">
    <b>定義: <a id="defn_PatternInstanceMapping" name="defn_PatternInstanceMapping">パターン・インスタンス・マッピング</a></b>
    
    <p><b>パターン・インスタンス・マッピング</b>Pは、RDFインスタンス・マッピング&#963;とソリューション・マッピング&#956;の組み合わせです。

P(x) = &#956;(&#963;(x))</p>
</div>

    <p>任意のパターン・インスタンス・マッピングは、それぞれクエリ変数と空白ノードに制限することによって得られた、ユニークなソリューション・マッピングおよびユニークなRDFインスタンス・マッピングを定義します。</p>

<div class="defn">    <b>定義: 基本グラフ・パターン・マッチング</b>

    <p>BGPを基本グラフ・パターンとし、GをRDFグラフとします。</p>

    <p>P(BGP)がGのサブグラフであり、&#956;がBGPのクエリ変数に対するPの制限であるような、パターン・インスタンス・マッピングPがあるとき、&#956;は、GからのBGPのソリューションです。</p>

    <p>card[&Omega;](&mu;) = card[&Omega;]（P = &#956;(&#963;) であるような異なるRDFインスタンス・マッピングの数、&#963;はパターン・インスタンス・マッピングであり、P(BGP)はGのサブグラフです）。</p>
</div>

<p>基本グラフ・パターンが空の集合である場合、ソリューションは&#937;<sub>0</sub>です。</p>

<h4>12.3.2 <a id="BGPsparqlBNodes" name="BGPsparqlBNodes">空白ノードの処理</a>
</h4>

		<p>この定義によって、ソリューション・マッピングは、基本グラフ・パターンであるBGPの変数をGの空白ノードにバインドできます。SPARQLは、<a href="www.w3.org/TR/rdf-sparql-XMLres/">SPARQLクエリ結果XMLフォーマット</a>ドキュメントの空白ノード識別子をそのドキュメントに対して有効であるものとして扱うため、データセットのアクティブ・グラフにおけるノードを識別しているとは解釈されません。したがって、DSがクエリのデータセットである場合、パターンのソリューションはDS自身のアクティブ・グラフからのものではなくRDFグラフからのものであると解釈され、これは<i>スコーピング・グラフ</i>と呼ばれ、DSのアクティブ・グラフに対しグラフ同等（graph-equivalent）であるけれどもDSまたはBGPと空白ノードを共有しません。スコーピング・グラフは、1つのクエリに対するすべてのソリューションに用いられます。スコーピング・グラフは、純粋に理論的構成概念（theoretical construct）で、実際には、単なる空白ノード識別子に対するドキュメント範囲の慣習によって効果が得られます。</p>

<!--
 <div class="defn">
    <b>定義:</b> <a id="defn_ScopingGraph" name="defn_GraphSet">Scoping Graph</a>

    <p>The <span class="definedTerm">Scoping Graph</span> G' for
    RDF graph G, is an RDF Graph that is <a href="http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/#section-graph-equality">

    graph-equivalent</a> to G</p>
  </div>
-->
		<p>RDFの空白ノードが多くのパターンに対する多くの重複するソリューションを無限に許すため、多くのパターンのソリューション（空白ノードを別の空白ノードに置き換えることによって得られる）が無限に存在しえます。したがって、何らかの形で基本グラフ・パターンのソリューションを区切る必要があります。SPARQLは、基本グラフ・パターンのソリューションを決定するために、サブグラフ・マッチの基準を用います。基本グラフ・パターンからアクティブ・グラフのサブセットにマッピングする異なるパターンのインスタンスに対し、それぞれ1つのソリューションが存在します。</p>

<p>これは、重複の排除よりむしろ計算の容易さのために最適化されます。これによって、データセットのアクティブ・グラフが<a href="www.w3.org/TR/rdf-mt/#deflean">貧弱</a>であるときでも、クエリ結果に重複を含むことができ、論理的に同等なデータセットが異なるクエリ結果を出すことが可能になります。</p>

  <h3>12.4 <a id="sparqlAlgebra" name="sparqlAlgebra">SPARQL代数</a>
</h3>

  <p>SPARQLの抽象クエリに内の各シンボルに対し、評価のための演算子を定義しています。同じ名前のSPARQL代数演算子は、「<a href="#sparqlAlgebraEval">評価セマンティクス</a>」の項で記述されているように、SPARQLの抽象クエリ・ノードを評価するために用いられます。</p>

  <div class="defn">
    <p><b>定義: <a id="defn_algFilter" name="defn_algFilter">Filter</a></b></p>

    <p>&Omega;をソリューション・マッピングの多重集合とし、exprを式とします。次のとおり定義します。</p>

    <p>Filter(expr, &Omega;) = { &mu; | &mu; in &Omega; and expr(&mu;) is an expression that has an 
    effective boolean value of true }</p>

    <p>card[Filter(expr, &Omega;)](&mu;) = card[&Omega;](&mu;)</p>
  </div>

  <div class="defn">
    <p><b>定義: <a id="defn_algJoin" name="defn_algJoin">Join</a></b></p>

    <p>&Omega;<sub>1</sub>と&Omega;<sub>2</sub>をソリューション・マッピングの多重集合とします。次のとおり定義します。</p>

    <p>Join(&Omega;<sub>1</sub>, &Omega;<sub>2</sub>) = { merge(&mu;<sub>1</sub>, &mu;<sub>2</sub>) | &mu;<sub>1</sub>
    in &Omega;<sub>1</sub>and &mu;<sub>2</sub> in &Omega;<sub>2</sub>, and &mu;<sub>1</sub> and &mu;<sub>2</sub> are
    compatible }</p>

    <p>card[Join(&Omega;<sub>1</sub>, &Omega;<sub>2</sub>)](&mu;) = <br>
&nbsp;&nbsp;&nbsp; for each merge(&#956;<sub>1</sub>, &mu;<sub>2</sub>), &#956;<sub>1</sub>
    in &Omega;<sub>1</sub>and &mu;<sub>2</sub> in &Omega;<sub>2</sub> such that &#956; = merge(&#956;<sub>1</sub>, &mu;<sub>2</sub>),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum over (&#956;<sub>1</sub>, &mu;<sub>2</sub>), card[&Omega;<sub>1</sub>](&mu;<sub>1</sub>)*card[&Omega;<sub>2</sub>](&mu;<sub>2</sub>)</p>
  </div>

<p>Joinにおけるソリューション・マッピング&#956;は、異なるソリューション・マッピング、結合された多重集合における&#956;<sub>1</sub>と&mu;<sub>2</sub>において出現することは可能です。&#956;のカーディナリティーは、すべての可能性のカーディナリティーの合計です。</p>
  <div class="defn">
    <p><b>定義: <a id="defn_algDiff" name="defn_algDiff">Diff</a></b></p>

    <p>&Omega;<sub>1</sub>と&Omega;<sub>2</sub>をソリューション・マッピングの多重集合とします。次のとおり定義します。</p>

    <p>Diff(&Omega;<sub>1</sub>, &Omega;<sub>2</sub>, expr) =            { &mu; | &mu; in &Omega;<sub>1</sub> such that for all &mu;&prime; in &Omega;<sub>2</sub>, 
    either &#956; and &#956;&#8242; are not compatible or &mu; and &mu;'
    are compatible and expr(merge(&mu;, &mu;')) has an effective boolean value 
	of false }</p>

    <p>card[Diff(&Omega;<sub>1</sub>, &Omega;<sub>2</sub>, expr)](&mu;) = card[&Omega;<sub>1</sub>](&mu;)</p>
  </div>

  <p>Diffは、LeftJoinの定義のために内部的に使用されます。</p>

  <div class="defn">
    <p><b>定義: <a id="defn_algLeftJoin" name="defn_algLeftJoin">LeftJoin</a></b></p>

    <p>&Omega;<sub>1</sub>と&Omega;<sub>2</sub>をソリューション・マッピングの多重集合とし、exprを式とします。次のとおり定義します。</p>

    <p>LeftJoin(&Omega;<sub>1</sub>, &Omega;<sub>2</sub>, expr) = Filter(expr, Join(&Omega;<sub>1</sub>,
    &Omega;<sub>2</sub>)) <i>set-union</i> Diff(&Omega;<sub>1</sub>, &Omega;<sub>2</sub>, expr)</p>

    <p>card[LeftJoin(&Omega;<sub>1</sub>, &Omega;<sub>2</sub>, expr)](&mu;) = card[Filter(expr,
    Join(&Omega;<sub>1</sub>, &Omega;<sub>2</sub>))](&mu;) + card[Diff(&Omega;<sub>1</sub>, &Omega;<sub>2</sub>,
    expr)](&mu;)</p>
  </div>

  <p>これは、完全形で記述すれば、次の通りです。</p>

  <p>LeftJoin(&Omega;<sub>1</sub>, &Omega;<sub>2</sub>, expr) =<br>
          &nbsp;&nbsp;&nbsp;
          { merge(&mu;<sub>1,</sub> &mu;<sub>2</sub>) | &mu;<sub>1</sub> in &Omega;<sub>1</sub>and &mu;<sub>2</sub> in
  &Omega;<sub>2</sub>, and &mu;<sub>1</sub> and &mu;<sub>2</sub> are compatible and expr(merge(&mu;<sub>1</sub>,
  &mu;<sub>2</sub>)) is true }<br>
              <i>set-union</i><br>
          &nbsp;&nbsp;&nbsp;
          { &mu;<sub>1</sub> | &mu;<sub>1</sub> in &Omega;<sub>1</sub>and &mu;<sub>2</sub> in &Omega;<sub>2</sub>, and
  &mu;<sub>1</sub> and &mu;<sub>2</sub> are not compatible }<br>
              <i>set-union</i><br>
          &nbsp;&nbsp;&nbsp;
          { &mu;<sub>1</sub> | &mu;<sub>1</sub> in &Omega;<sub>1</sub>and &mu;<sub>2</sub> in &Omega;<sub>2</sub>, and
  &mu;<sub>1</sub> and &mu;<sub>2</sub> are compatible and expr(merge(&mu;<sub>1</sub>, &mu;<sub>2</sub>)) is false
  }</p>

  <p>これらが異なっているため、LeftJoinのカーディナリティーは、定義のこれらの個々の構成要素のカーディナリティーです。</p>

  <div class="defn">
    <p><b>定義: <a id="defn_algUnion" name="defn_algUnion">Union</a></b></p>

    <p>&Omega;<sub>1</sub>と&Omega;<sub>2</sub>をソリューション・マッピングの多重集合とします。次のとおり定義します。</p>

    <p>Union(&Omega;<sub>1</sub>, &Omega;<sub>2</sub>) = { &mu; | &mu; in &Omega;<sub>1</sub> or &mu; in
    &Omega;<sub>2</sub> }</p>

    <p>card[Union(&Omega;1, &Omega;2)](&mu;) = card[&Omega;1](&mu;) + card[&Omega;2](&mu;)</p>
  </div>

  <p>C(x)が真である要素のシーケンスを[x | C]と記述します。</p>

  <p>Lにおけるxのカーディナリティーになるようにcard[L](x)を記述します。</p>

  <div class="defn">
    <b>定義: <a id="defn_algToList" name="defn_algToList">ToList</a></b>

    <p>&Omega;をソリューション・マッピングの多重集合とします。次のとおり定義します。</p>

    <p>ToList(&Omega;) = a sequence of mappings &mu; in &Omega; in any order, with card[&Omega;](&mu;) occurrences of
    &mu;</p>

    <p>card[ToList(&Omega;)](&mu;) = card[&Omega;](&mu;)</p>
  </div>

  <div class="defn">
    <b>定義: <a id="defn_algOrdered" name="defn_algOrdered">OrderBy</a></b>

    <p>&Psi;をソリューション・マッピングのシーケンスとします。次のとおり定義します。</p>

    <p><a id="defn_algOrderBy0" name="defn_algOrderBy0">OrderBy</a>(&Psi;, condition) = [ &mu; | &mu; in &Psi; and the
    sequence satisfies the ordering condition]</p>

    <p>card[<a id="defn_algOrderBy1" name="defn_algOrderBy1">OrderBy</a>(&Psi;, condition)](&mu;) =
    card[&Psi;](&mu;)</p>
  </div>

  <div class="defn">
    <b>定義: <a id="defn_algProjection" name="defn_algProjection">Project</a></b>

    <p>&Psi;をソリューション・マッピングのシーケンスとし、PVを変数の集合とします。</p>

    <p>マッピング&mu;に対し、PVの変数に対する&mu;の制限になるようにProj(&mu;, PV)を記述します。</p>
    <p>Project(&Psi;, PV)  = [ Proj(&Psi;[&#956;], PV) | &#956; in &#936; ]</p>

    <p>card[Project(&Psi;, PV)](&#956;) = card[&#936;](&#956;)</p>

    <p>Project(&Psi;, PV)の順序は、OrderByによって与えられた順序付けを保持しなければなりません。</p>
  </div>

  <div class="defn">
    <b>定義: <a id="defn_algDistinct" name="defn_algDistinct">Distinct</a></b>

    <p>&Psi;をソリューション・マッピングのシーケンスとします。次のとおり定義します。</p>

    <p>Distinct(&Psi;) = [ &#956; | &#956; in &#936; ]</p>
    <p>card[Distinct(&Psi;)](&mu;) = 1</p>

    <p>Distinct(&Psi;)の順序は、OrderByによって与えられた順序付けを保持しなければなりません。</p>
  </div>

  <div class="defn">
    <b>定義: <a id="defn_algReduced" name="defn_algReduced">Reduced</a></b>

    <p>&Psi;をソリューション・マッピングのシーケンスとします。次のとおり定義します。</p>

    <p>Reduced(&Psi;) = [ &#956; | &#956; in &#936; ]</p>
    <p>card[Reduced(&Psi;)](&mu;) is between 1 and card[&#936;](&#956;)</p>

    <p>Reduced(&Psi;)の順序は、OrderByによって与えられた順序付けを保持しなければなりません。</p>  </div>

  <p>Reducedソリューション・シーケンス修飾子は、定義済みのカーディナリティーを保証しません。</p>

  <div class="defn">
    <b>定義: <a id="defn_algSlice" name="defn_algSlice">Slice</a></b>

    <p>&Psi;をソリューション・マッピングのシーケンスとします。次のとおり定義します。</p>

    <p><a name="defn_algOrderBy2" id="defn_algOrderBy2">Slice</a>(&Psi;, start, length)[i] = &Psi;[start+i] for i = 0
    to (length-1)</p>  </div>

  <h3>12.5 <a id="sparqlAlgebraEval" name="sparqlAlgebraEval">評価セマンティクス</a>
</h3>

  <p>我々は、eval(D(G), graph pattern)を、アクティブ・グラフGを持つデータセットDに関するグラフ・パターンの評価であると定義しています。アクティブ・グラフは、最初はデフォルト・グラフです。</p>

  <pre class="box">
D : データセット
D(G) : アクティブ・グラフGを持つデータセットD（パターンがマッチするもの）
D[i] : データセットDにIRI iを持つグラフ
D[DFT] : Dのデフォルト・グラフ
P, P1, P2 : グラフ・パターン
L : ソリューション・シーケンス</pre>
<div class="defn">
    <b>定義: <a id="defn_evalFilter" name="defn_evalFilter">Filter(F, P)の評価</a></b>
    <pre class="code">
eval(D(G), Filter(F, P)) = Filter(F, eval(D(G),P))</pre>
  </div>

  <div class="defn">
    <b>定義: <a id="defn_evalJoin" name="defn_evalJoin">Join(P1, P2)の評価</a></b>
    <pre class="code">
eval(D(G), Join(P1, P2)) = Join(eval(D(G), P1), eval(D(G), P2))</pre>
  </div>

  <div class="defn">
    <b>定義: <a id="defn_evalLeftJoin" name="defn_evalLeftJoin">LeftJoin(P1, P2, F)の評価</a></b>
    <pre class="code">eval(D(G), LeftJoin(P1, P2, F)) = LeftJoin(eval(D(G), P1), eval(D(G), P2), F)
</pre>
  </div>

  <div class="defn">
    <b>定義: <a id="defn_evalBasicGraphPattern" name="defn_evalBasicGraphPattern">基本グラフ・パターンの評価</a></b>
	<pre class="code">eval(D(G), BGP) = multiset of solution mappings</pre>
    <p><a href="#BasicGraphPattern">12.3 基本グラフ・パターン</a>の項を参照してください。</p>
  </div>

  <div class="defn">
    <b>定義: <a id="defn_evalUnion" name="defn_evalUnion">Unionパターンの評価</a></b>
    <pre class="code">
eval(D(G), Union(P1,P2)) = Union(eval(D(G), P1), eval(D(G), P2))
</pre>
  </div>

  <div class="defn">
    <b>定義: <a id="defn_evalGraph" name="defn_evalGraph">グラフ・パターンの評価</a></b>
    <pre class="code">
if IRI is a graph name in D
eval(D(G), Graph(IRI,P)) = eval(D(D[IRI]), P)</pre>
    <pre class="code">
if IRI is not a graph name in D
eval(D(G), Graph(IRI,P)) = the empty multiset</pre>
    <pre class="code">
eval(D(G), Graph(var,P)) =
     Let R be the empty multiset
     foreach IRI i in D
        R := Union(R, Join( eval(D(D[i]), P) , &Omega;(?var-&gt;i) )
     the result is R
</pre>
  </div>

<p>グラフの評価は、SPARQL代数和集合演算子を使用します。ソリューション・マッピングのカーディナリティーは、それぞれのjoinの操作における、そのソリューション・マッピングのカーディナリティーの合計です。</p>

  <div class="defn">
    <b>定義: <a id="defn_evalList" name="defn_evalList">ToListの評価</a></b><pre class="code">
eval(D, ToList(P)) = ToList(eval(D(D[DFT]), P))
</pre>
  </div>

  <div class="defn">
    <b>定義: <a id="defn_evalDistinct" name="defn_evalDistinct">Distinctの評価</a></b><pre class="code">
eval(D, Distict(L)) = Distinct(eval(D, L))
</pre>
  </div>

  <div class="defn">
    <b>定義: <a id="defn_evalReduced" name="defn_evalReduced">Reducedの評価</a></b><pre class="code">
eval(D, Reduced(L)) = Reduced(eval(D, L))
</pre>
  </div>

  <div class="defn">
    <b>定義: <a id="defn_evalProject" name="defn_evalProject">Projectの評価</a></b><pre class="code">
eval(D, Project(L, vars)) = Project(eval(D, L), vars)
</pre>
  </div>

  <div class="defn">
    <b>定義: <a id="defn_evalOrderBy" name="defn_evalOrderBy">OrderByの評価</a></b><pre class="code">
eval(D, OrderBy(L, condition)) = OrderBy(eval(D, L), condition)
</pre>
  </div>

  <div class="defn">
    <b>定義: <a id="defn_evalSlice" name="defn_evalSlice">Sliceの評価</a></b><pre class="code">
eval(D, Slice(L, start, length)) = Slice(eval(D, L), start, length)
</pre>
  </div>
  
<h3>12.6 <a id="sparqlBGPExtend" name="sparqlBGPExtend">SPARQL基本グラフ・マッチングの拡張</a>
</h3>
<p>SPARQLの全体的な設計は、基本グラフ・パターンにマッチングした条件を書き直すことによって、シンプルな含意ではなく、より精緻な形式の含意を想定したクエリに使用できます。1つの一般的な形式でそのような条件を記述し、それをすべての形式の含意に適用して不必要または不適切な重複を最適に排除することは、未解決の研究課題であるため、このドキュメントは、そのようなソリューションが満たすべき必要条件を提示するのみです。これらは、それぞれの具体的な事例に対する完全な定義に拡張する必要があるでしょう。</p>

 <p>基本グラフ・パターンは、RDFグラフがRDFトリプルに対して行うトリプルのパターンと同じ関係にあり、同じ用語の多くをそれらに適用できます。特に、トリプル（M(s), M(p) M(o)）が2番目のパターンにある場合に限りトリプル（s, p, o）が最初のパターンに存在するような、空白ノードを空白ノードにマッピングし、変数、リテラル、およびIRIをそれら自身にマッピングするトリプル・パターンの用語間に全単射Mがある場合、2つの基本グラフ・パターンはが<i>同等</i>であると述べられます。この定義は、変数名を同等なパターン全体で保持することによって、RDFグラフの同等性に対し、それを基本グラフ・パターンに拡張します。</p>

<p><i>含意レジーム</i>（entailment regime）は、次の仕様を定めます。</p>

<ol>
	<li>レジームに対する<i>整形式</i>と呼ばれるRDFグラフのサブセット</li>
	<li>整形式のグラフと整形式のグラフのサブセットの間の<i>含意</i>関係</li>
</ol>

<p>含意レジームに関する例には、シンプルな含意（simple entailment）[<a href="#RDF-MT">RDF-MT</a>]、RDF含意（RDF entailment）[<a href="#RDF-MT">RDF-MT</a>]、RDFS含意（RDFS entailment）[<a href="#RDF-MT">RDF-MT</a>]、D-含意（D-entailment）[<a href="#RDF-MT">RDF-MT</a>]、およびOWL-DL含意（OWL-DL entailment）[<a href="#OWL_Semantics">OWL-Semantics</a>]が含まれています。これらのうち、OWL-DL含意のみが整形式グラフの集合を制限します。Eが含意レジームである場合、この名前付けの慣習に従い、E-含意（E-entailment）、E-整合性（E-consistency）などについて言及します。</p>

<p>いくつかの含意レジームは、いくつかのRDFグラフを、矛盾すると分類することができます。例えば、次のRDFグラフは、</p>

<pre class="data">
_:x rdf:type xsd:string ._:x rdf:type xsd:decimal .
</pre>

<p>DがXSDデータ型を含んでいる場合、D矛盾です。矛盾したグラフへのクエリの効果は、この仕様ではカバーしていませんが、特定のSPARQLの拡張で指定しなければなりません。</p>
        
        
<p>E-含意（E-entailment）へのSPARQLの拡張は、以下の条件を満たさなければなりません。</p>

<p>1 -- 任意の整合性のあるアクティブ・グラフAGに対応している<a href="#BGPsparqlBNodes">スコーピング・グラフ</a>SGは、一意に指定され、AGにE-同等（E-equivalent）です。</p>

<p>2 -- 任意の基本グラフ・パターンBGPとパターン・ソリューション・マッピングPの場合、P(BGP)はEに対する整形式です。</p>

<p>3 -- 基本グラフ・パターンBGPに対する任意のスコーピング・グラフSGおよび答えの集合{P<sub>1</sub> ... P<sub>n</sub>}の場合、そして、{BGP<sub>1 .... </sub>BGP<sub>n</sub>}がBGPにすべて同等な基本グラフ・パターンの集合である場合は、これらのうちのどれもが、他のものまたはSGと空白ノードを共有しません。</p>

<blockquote>
	<p>SG E-entails (SG union P<sub>1</sub>(BGP<sub>1</sub>) union ... union P<sub>n</sub>(BGP<sub>n</sub>))</p>
</blockquote>
<p>RDFがいくらでも重複を許すため、これらの条件は、ありえる答えの集合を完全に決定するわけではありません。さらに、したがって、下記が当てはまらなければなりません。</p>

<p>4 -- それぞれのSPARQLの拡張は、すべてのBGPとAGが、RDFグラフ同等性を除いて一意である有限の答えの集合を持つことを保証する答えの集合における条件を提供しなければなりません。</p>

<h4 id="sparqlBGPExtend-notes">注意</h4>

<p>(a) SGは、しばしばAGと同等のグラフになるでしょうが、これをE-同等（E-equivalence）に制限すると、例えばセマンティックな重複の排除などのいくつかの形式の正規化をクエリの実行前にソース・ドキュメントに適用することが可能になります。</p>

<p>(b) 条件3の構築は、空白ノードがSGで出現する方法と内部的に整合性があるような方法で、ソリューション・マッピングによって導入された任意の空白ノードが確実に用いられるようになります。これにより、答えの集合の中の1つ以上の答えで、そのように識別された空白ノードが本当にSGにおいて同じであるときにのみ、空白ノード識別子が確実に生じます。拡張が空白ノードへの答えのバインディングを許さない場合、この条件は以下の条件に簡略化できます。</p>

<blockquote>
	<p>SG E-entails P(BGP) for each pattern solution P.</p>
</blockquote>

<p>(c) これらの条件は、SGがAGまたはBGPと空白ノードを共有しないという要件をSPARQLに課しません。特に、これによって、SGが実際にAGになることが可能になります。これにより、空白ノード識別子がクエリとソース・ドキュメントの間や複数のクエリにまたがって意味を保有するクエリ・プロトコルが可能になります。しかし、そのようなプロトコルは、現在のSPARQLプロトコル仕様ではサポートされていません。</p>

<p>(d) 条件1～3のみが答えにおける必要条件であるため、条件4では、正当な答えの集合を様々な方法で制限しうるケースが許されます。例えば、OWL-DLクエリの最新技術は、空白ノードへの答えのバインディングが禁止されているケースに注目しています。これらの条件が、すべてのクエリが空の答えの集合を有する病的な「ミュート」のケースさえ許すことに注意してください。</p>

<p>(e) これらの条件は、BGPの空白ノードにおけるインスタンス・マッピングを明示的に参照しません。いくつかの含意レジームに関しては、1つのインスタンス・マッピングの存在によって、空白ノードの存在を表す解釈を完全に得ることができるわけではありません。これらの条件は、このようなレジームがクエリ・パターンの空白ノードに「完全に存在する」読込みを与えることを許します。</p>

<p>SGにおけるSPARQL条件が、AGにグラフ同等（graph-equivalent）であるけれども、AGやBGPと空白ノードを共有しないという（最初の条件を満たす）ものである場合、Eがシンプルな含意であるケースのこれらの条件をSPARQLが満たすということを示すと分かりやすいです。唯一の重要な条件は(3)です。</p>

<p>すべての答えP<sub>i</sub>は、M<sub>i</sub>(BGP<sub>i</sub>)がSGのサブグラフであるようなSPARQLインスタンスM<sub>i</sub>のソリューション・マッピングの制限です。BGP<sub>i</sub>とSGが共通の空白ノードを持たないため、M<sub>i</sub>の範囲にはBGP<sub>i</sub>の空白ノードは含まれません。したがって、ソリューション・マッピングP<sub>i</sub>とM<sub>i</sub>のRDFインスタンス・マッピングI<sub>i</sub>構成要素は交換され、したがって、M<sub>i</sub>(BGP<sub>i</sub>) = I<sub>i</sub>(P<sub>i</sub>(BGP<sub>i</sub>))です。したがって、次のとおりです。</p>

<p>M<sub>1</sub>(BGP<sub>1</sub>) union ... union M<sub>n</sub>(BGP<sub>n</sub>)
<br>= I<sub>1</sub>(P<sub>1</sub>(BGP<sub>1</sub>)) union ... union I<sub>n</sub>(P<sub>n</sub>(BGP<sub>n</sub>))<br>= [ I<sub>1</sub> + ... + I<sub>n</sub>]( P<sub>1</sub>(BGP<sub>1</sub>) union 
... union P<sub>n</sub>(BGP<sub>n</sub>) )</p>

<p>これは、I<sub>i</sub>インスタンス・マッピングの定義域がすべて互いに排他的であるためです。これらがSGから排他的であるためでもあります。</p>

<p>SG union [ I<sub>1</sub> + ... + I<sub>n</sub>]( P<sub>1</sub>(BGP<sub>1</sub>) 
union ... union P<sub>n</sub>(BGP<sub>n</sub>) )<br>= [ I<sub>1</sub> + ... + I<sub>n</sub>](SG union P<sub>1</sub>(BGP<sub>1</sub>) union ... union P<sub>n</sub>(BGP<sub>n</sub>) )</p>

<p>すなわち、</p>

<p>SG union P<sub>1</sub>(BGP<sub>1</sub>) union ... union P<sub>n</sub>(BGP<sub>n</sub>)</p>

<p>は、SGのサブグラフであるインスタンスを持っており、そのため、<a href="www.w3.org/TR/rdf-mt/#interplemmaprf">RDF補間定理</a>[<a href="#RDF-MT">RDF-MT</a>]によるSGによって簡単に含意されます。</p>

<h2>A. <a id="grammar" name="grammar">SPARQL文法</a>
</h2>

<h4>A.1 <a id="queryString" name="queryString">SPARQLクエリ文字列</a>
</h4>

<p><a name="defn_SPARQLQueryString" id="defn_SPARQLQueryString">SPARQLクエリ文字列</a>は、<a href="#rQuery">Query</a>の生成規則で始まる、以下の文法によって定義された言語のUnicodeの文字列（参照：[<a href="#CHARMOD">CHARMOD</a>]の6.1項 文字列の概念）です。Unicodeの将来のバージョンとの互換性のために、この文字列中の文字には、この公表日の時点で割り当てられていないUnicodeコードポイントを含むことができるようになっています（<a class="inform" href="www.unicode.org/reports/tr31/tr31-5.html">識別子とパターン構文</a>[<a href="#UNIID">UNIID</a>]の4項 パターン構文を参照）。除外されている文字クラスを伴う生成規則（例えば、<code>[^&lt;&gt;&#39;{}|^`]</code>）では、それらの文字は<code>#x0 - #x10FFFF</code>の範囲から除外されます。</p>
<h4>A.2 <a id="codepointEscape" name="codepointEscape">コードポイント・エスケープ・シーケンス</a>
</h4>

<p>SPARQLクエリ文字列は、以下のEBNFで定義された文法によって分析する前に、コードポイント・エスケープ・シーケンス用に処理されます。SPARQLクエリ文字列用のコードポイント・エスケープ・シーケンスは、以下の通りです。</p>

<table summary="Codepoint escapes" id="table68">
	<colgroup>
<col width="40%">
	</colgroup>
	<tr>
		<th class="major">エスケープ</th>
		<th class="major">Unicodeコードポイント</th>
	</tr>
	<tr>
		<td>
<span class="token">&#39;\u&#39;</span> <a href="#rHEX">HEX</a>
		<a href="#rHEX">HEX</a> <a href="#rHEX">HEX</a> <a href="#rHEX">HEX</a>
</td>
		<td>コード化された16進の値に対応する包括的な範囲U+0～U+FFFFのUnicodeコード・ポイント。</td>
	</tr>
	<tr>
		<td>
<span class="token">&#39;\U&#39;</span> <a href="#rHEX">HEX</a>
		<a href="#rHEX">HEX</a> <a href="#rHEX">HEX</a> <a href="#rHEX">HEX</a>
		<a href="#rHEX">HEX</a> <a href="#rHEX">HEX</a> <a href="#rHEX">HEX</a>
		<a href="#rHEX">HEX</a>
</td>
		<td>コード化された16進の値に対応する包括的な範囲U+0～U+10FFFFのUnicodeコード・ポイント。</td>
	</tr>
</table>

<p>ここでは、<a href="#rHEX">HEX</a>は16進の文字です。</p>

<blockquote>
	<p><span style="font-family: monospace; font-size: 85%"><a name="rHEX" id="rHEX">HEX</a> 
  ::= [0-9] | [A-F] | [a-f]</span></p>
</blockquote>

<p>例:</p>

<pre class="query untested">&lt;abéxy&gt;        # Codepoint 00E9 is Latin small e with acute - &eacute;
α:a            # Codepoint x03B1 is Greek small alpha - &#945;
a:b            # a:b -- codepoint x3A is colon</pre>

<p>コードポイント・エスケープ・シーケンスは、クエリ文字列のどこにでも出現できます。これらは、文法規則に基づいた分析の前に処理され、したがって、接頭辞付き名前をマーク付けする「<code>:</code>」のような、文法中で重要性を持つコードポイントに置き換えられることがあります。</p>

<p>これらのエスケープ・シーケンスは、以下の文法に含まれていません。その時点で文法上正当な文字列のエスケープ・シーケンスのみが示されるかもしれません。例えば、変数「<code>?x y</code>」は、正当ではありません（<code> </code>はスペースであり、変数名では許されていない）。</p>

<h4>A.3 <a id="whitespace" name="whitespace">空白</a>
</h4>

<p>空白（生成規則<code class="gRuleBody"><a href="#rWS">WS</a></code>）は2つの終端記号を区切るために用いられ、そうでなければ、1つの終端記号として（誤）認識されます。下記の大文字の規則名は、空白が重要である場合を示します。これらは、SPARQLパーサを構築するための可能な端末の選択を形成します。文字列において空白は重要です。</p>

<p>例えば、</p>

<blockquote>
	<p><code>?a&lt;?b&amp;&amp;?c&gt;?d</code></p>
</blockquote>

<p>は、トークン・シーケンスの変数「<code>?a</code>」、IRI「<code>&lt;?b&amp;&amp;?c&gt;</code>」、変数「<code>?d</code>」であり、「<code>&lt;</code>」（小なり）および「<code>&gt;</code>」（大なり）を用いた2つの式を結合した演算子「<code>&amp;&amp;</code>」を含んだ式ではありません。</p>

<h4>A.4 <a id="grammarComments" name="grammarComments">コメント</a>
</h4>

<p>SPARQLクエリにおけるコメントは、IRI中または文字列中以外では、「<code>#</code>」の形式をとり、これは、行末（文字列<code>0x0D</code>または<code>0x0A</code>でマーク付けされる）まで続くか、コメント・マーカーの後に行末がなければファイルの終りまで続きます。コメントは空白として扱われます。</p>

<h4>A.5 <a id="iriRefs" name="iriRefs">IRI参照</a>
</h4>

<p><code class="gRuleBody"><a href="#rIRI_REF">IRI_REF</a></code>生成規則および<code class="gRuleHead"><a href="#rPrefixedName">PrefixedName</a></code>（接頭辞拡張の後の）生成規則でマッチングされたテキストは、エスケープ処理の後に、RFC 3987[<a href="#rfc3987">RFC3987</a>]の2.2項「IRI参照およびIRIのためのABNF」のIRI参照の一般的な構文に適合していなければなりません。例えば、<code class="gRuleBody"><a href="#rIRI_REF">IRI_REF</a></code> <code>&lt;abc#def&gt;</code>は、SPARQLクエリ文字列で出現可能ですが、<code class="gRuleBody"><a href="#rIRI_REF">IRI_REF</a></code> <code>&lt;abc##def&gt;</code>は出現できません。</p>

<p>キーワード<span class="token">BASE</span>で宣言された基底IRIは、絶対IRIでなければなりません。キーワード<span class="token">PREFIX</span>で宣言された接頭辞は、同じクエリ中で再宣言できません。<span class="token">BASE</span>と<span class="token">PREFIX</span>の記述に関しては、2.1.1項、<a href="#QSynIRI">IRI用語の構文</a>を参照してください。</p>

<h4>A.6 <a id="grammarBNodeLabels" name="grammarBNodeLabels">空白ノード・ラベル</a>
</h4>

<p>1つのクエリを持つ2つの別々の基本グラフ・パターンでは、同じ空白ノード・ラベルを使用してはなりません。</p>

<h4>A.7 <a id="grammarEscapes" name="grammarEscapes">文字列中のエスケープ・シーケンス</a>
</h4>

<p><a href="#codepointEscape">コードポイント・エスケープ・シーケンス</a>に加え、下記は、任意の<code><a href="#rString">string</a></code>生成規則（例えば、<code><a href="#rSTRING_LITERAL1">STRING_LITERAL1</a></code>、<code><a href="#rSTRING_LITERAL2">STRING_LITERAL2</a></code>、<code><a href="#rSTRING_LITERAL_LONG1">STRING_LITERAL_LONG1</a></code>、<code><a href="#rSTRING_LITERAL_LONG2">STRING_LITERAL_LONG2</a></code>）のエスケープ・シーケンスを行います。</p>

<table summary="String escapes">
	<colgroup>
<col width="40%">
	</colgroup>
	<tr>
		<th class="major">エスケープ</th>
		<th class="major">Unicodeコードポイント</th>
	</tr>
	<tr>
		<td><span class="token">&#39;\t&#39;</span></td>
		<td>U+0009（タブ）</td>
	</tr>
	<tr>
		<td><span class="token">&#39;\n&#39;</span></td>
		<td>U+000A（改行）</td>
	</tr>
	<tr>
		<td><span class="token">&#39;\r&#39;</span></td>
		<td>U+000D（復帰）</td>
	</tr>
	<tr>
		<td><span class="token">&#39;\b&#39;</span></td>
		<td>U+0008（バックスペース）</td>
	</tr>
	<tr>
		<td><span class="token">&#39;\f&#39;</span></td>
		<td>U+000C（改ページ）</td>
	</tr>
	<tr>
		<td><span class="token">&#39;\&quot;&#39;</span></td>
		<td>U+0022（引用符、二重引用符）</td>
	</tr>
	<tr>
		<td><span class="token">&quot;\&#39;&quot;</span></td>
		<td>U+0027（アポストロフィ、一重引用符）</td>
	</tr>
	<tr>
		<td><span class="token">&#39;\\&#39;</span></td>
		<td>U+005C（逆斜線）</td>
	</tr>
</table>

<p>例:</p>

<pre class="query untested">&quot;abc\n&quot;
&quot;xy\rz&quot;
&#39;xy\tz&#39;</pre>

<h4>A.8 <a name="sparqlGrammar" id="sparqlGrammar">文法</a>
</h4>

<p>文法で用いられるEBNF表記法は、XML（Extensible Markup Language）1.1[<a href="#XML11">XML11</a>]の6項の<a class="norm" href="www.w3.org/TR/2004/REC-xml11-20040204/#sec-notation">表記法</a>で定義されています。</p>

<p>キーワードは、TurtleとN3に沿ってIRI <code>rdf:type</code>の代わりに用いられるキーワード「<code>a</code>」を除き、大文字・小文字を区別しない方法でマッチします（完全形では、<code><a href="www.w3.org/1999/02/22-rdf-syntax-ns#type">http://www.w3.org/1999/02/22-rdf-syntax-ns#type</a></code>）。</p>

<p>キーワード:</p>

<!-- <table cellpadding="0" cellspacing="1" style="border-collapse: collapse"> -->
<table class="plain">
	<tbody>
		<tr>
			<td>BASE</td>
			<td>SELECT</td>
			<td>ORDER BY</td>
			<td>FROM</td>
			<td>GRAPH</td>
			<td>STR</td>
			<td>isURI</td>
		</tr>
		<tr>
			<td>PREFIX</td>
			<td>CONSTRUCT</td>
			<td>LIMIT</td>			<td>FROM NAMED</td>
			<td>OPTIONAL</td>
			<td>LANG</td>
			<td>isIRI</td>
		</tr>
		<tr>
			<td>&nbsp;</td>
			<td>DESCRIBE</td>
			<td>OFFSET</td>
			<td>WHERE</td>
			<td>UNION</td>
			<td>LANGMATCHES</td>
			<td>isLITERAL</td>
		</tr>
		<tr>
			<td>&nbsp;</td>
			<td>ASK</td>
			<td>DISTINCT</td>
			<td>&nbsp;</td>
			<td>FILTER</td>
			<td>DATATYPE</td>
			<td>REGEX</td>
		</tr>
		<tr>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
			<td>REDUCED</td>
			<td>&nbsp;</td>
			<td>a</td>
			<td>BOUND</td>
			<td>true</td>
		</tr>
		<tr>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
			<td>&nbsp;</td>
			<td>sameTERM</td>
			<td>false</td>
		</tr>
	</tbody>
</table>

<p>エスケープ・シーケンスは、大文字と小文字を区別します。</p>

<p>マッチする規則を選選択するときには、最も長いマッチが選ばれます。</p>

<!-- MARKER html GRAMMAR -->

<div class="grammarTable">
  <table><tbody>

<tr valign="baseline">
  <td><code class="gRuleLabel">[1]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rQuery" name="rQuery">Query</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rPrologue">Prologue</a><br>( <a href="#rSelectQuery">SelectQuery</a> | <a href="#rConstructQuery">ConstructQuery</a> | <a href="#rDescribeQuery">DescribeQuery</a> | <a href="#rAskQuery">AskQuery</a> )</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[2]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rPrologue" name="rPrologue">Prologue</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rBaseDecl">BaseDecl</a>? <a href="#rPrefixDecl">PrefixDecl</a>*</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[3]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rBaseDecl" name="rBaseDecl">BaseDecl</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'BASE'</span> <a href="#rIRI_REF">IRI_REF</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[4]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rPrefixDecl" name="rPrefixDecl">PrefixDecl</a></code></td>  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'PREFIX'</span> <a href="#rPNAME_NS">PNAME_NS</a> <a href="#rIRI_REF">IRI_REF</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[5]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rSelectQuery" name="rSelectQuery">SelectQuery</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'SELECT'</span> ( <span class="token">'DISTINCT'</span> | <span class="token">'REDUCED'</span> )? ( <a href="#rVar">Var</a>+ | <span class="token">'*'</span> ) <a href="#rDatasetClause">DatasetClause</a>* <a href="#rWhereClause">WhereClause</a> <a href="#rSolutionModifier">SolutionModifier</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[6]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rConstructQuery" name="rConstructQuery">ConstructQuery</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'CONSTRUCT'</span> <a href="#rConstructTemplate">ConstructTemplate</a> <a href="#rDatasetClause">DatasetClause</a>* <a href="#rWhereClause">WhereClause</a> <a href="#rSolutionModifier">SolutionModifier</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[7]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rDescribeQuery" name="rDescribeQuery">DescribeQuery</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'DESCRIBE'</span> ( <a href="#rVarOrIRIref">VarOrIRIref</a>+ | <span class="token">'*'</span> ) <a href="#rDatasetClause">DatasetClause</a>* <a href="#rWhereClause">WhereClause</a>? <a href="#rSolutionModifier">SolutionModifier</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[8]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rAskQuery" name="rAskQuery">AskQuery</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'ASK'</span> <a href="#rDatasetClause">DatasetClause</a>* <a href="#rWhereClause">WhereClause</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[9]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rDatasetClause" name="rDatasetClause">DatasetClause</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'FROM'</span> ( <a href="#rDefaultGraphClause">DefaultGraphClause</a> | <a href="#rNamedGraphClause">NamedGraphClause</a> )</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[10]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rDefaultGraphClause" name="rDefaultGraphClause">DefaultGraphClause</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rSourceSelector">SourceSelector</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[11]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rNamedGraphClause" name="rNamedGraphClause">NamedGraphClause</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'NAMED'</span> <a href="#rSourceSelector">SourceSelector</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[12]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rSourceSelector" name="rSourceSelector">SourceSelector</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rIRIref">IRIref</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[13]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rWhereClause" name="rWhereClause">WhereClause</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'WHERE'</span>? <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[14]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rSolutionModifier" name="rSolutionModifier">SolutionModifier</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rOrderClause">OrderClause</a>? <a href="#rLimitOffsetClauses">LimitOffsetClauses</a>?</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[15]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rLimitOffsetClauses" name="rLimitOffsetClauses">LimitOffsetClauses</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">( <a href="#rLimitClause">LimitClause</a> <a href="#rOffsetClause">OffsetClause</a>? | <a href="#rOffsetClause">OffsetClause</a> <a href="#rLimitClause">LimitClause</a>? )</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[16]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rOrderClause" name="rOrderClause">OrderClause</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'ORDER'</span> <span class="token">'BY'</span> <a href="#rOrderCondition">OrderCondition</a>+</code></td>
</tr>
<tr valign="baseline">
  <td><code class="gRuleLabel">[17]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rOrderCondition" name="rOrderCondition">OrderCondition</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">   ( ( <span class="token">'ASC'</span> | <span class="token">'DESC'</span> ) <a href="#rBrackettedExpression">BrackettedExpression</a> )<br>| ( <a href="#rConstraint">Constraint</a> | <a href="#rVar">Var</a> ) </code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[18]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rLimitClause" name="rLimitClause">LimitClause</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'LIMIT'</span> <a href="#rINTEGER">INTEGER</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[19]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rOffsetClause" name="rOffsetClause">OffsetClause</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'OFFSET'</span> <a href="#rINTEGER">INTEGER</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[20]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rGroupGraphPattern" name="rGroupGraphPattern">GroupGraphPattern</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'{'</span> <a href="#rTriplesBlock">TriplesBlock</a>? ( ( <a href="#rGraphPatternNotTriples">GraphPatternNotTriples</a> | <a href="#rFilter">Filter</a> ) <span class="token">'.'</span>? <a href="#rTriplesBlock">TriplesBlock</a>? )* <span class="token">'}'</span></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[21]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rTriplesBlock" name="rTriplesBlock">TriplesBlock</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rTriplesSameSubject">TriplesSameSubject</a> ( <span class="token">'.'</span> <a href="#rTriplesBlock">TriplesBlock</a>? )?</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[22]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rGraphPatternNotTriples" name="rGraphPatternNotTriples">GraphPatternNotTriples</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rOptionalGraphPattern">OptionalGraphPattern</a> | <a href="#rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</a> | <a href="#rGraphGraphPattern">GraphGraphPattern</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[23]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rOptionalGraphPattern" name="rOptionalGraphPattern">OptionalGraphPattern</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'OPTIONAL'</span> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[24]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rGraphGraphPattern" name="rGraphGraphPattern">GraphGraphPattern</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'GRAPH'</span> <a href="#rVarOrIRIref">VarOrIRIref</a> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
</tr>
<tr valign="baseline">
  <td><code class="gRuleLabel">[25]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rGroupOrUnionGraphPattern" name="rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rGroupGraphPattern">GroupGraphPattern</a> ( <span class="token">'UNION'</span> <a href="#rGroupGraphPattern">GroupGraphPattern</a> )*</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[26]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rFilter" name="rFilter">Filter</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'FILTER'</span> <a href="#rConstraint">Constraint</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[27]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rConstraint" name="rConstraint">Constraint</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rBrackettedExpression">BrackettedExpression</a> | <a href="#rBuiltInCall">BuiltInCall</a> | <a href="#rFunctionCall">FunctionCall</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[28]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rFunctionCall" name="rFunctionCall">FunctionCall</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rIRIref">IRIref</a> <a href="#rArgList">ArgList</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[29]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rArgList" name="rArgList">ArgList</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">( <a href="#rNIL">NIL</a> | <span class="token">'('</span> <a href="#rExpression">Expression</a> ( <span class="token">','</span> <a href="#rExpression">Expression</a> )* <span class="token">')'</span> )</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[30]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rConstructTemplate" name="rConstructTemplate">ConstructTemplate</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'{'</span> <a href="#rConstructTriples">ConstructTriples</a>? <span class="token">'}'</span></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[31]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rConstructTriples" name="rConstructTriples">ConstructTriples</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rTriplesSameSubject">TriplesSameSubject</a> ( <span class="token">'.'</span> <a href="#rConstructTriples">ConstructTriples</a>? )?</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[32]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rTriplesSameSubject" name="rTriplesSameSubject">TriplesSameSubject</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rVarOrTerm">VarOrTerm</a> <a href="#rPropertyListNotEmpty">PropertyListNotEmpty</a> |	<a href="#rTriplesNode">TriplesNode</a> <a href="#rPropertyList">PropertyList</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[33]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rPropertyListNotEmpty" name="rPropertyListNotEmpty">PropertyListNotEmpty</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rVerb">Verb</a> <a href="#rObjectList">ObjectList</a> ( <span class="token">';'</span> ( <a href="#rVerb">Verb</a> <a href="#rObjectList">ObjectList</a> )? )*</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[34]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rPropertyList" name="rPropertyList">PropertyList</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rPropertyListNotEmpty">PropertyListNotEmpty</a>?</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[35]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rObjectList" name="rObjectList">ObjectList</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rObject">Object</a> ( <span class="token">','</span> <a href="#rObject">Object</a> )*</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[36]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rObject" name="rObject">Object</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rGraphNode">GraphNode</a></code></td>
</tr>
<tr valign="baseline">
  <td><code class="gRuleLabel">[37]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rVerb" name="rVerb">Verb</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rVarOrIRIref">VarOrIRIref</a> | <span class="token">'a'</span></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[38]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rTriplesNode" name="rTriplesNode">TriplesNode</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rCollection">Collection</a> |	<a href="#rBlankNodePropertyList">BlankNodePropertyList</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[39]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rBlankNodePropertyList" name="rBlankNodePropertyList">BlankNodePropertyList</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'['</span> <a href="#rPropertyListNotEmpty">PropertyListNotEmpty</a> <span class="token">']'</span></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[40]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rCollection" name="rCollection">Collection</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'('</span> <a href="#rGraphNode">GraphNode</a>+ <span class="token">')'</span></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[41]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rGraphNode" name="rGraphNode">GraphNode</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>  <td><code class="gRuleBody"><a href="#rVarOrTerm">VarOrTerm</a> |	<a href="#rTriplesNode">TriplesNode</a></code></td>
</tr>
<tr valign="baseline">
  <td><code class="gRuleLabel">[42]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rVarOrTerm" name="rVarOrTerm">VarOrTerm</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rVar">Var</a> | <a href="#rGraphTerm">GraphTerm</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[43]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rVarOrIRIref" name="rVarOrIRIref">VarOrIRIref</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rVar">Var</a> | <a href="#rIRIref">IRIref</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[44]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rVar" name="rVar">Var</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rVAR1">VAR1</a> | <a href="#rVAR2">VAR2</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[45]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rGraphTerm" name="rGraphTerm">GraphTerm</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rIRIref">IRIref</a> |	<a href="#rRDFLiteral">RDFLiteral</a> |	<a href="#rNumericLiteral">NumericLiteral</a> |	<a href="#rBooleanLiteral">BooleanLiteral</a> |	<a href="#rBlankNode">BlankNode</a> |	<a href="#rNIL">NIL</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[46]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rExpression" name="rExpression">Expression</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rConditionalOrExpression">ConditionalOrExpression</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[47]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rConditionalOrExpression" name="rConditionalOrExpression">ConditionalOrExpression</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rConditionalAndExpression">ConditionalAndExpression</a> ( <span class="token">'||'</span> <a href="#rConditionalAndExpression">ConditionalAndExpression</a> )*</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[48]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rConditionalAndExpression" name="rConditionalAndExpression">ConditionalAndExpression</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rValueLogical">ValueLogical</a> ( <span class="token">'&amp;&amp;'</span> <a href="#rValueLogical">ValueLogical</a> )*</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[49]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rValueLogical" name="rValueLogical">ValueLogical</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rRelationalExpression">RelationalExpression</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[50]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rRelationalExpression" name="rRelationalExpression">RelationalExpression</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rNumericExpression">NumericExpression</a> ( <span class="token">'='</span> <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'!='</span> <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'&lt;'</span> <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'&gt;'</span> <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'&lt;='</span> <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'&gt;='</span> <a href="#rNumericExpression">NumericExpression</a> )?</code></td>
</tr>
<tr valign="baseline">
  <td><code class="gRuleLabel">[51]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rNumericExpression" name="rNumericExpression">NumericExpression</a></code></td>  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rAdditiveExpression">AdditiveExpression</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[52]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rAdditiveExpression" name="rAdditiveExpression">AdditiveExpression</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rMultiplicativeExpression">MultiplicativeExpression</a> ( <span class="token">'+'</span> <a href="#rMultiplicativeExpression">MultiplicativeExpression</a> | <span class="token">'-'</span> <a href="#rMultiplicativeExpression">MultiplicativeExpression</a> | <a href="#rNumericLiteralPositive">NumericLiteralPositive</a> | <a href="#rNumericLiteralNegative">NumericLiteralNegative</a> )*</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[53]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rMultiplicativeExpression" name="rMultiplicativeExpression">MultiplicativeExpression</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rUnaryExpression">UnaryExpression</a> ( <span class="token">'*'</span> <a href="#rUnaryExpression">UnaryExpression</a> | <span class="token">'/'</span> <a href="#rUnaryExpression">UnaryExpression</a> )*</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[54]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rUnaryExpression" name="rUnaryExpression">UnaryExpression</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">&nbsp;&nbsp;<span class="token">'!'</span> <a href="#rPrimaryExpression">PrimaryExpression</a> <br>|	<span class="token">'+'</span> <a href="#rPrimaryExpression">PrimaryExpression</a> <br>|	<span class="token">'-'</span> <a href="#rPrimaryExpression">PrimaryExpression</a> <br>|	<a href="#rPrimaryExpression">PrimaryExpression</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[55]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rPrimaryExpression" name="rPrimaryExpression">PrimaryExpression</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rBrackettedExpression">BrackettedExpression</a> | <a href="#rBuiltInCall">BuiltInCall</a> | <a href="#rIRIrefOrFunction">IRIrefOrFunction</a> | <a href="#rRDFLiteral">RDFLiteral</a> | <a href="#rNumericLiteral">NumericLiteral</a> | <a href="#rBooleanLiteral">BooleanLiteral</a> | <a href="#rVar">Var</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[56]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rBrackettedExpression" name="rBrackettedExpression">BrackettedExpression</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[57]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rBuiltInCall" name="rBuiltInCall">BuiltInCall</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">&nbsp;&nbsp;<span class="token">'STR'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>|	<span class="token">'LANG'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>|	<span class="token">'LANGMATCHES'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>|	<span class="token">'DATATYPE'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>|	<span class="token">'BOUND'</span> <span class="token">'('</span> <a href="#rVar">Var</a> <span class="token">')'</span> <br>|	<span class="token">'sameTerm'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>|	<span class="token">'isIRI'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>|	<span class="token">'isURI'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>|	<span class="token">'isBLANK'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>|	<span class="token">'isLITERAL'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>|	<a href="#rRegexExpression">RegexExpression</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[58]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rRegexExpression" name="rRegexExpression">RegexExpression</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'REGEX'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> ( <span class="token">','</span> <a href="#rExpression">Expression</a> )? <span class="token">')'</span></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[59]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rIRIrefOrFunction" name="rIRIrefOrFunction">IRIrefOrFunction</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rIRIref">IRIref</a> <a href="#rArgList">ArgList</a>?</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[60]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rRDFLiteral" name="rRDFLiteral">RDFLiteral</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rString">String</a> ( <a href="#rLANGTAG">LANGTAG</a> | ( <span class="token">'^^'</span> <a href="#rIRIref">IRIref</a> ) )?</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[61]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rNumericLiteral" name="rNumericLiteral">NumericLiteral</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rNumericLiteralUnsigned">NumericLiteralUnsigned</a> | <a href="#rNumericLiteralPositive">NumericLiteralPositive</a> | <a href="#rNumericLiteralNegative">NumericLiteralNegative</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[62]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rNumericLiteralUnsigned" name="rNumericLiteralUnsigned">NumericLiteralUnsigned</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rINTEGER">INTEGER</a> |	<a href="#rDECIMAL">DECIMAL</a> |	<a href="#rDOUBLE">DOUBLE</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[63]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rNumericLiteralPositive" name="rNumericLiteralPositive">NumericLiteralPositive</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rINTEGER_POSITIVE">INTEGER_POSITIVE</a> |	<a href="#rDECIMAL_POSITIVE">DECIMAL_POSITIVE</a> |	<a href="#rDOUBLE_POSITIVE">DOUBLE_POSITIVE</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[64]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rNumericLiteralNegative" name="rNumericLiteralNegative">NumericLiteralNegative</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rINTEGER_NEGATIVE">INTEGER_NEGATIVE</a> |	<a href="#rDECIMAL_NEGATIVE">DECIMAL_NEGATIVE</a> |	<a href="#rDOUBLE_NEGATIVE">DOUBLE_NEGATIVE</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[65]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rBooleanLiteral" name="rBooleanLiteral">BooleanLiteral</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'true'</span> |	<span class="token">'false'</span></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[66]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rString" name="rString">String</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rSTRING_LITERAL1">STRING_LITERAL1</a> | <a href="#rSTRING_LITERAL2">STRING_LITERAL2</a> | <a href="#rSTRING_LITERAL_LONG1">STRING_LITERAL_LONG1</a> | <a href="#rSTRING_LITERAL_LONG2">STRING_LITERAL_LONG2</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[67]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rIRIref" name="rIRIref">IRIref</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rIRI_REF">IRI_REF</a> |	<a href="#rPrefixedName">PrefixedName</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[68]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rPrefixedName" name="rPrefixedName">PrefixedName</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rPNAME_LN">PNAME_LN</a> | <a href="#rPNAME_NS">PNAME_NS</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[69]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rBlankNode" name="rBlankNode">BlankNode</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rBLANK_NODE_LABEL">BLANK_NODE_LABEL</a> |	<a href="#rANON">ANON</a></code></td>
</tr>
</tbody></table>

<p>終端記号の生成規則:</p>

<table><tbody>

<tr valign="baseline">
  <td><code class="gRuleLabel">[70]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rIRI_REF" name="rIRI_REF">IRI_REF</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'&lt;' ([^&lt;&gt;&quot;{}|^`\]-[#x00-#x20])* '&gt;'</span></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[71]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rPNAME_NS" name="rPNAME_NS">PNAME_NS</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rPN_PREFIX">PN_PREFIX</a>? ':'</code></td>
</tr>
<tr valign="baseline">
  <td><code class="gRuleLabel">[72]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rPNAME_LN" name="rPNAME_LN">PNAME_LN</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rPNAME_NS">PNAME_NS</a> <a href="#rPN_LOCAL">PN_LOCAL</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[73]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rBLANK_NODE_LABEL" name="rBLANK_NODE_LABEL">BLANK_NODE_LABEL</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>  <td><code class="gRuleBody">'_:' <a href="#rPN_LOCAL">PN_LOCAL</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[74]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rVAR1" name="rVAR1">VAR1</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">'?' <a href="#rVARNAME">VARNAME</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[75]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rVAR2" name="rVAR2">VAR2</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">'$' <a href="#rVARNAME">VARNAME</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[76]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rLANGTAG" name="rLANGTAG">LANGTAG</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">'@' [a-zA-Z]+ ('-' [a-zA-Z0-9]+)*</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[77]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rINTEGER" name="rINTEGER">INTEGER</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">[0-9]+</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[78]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rDECIMAL" name="rDECIMAL">DECIMAL</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">[0-9]+ '.' [0-9]* | '.' [0-9]+</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[79]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rDOUBLE" name="rDOUBLE">DOUBLE</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">[0-9]+ '.' [0-9]* <a href="#rEXPONENT">EXPONENT</a> | '.' ([0-9])+ <a href="#rEXPONENT">EXPONENT</a> | ([0-9])+ <a href="#rEXPONENT">EXPONENT</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[80]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rINTEGER_POSITIVE" name="rINTEGER_POSITIVE">INTEGER_POSITIVE</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'+'</span> <a href="#rINTEGER">INTEGER</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[81]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rDECIMAL_POSITIVE" name="rDECIMAL_POSITIVE">DECIMAL_POSITIVE</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'+'</span> <a href="#rDECIMAL">DECIMAL</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[82]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rDOUBLE_POSITIVE" name="rDOUBLE_POSITIVE">DOUBLE_POSITIVE</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'+'</span> <a href="#rDOUBLE">DOUBLE</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[83]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rINTEGER_NEGATIVE" name="rINTEGER_NEGATIVE">INTEGER_NEGATIVE</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'-'</span> <a href="#rINTEGER">INTEGER</a></code></td>
</tr>
<tr valign="baseline">
  <td><code class="gRuleLabel">[84]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rDECIMAL_NEGATIVE" name="rDECIMAL_NEGATIVE">DECIMAL_NEGATIVE</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'-'</span> <a href="#rDECIMAL">DECIMAL</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[85]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rDOUBLE_NEGATIVE" name="rDOUBLE_NEGATIVE">DOUBLE_NEGATIVE</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><span class="token">'-'</span> <a href="#rDOUBLE">DOUBLE</a></code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[86]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rEXPONENT" name="rEXPONENT">EXPONENT</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">[eE] [+-]? [0-9]+</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[87]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rSTRING_LITERAL1" name="rSTRING_LITERAL1">STRING_LITERAL1</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">"'" ( ([^#x27#x5C#xA#xD]) | <a href="#rECHAR">ECHAR</a> )* "'"</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[88]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rSTRING_LITERAL2" name="rSTRING_LITERAL2">STRING_LITERAL2</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">'"' ( ([^#x22#x5C#xA#xD]) | <a href="#rECHAR">ECHAR</a> )* '"'</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[89]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rSTRING_LITERAL_LONG1" name="rSTRING_LITERAL_LONG1">STRING_LITERAL_LONG1</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">"'''" ( ( "'" | "''" )? ( [^'\] | <a href="#rECHAR">ECHAR</a> ) )* "'''"</code></td>
</tr>
<tr valign="baseline">
  <td><code class="gRuleLabel">[90]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rSTRING_LITERAL_LONG2" name="rSTRING_LITERAL_LONG2">STRING_LITERAL_LONG2</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">'"""' ( ( '"' | '""' )? ( [^"\] | <a href="#rECHAR">ECHAR</a> ) )* '"""'</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[91]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rECHAR" name="rECHAR">ECHAR</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">'\' [tbnrf\"']</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[92]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rNIL" name="rNIL">NIL</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">'(' <a href="#rWS">WS</a>* ')'</code></td>
</tr>
<tr valign="baseline">
  <td><code class="gRuleLabel">[93]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rWS" name="rWS">WS</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">#x20 | #x9 | #xD | #xA</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[94]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rANON" name="rANON">ANON</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">'['  <a href="#rWS">WS</a>* ']'</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[95]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rPN_CHARS_BASE" name="rPN_CHARS_BASE">PN_CHARS_BASE</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">[A-Z] | [a-z] | [#x00C0-#x00D6] | [#x00D8-#x00F6] | [#x00F8-#x02FF] | [#x0370-#x037D] | [#x037F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[96]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rPN_CHARS_U" name="rPN_CHARS_U">PN_CHARS_U</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rPN_CHARS_BASE">PN_CHARS_BASE</a> | '_'</code></td>
</tr>
<tr valign="baseline">
  <td><code class="gRuleLabel">[97]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rVARNAME" name="rVARNAME">VARNAME</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody">( <a href="#rPN_CHARS_U">PN_CHARS_U</a>  | [0-9] ) ( <a href="#rPN_CHARS_U">PN_CHARS_U</a> | [0-9] | #x00B7 | [#x0300-#x036F] | [#x203F-#x2040] )*</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[98]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rPN_CHARS" name="rPN_CHARS">PN_CHARS</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rPN_CHARS_U">PN_CHARS_U</a> | '-' | [0-9] | #x00B7 | [#x0300-#x036F] | [#x203F-#x2040]</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[99]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rPN_PREFIX" name="rPN_PREFIX">PN_PREFIX</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
  <td><code class="gRuleBody"><a href="#rPN_CHARS_BASE">PN_CHARS_BASE</a> ((<a href="#rPN_CHARS">PN_CHARS</a>|'.')* <a href="#rPN_CHARS">PN_CHARS</a>)?</code></td>
</tr>

<tr valign="baseline">
  <td><code class="gRuleLabel">[100]&nbsp;&nbsp;</code></td>
  <td><code class="gRuleHead"><a id="rPN_LOCAL" name="rPN_LOCAL">PN_LOCAL</a></code></td>
  <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
	    <td>
<code class="gRuleBody">( <a href="#rPN_CHARS_U">PN_CHARS_U</a> | [0-9] ) ((<a href="#rPN_CHARS">PN_CHARS</a>|'.')* <a href="#rPN_CHARS">PN_CHARS</a>)?</code><br>Note that <a href="#rPN_LOCAL">SPARQL local names</a> allow leading digits while <a href="www.w3.org/TR/2006/REC-xml-names11-20060816/#NT-LocalPart">XML local names</a> do not.</td>
</tr>
  </tbody></table>
</div>


<!-- /MARKER html GRAMMAR -->
  <p>注意:</p>
<ol>
	<li>大文字化された名前を持つ規則が終端記号として用いられるとき、SPARQL文法はLL(1)です。</li>
	<li>符号付きの数字では、符号と数字の間には空白は許されません。<code class="gRuleHead"><a href="#rAdditiveExpression">AdditiveExpression</a></code>文法規則は、符号付きの数字が後続する式の2つのケースをカバーすることで、これを可能にします。これらにより、必要に応じて、符号のない数の加算または減算が生じます。</li>
</ol>

<p>よく用いられているツールの文法ファイルを<a href="www.w3.org//2001/sw/DataAccess/rq23/parsers/">ここで入手</a>できます。</p>

<h2>B. <a id="conformance" name="conformance">適合性</a>
</h2>

<p><a href="#defn_SPARQLQueryString">SPARQLクエリ文字列</a>の適合性に関しては付録の<a href="#grammar">SPARQL文法</a>を、クエリ結果の適合性に関しては<a href="#QueryForms">10 クエリ形式</a>の項を参照してください。application/sparql-queryメディア・タイプへの適合性に関しては付録 <a href="#mediaType">E. インターネット・メディア・タイプ</a>を参照してください。</p>

<p>この仕様は、SPARQLプロトコル[<a href="#SPROT">SPROT</a>]およびSPARQLクエリ結果XMLフォーマット[<a href="#RESULTS">RESULTS</a>]との併用を意図しています。これらの適合性基準に関してはそれらの仕様を参照してください。</p>

<p>SPARQLプロトコルがネットワーク・プロトコルのみならず抽象的なインターフェースも記述し、抽象的なインターフェースがネットワーク・インターフェースのみならずAPIにも当てはまるかもしれないことに注意してください。</p>

<h2>C. <a id="security" name="security">セキュリティに関する留意点</a>（参考情報）</h2>

<p>FROM、FROM NAMED、またはGRAPHを用いたSPARQLクエリは、指定されたURIを逆参照するかもしれません。これは、サービスの拒否などの関連する副次的な問題と共に、ネットワーク、ディスクまたはCPU資源の追加使用を招くかもしれません。<a class="norm" href="www.ietf.org/rfc/rfc3986.txt">URI（Uniform Resource Identifier）:一般的構文</a>[<a href="#rfc3986">RFC3986</a>]の7項のセキュリティ問題について考察する必要があります。さらに、場合によっては、<code>file:</code> URIのコンテンツにアクセスし、処理し、結果として返すことができ、ローカル資源への予期しないアクセスが行われます。</p>

<p>SPARQL言語は拡張を認めており、それには独自のセキュリティ上の影響があるでしょう。</p>

<p>複数のIRIが同じ外観を持っているかもしれません。異なるスクリプトの文字が同じに見えるかもしれません（キリル文字の「&#1086;」はラテン文字の「o」と同じに見えるかもしれません）。 結合文字が後続する文字は、別の文字と同じ視覚的表現を持っているかもしれません（結合アキュート・アクセントが後続するラテン小文字Eは、アキュート付きラテン小文字Eと同じ視覚的表現を持っています）。SPARQLのユーザは、注意してデータ中のIRIにマッチするIRIを持つクエリを構築しなければなりません。類似している文字のマッチングに関する詳細は、<a class="inform" href="www.unicode.org/reports/tr36/">Unicodeセキュリティに関する留意点</a>[<a href="#UNISEC">UNISEC</a>]および<a class="norm" href="www.ietf.org/rfc/rfc3987.txt">IRI（Internationalized Resource Identifiers）</a>[<a href="#rfc3987">RFC3987</a>]の8項にあります。</p>

<h2>D. <a id="mediaType" name="mediaType">インターネット・メディア・タイプ、ファイル拡張子、およびマッキントッシュ・ファイル・タイプ</a>
</h2>

<dl>
	<dt>コンタクト:</dt>
	<dd>Eric Prud&#39;hommeaux</dd>
	<dt>参照:</dt>
	<dd><a href="www.w3.org/2002/06/registering-mediatype">W3C仕様に関するメディア・タイプの登録方法</a></dd>
	<dd>
<a href="www.w3.org/2001/tag/2002/0129-mime">インターネット・メディア・タイプ登録、使用の整合性</a><br>TAGの発見事項 2002年6月3日（2002年9月4日改定）</dd>
</dl>
<p>SPARQLクエリ言語のインターネット・メディア・タイプ/MIMEタイプは、「application/sparql-query」です。</p>

<p>sparqlクエリ・ファイルは、すべてのプラットホーム上で拡張子「.rq」（すべて小文字）であることが推奨されます。</p>

<p>マッキントッシュHFSファイル・システム上に保存されたsparqlクエリ・ファイルには、ファイル・タイプ「TEXT」が付与されていることが推奨されます。</p>

<dl>
	<dt>タイプ名:</dt>
	<dd>application</dd>
	<dt>サブタイプ名:</dt>
	<dd>sparql-query</dd>
	<dt>必須パラメータ:</dt>
	<dd>なし</dd>
	<dt>任意のパラメータ:</dt>
	<dd>なし</dd>
	<dt>コード化に関する留意点:</dt>
	<dd>SPARQLクエリ言語の構文は、Unicode[<a href="#UNICODE">UNICODE</a>]のコード・ポイントで表されます。コード化は、常にUTF-8[<a href="#rfc3629">RFC3629</a>]です。</dd>
	<dd>Unicodeコード・ポイントは、Xが16進の[0-9A-F]である場合、\uXXXX（U+0～U+FFFF）または\UXXXXXXXX構文（U+10000以降）を用いて表現できます。
</dd>
	<dt>セキュリティに関する留意点:</dt>
	<dd>SPARQLクエリ付録C、<a href="#security">セキュリティに関する留意点</a>および<a class="norm" href="www.ietf.org/rfc/rfc3629.txt">RFC 3629</a>[<a href="#rfc3629">RFC3629</a>]の7項、セキュリティに関する留意点を参照してください。</dd>
	<dt>互換性に関する留意点:</dt>
	<dd>互換性の問題は知られていません。</dd>
	<dt>公開済み仕様書:</dt>
	<dd>この仕様書。</dd>
	<dt>このメディア・タイプを使用するアプリケーション:</dt>
	<dd>現時点でこのメディア・タイプを使用するアプリケーションは知られていません。</dd>
	<dt>追加情報:</dt>
	<dt>マジック・ナンバー:</dt>
	<dd>SPARQLクエリは、ドキュメントの冒頭付近に、文字列「PREFIX」（大文字と小文字を区別しない）を持つことができます。</dd>
	<dt>ファイル拡張子:</dt>
	<dd>「.rq」</dd>
	<dt>基底URI:</dt>
	<dd>SPARQL「BASE &lt;IRIref&gt;」用語は、現在の基底URIを、ドキュメントにおいて後ほど順次使用されるクエリ言語内の相対IRIrefに変更できます。</dd>
	<dt>マッキントッシュ・ファイル・タイプ・コード:</dt>
	<dd>「TEXT」</dd>
	<dt>詳細情報に関する連絡先:</dt>
	<dd>public-rdf-dawg-comments@w3.org</dd>
	<dt>意図する使途:</dt>
	<dd>汎用</dd>
	<dt>使用上の制限:</dt>
	<dd>なし</dd>
	<dt>著者／改版管理者:</dt>
	<dd>SPARQL仕様は、ワールド・ワイド・ウェブ・コンソーシアム（World Wide Web Consortium）のRDFデータ・アクセス・ワーキンググループ（RDF Data Access Working Group）の作業の成果です。W3Cは、これらの仕様の変更に対する管理権を有します。</dd>
</dl>
<div>
	<h2>E. <a id="references" name="references">参考文献</a>
</h2>

	<h3 id="normativeRefs">規範的な参考文献</h3>

	<dl class="bib">
		<dt><a name="CHARMOD" id="CHARMOD">[CHARMOD]</a></dt>
		<dd>
<cite>
		<a href="www.w3.org/TR/2005/REC-charmod-20050215/">Character
      Model for the World Wide Web 1.0: Fundamentals</a></cite>,
      R. Ishida, F. Yergeau, M. J. D&uuml;st, M. Wolf, T. Texin,
      Editors, W3C Recommendation, 15 February 2005,
      http://www.w3.org/TR/2005/REC-charmod-20050215/ . 
		<a href="www.w3.org/TR/charmod/" title="Latest version of Character Model for the World Wide Web 1.0: Fundamentals">Latest version</a> available at http://www.w3.org/TR/charmod/
      .</dd>
		<dt><a name="CONCEPTS" id="CONCEPTS">[CONCEPTS]</a></dt>
		<dd>
<cite>
		<a href="www.w3.org/TR/2004/REC-rdf-concepts-20040210/">Resource
      Description Framework (RDF): Concepts and Abstract
      Syntax</a></cite>, G. Klyne, J. J. Carroll, Editors, W3C
      Recommendation, 10 February 2004,
      http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/ .
      	<a href="www.w3.org/TR/rdf-concepts/" title="Latest version of Resource Description Framework (RDF): Concepts and Abstract Syntax">Latest version</a> available at
      http://www.w3.org/TR/rdf-concepts/ .</dd>
		<dt><a name="FUNCOP" id="FUNCOP">[FUNCOP]</a></dt>
		<dd>
<cite>
		<a href="www.w3.org/TR/2007/REC-xpath-functions-20070123/">XQuery
      1.0 and XPath 2.0 Functions and Operators</a></cite>, J.
      Melton, A. Malhotra, N. Walsh, Editors, W3C Recommendation,
      23 January 2007,
      http://www.w3.org/TR/2007/REC-xpath-functions-20070123/ .
      	<a href="www.w3.org/TR/xpath-functions/" title="Latest version of XQuery 1.0 and XPath 2.0 Functions and Operators">Latest version</a> available at
      http://www.w3.org/TR/xpath-functions/ .</dd>
		<dt><a id="RDF-MT" name="RDF-MT">[RDF-MT]</a></dt>
		<dd>
<cite>
		<a href="www.w3.org/TR/2004/REC-rdf-mt-20040210/">RDF
      Semantics</a></cite>, P. Hayes, Editor, W3C Recommendation,
      10 February 2004,
      http://www.w3.org/TR/2004/REC-rdf-mt-20040210/ . 
		<a title="Latest version of RDF Semantics" href="www.w3.org/TR/rdf-mt/">Latest version</a> available
      at http://www.w3.org/TR/rdf-mt/ .</dd>
		<dt><a name="rfc3629" id="rfc3629">[RFC3629]</a></dt>
		<dd>RFC 3629 <cite>
		<a href="www.ietf.org/rfc/rfc3629.txt">UTF-8, a transformation
      format of ISO 10646</a></cite>, F. Yergeau November 2003</dd>

	<dt><a name="rfc4647" id="rfc4647">[RFC4647]</a></dt>	<dd>RFC 4647 <cite><a href="www.ietf.org/rfc/rfc4647.txt">Matching of Language Tags</a></cite>, A. Phillips, M. Davis September 2006</dd>

		<dt><a name="rfc3986" id="rfc3986">[RFC3986]</a></dt>
		<dd>RFC 3986 <cite>		<a href="www.ietf.org/rfc/rfc3986.txt">Uniform Resource
      Identifier (URI): Generic Syntax</a></cite>, T. Berners-Lee,
      R. Fielding, L. Masinter January 2005</dd>		<dt><a name="rfc3987" id="rfc3987">[RFC3987]</a></dt>
		<dd>
<a href="www.ietf.org/rfc/rfc3987.txt">RFC
      3987</a>, "Internationalized Resource Identifiers (IRIs)", M.
      D&uuml;rst , M. Suignard</dd>
		<dt><a name="UNICODE" id="UNICODE">[UNICODE]</a></dt>
		<dd>
<cite>The Unicode Standard, Version 4</cite>. ISBN
      0-321-18578-1, as updated from time to time by the
      publication of new versions. The latest version of Unicode
      and additional information on versions of the standard and of
      the Unicode Character Database is available at 
		<a href="www.unicode.org/unicode/standard/versions/">http://www.unicode.org/unicode/standard/versions/</a>.</dd>
		<dt><a name="XML11" id="XML11">[XML11]</a></dt>
		<dd>
<cite>
		<a href="www.w3.org/TR/2004/REC-xml11-20040204/">Extensible
      Markup Language (XML) 1.1</a></cite>, J. Cowan, J. Paoli, E.
      Maler, C. M. Sperberg-McQueen, F. Yergeau, T. Bray, Editors,
      W3C Recommendation, 4 February 2004,
      http://www.w3.org/TR/2004/REC-xml11-20040204/ . 
		<a href="www.w3.org/TR/xml11/" title="Latest version of Extensible Markup Language (XML) 1.1">Latest
      version</a> available at http://www.w3.org/TR/xml11/ .</dd>
		<dt><a name="XPATH20" id="XPATH20">[XPATH20]</a></dt>
		<dd>
<cite>
		<a href="www.w3.org/TR/2007/REC-xpath20-20070123/">XML Path
      Language (XPath) 2.0</a></cite>, A. Berglund, S. Boag, D. Chamberlin, M. F. Fernandez, M. Kay, J. Robie, J. Simeon,
      Editors, W3C Recommendation, 23 January 2007,
      http://www.w3.org/TR/2007/REC-xpath20-20070123/ . 
		<a href="www.w3.org/TR/xpath20/" title="Latest version of XML Path Language (XPath) 2.0">Latest
      version</a> available at http://www.w3.org/TR/xpath20/ .</dd>
		<dt><a name="XQUERY" id="XQUERY">[XQUERY]</a></dt>
		<dd>
<cite>
		<a href="www.w3.org/TR/2007/REC-xquery-20070123/">XQuery 1.0:
      An XML Query Language</a></cite>, S. Boag, D. Chamberlin, M. F. Fernandez, D. Florescu, J. Robie, J. Simeon, Editors, W3C Recommendation, 23
      January 2007, http://www.w3.org/TR/2007/REC-xquery-20070123/.
      	<a href="www.w3.org/TR/xquery/" title="Latest version of XQuery 1.0: An XML Query Language">Latest
      version</a> available at http://www.w3.org/TR/xquery/ . 
      <!-- odd... bib generator knows it as http://www.w3.org/TR/xquery
      but the title page says http://www.w3.org/TR/xquery/ -->
</dd>
		<dt><a name="XSDT" id="XSDT">[XSDT]</a></dt>
		<dd>
<cite>		<a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/">XML
      Schema Part 2: Datatypes Second Edition</a></cite>, P. V.
      Biron, A. Malhotra, Editors, W3C Recommendation, 28 October
      2004, http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/ .
      	<a href="www.w3.org/TR/xmlschema-2/" title="Latest version of XML Schema Part 2: Datatypes Second Edition">Latest version</a> available at
      http://www.w3.org/TR/xmlschema-2/ .</dd>
	<dt><a name="BCP47" id="BCP47">[BCP47]</a></dt>
	<dd>
<cite><a href="www.rfc-editor.org/rfc/bcp/bcp47.txt">Best Common Practice 47</a></cite>, P. V. Biron, A. Malhotra, Editors, W3C Recommendation, 28 October 2004, http://www.rfc-editor.org/rfc/bcp/bcp47.txt .</dd>
	</dl>
	<h3 id="informativeRefs">参考情報の参考文献</h3>
	<dl class="bib">
		<dt><a name="CBD" id="CBD">[CBD]</a></dt>
		<dd>
<cite><a href="www.w3.org/Submission/CBD/">CBD - Concise 
        Bounded Description</a></cite>, Patrick Stickler, Nokia, W3C Member 
        Submission, 3 June 2005.</dd>
		<dt><a name="DC" id="DC">[DC]</a></dt>		<dd>
<cite>		<a href="www.dublincore.org/documents/dcmes-xml/">Expressing
      Simple Dublin Core in RDF/XML</a></cite>
		<a href="dublincore.org/">Dublin Core Dublin Core Metadata
      Initiative</a> Recommendation 2002-07-31.</dd>
<!--
    <dt><a name="namespace" id="namespace">[NAMESPACE]</a></dt>
    <dd>
      <cite><a
      href="http://www.w3.org/TR/2004/REC-xml-names11-20040204">Namespaces
      in XML 1.1</a> </cite>, T. Bray, A. Layman, D. Hollander,
      R. Tobin, Editors, W3C Recommendation, 4 February 2004,
      http://www.w3.org/TR/2004/REC-xml-names11-20040204 . <a
      href="http://www.w3.org/TR/xml-names11" title="Latest version
      of Namespaces in XML 1.1">Latest version</a> available at
      http://www.w3.org/TR/xml-names11/ .
    </dd>
-->
        <dt><a id="multiset" name="multiset">[Multiset]</a></dt>
        <dd>
<cite>
            <a href="en.wikipedia.org/w/index.php?title=Multiset&amp;oldid=163605900">Multiset</a></cite>, Wikipedia, The Free Encyclopedia.
            Article as given on October 25, 2007 at http://en.wikipedia.org/w/index.php?title=Multiset&amp;oldid=163605900. The 
            <a href="en.wikipedia.org/wiki/Multiset">latest version</a> of this article is at http://en.wikipedia.org/wiki/Multiset.
            </dd>
      	<dt><a id="OWL_Semantics" name="OWL_Semantics">[OWL-Semantics]</a></dt>
		<dd>
<cite>		<a href="www.w3.org/TR/2004/REC-owl-semantics-20040210/">OWL
      Web Ontology Language Semantics and Abstract
      Syntax</a></cite>, Peter F. Patel-Schneider, Patrick Hayes,
      Ian Horrocks, Editors, W3C Recommendation
      http://www.w3.org/TR/2004/REC-owl-semantics-20040210/.
      	<a href="www.w3.org/TR/owl-semantics/">Latest
      version</a> at <a href="www.w3.org/TR/owl-semantics/">http://www.w3.org/TR/owl-semantics/</a>.</dd>


	<dt><a id="rdfschema" name="rdfschema">[RDFS]</a></dt>
	<dd>
	  <cite><a href="www.w3.org/TR/2004/REC-rdf-schema-20040210/">RDF Vocabulary Description Language 1.0: RDF Schema</a></cite>,
	  Dan Brickley, R.V. Guha, Editors,
	  W3C Recommendation,
	  10 February 2004,
	  http://www.w3.org/TR/2004/REC-rdf-schema-20040210/ .
	  <a href="www.w3.org/TR/rdf-schema/">Latest version</a> at <a href="www.w3.org/TR/rdf-schema/">http://www.w3.org/TR/rdf-schema/</a> .
	</dd>
		<dt><a name="RESULTS" id="RESULTS">[RESULTS]</a></dt>
		<dd>
<cite>		<a href="www.w3.org/TR/2008/REC-rdf-sparql-XMLres-20080115/">SPARQL
      Query Results XML Format</a></cite>, D. Beckett, Editor, W3C      Recommendation, 15 January 2008,
      http://www.w3.org/TR/2008/REC-rdf-sparql-XMLres-20080115/ .
      	<a href="www.w3.org/TR/rdf-sparql-XMLres/" title="Latest version of SPARQL Query Results XML Format">Latest
      version</a> available at 
		<a href="www.w3.org/TR/rdf-sparql-XMLres/">http://www.w3.org/TR/rdf-sparql-XMLres/</a>
      .</dd>
		<dt><a id="SPROT" name="SPROT">[SPROT]</a></dt>
		<dd>
<cite>
		<a href="www.w3.org/TR/2008/REC-rdf-sparql-protocol-20080115/">SPARQL
      Protocol for RDF</a></cite>, K. Clark, Editor, W3C Recommendation,
      15 January 2008,
      http://www.w3.org/TR/2008/REC-rdf-sparql-protocol-20080115/ .
      	<a title="Latest version of SPARQL Protocol for RDF" href="www.w3.org/TR/rdf-sparql-protocol/">Latest
      version</a> available at
      http://www.w3.org/TR/rdf-sparql-protocol/ .</dd>
		<dt><a name="TURTLE" id="TURTLE">[TURTLE]</a></dt>
		<dd>
<a href="www.w3.org/TeamSubmission/turtle/">Turtle - Terse
      RDF Triple Language</a>, Dave Beckett.</dd>
		<dt><a name="UCNR" id="UCNR">[UCNR]</a></dt>
		<dd>
<cite>
		<a href="www.w3.org/TR/2005/WD-rdf-dawg-uc-20050325/">RDF Data
      Access Use Cases and Requirements</a></cite>, K. Clark,
      Editor, W3C Working Draft, 25 March 2005,
      http://www.w3.org/TR/2005/WD-rdf-dawg-uc-20050325/ . 
		<a href="www.w3.org/TR/rdf-dawg-uc/" title="Latest version of RDF Data Access Use Cases and Requirements">Latest version</a> available at
      http://www.w3.org/TR/rdf-dawg-uc/ .</dd>
		<dt><a name="UNISEC" id="UNISEC">[UNISEC]</a></dt>
		<dd>
<cite><a href="www.unicode.org/reports/tr36/">Unicode Security
      Considerations</a></cite>, Mark Davis, Michel Suignard</dd>

	<dt><a id="VCARD" name="VCARD">[VCARD]</a></dt>
	<dd>
	  <cite><a href="www.w3.org/TR/2001/NOTE-vcard-rdf-20010222/">Representing vCard Objects in RDF/XML</a></cite>,
	  Renato Iannella,
	  W3C Note,
	  22 February 2001,
	  http://www.w3.org/TR/2001/NOTE-vcard-rdf-20010222/ .
	  <a href="www.w3.org/TR/vcard-rdf">Latest version</a> is available at <tt>http://www.w3.org/TR/vcard-rdf</tt> .
	</dd>

	<dt><a name="WEBARCH" id="WEBARCH">[WEBARCH]</a></dt>
	<dd>
	  <cite><a href="www.w3.org/TR/2004/REC-webarch-20041215/">Architecture of the World Wide Web, Volume One</a></cite>, 
	  I. Jacobs, N. Walsh, Editors,
	  W3C Recommendation,
	  15 December 2004,
	  http://www.w3.org/TR/2004/REC-webarch-20041215/ .
	  <a href="www.w3.org/TR/webarch/">Latest version</a> is available at <tt>http://www.w3.org/TR/webarch/</tt> .
	</dd>

		<dt><a name="UNIID" id="UNIID">[UNIID]</a></dt>
		<dd>
<cite>
		<a href="www.unicode.org/reports/tr31/tr31-5.html">Identifier
      and Pattern Syntax 4.1.0</a></cite>, Mark Davis, Unicode
      Standard Annex #31, 25 March 2005,
      http://www.unicode.org/reports/tr31/tr31-5.html . 
		<a href="www.unicode.org/reports/tr31/" title="Latest version of Identifier and Pattern Syntax">Latest
      version</a> available at <a href="www.unicode.org/reports/tr31/">http://www.unicode.org/reports/tr31/</a>
      .</dd>
      <dt>[<a name="refSemantics1" id="refSemantics1">SPARQL-sem-05</a>]</dt>
      <dd>
<cite><a href="www.hpl.hp.com/techreports/2005/HPL-2005-170.html">A relational
      algebra for SPARQL</a></cite>, Richard Cyganiak, 2005</dd>
      <dt>[<a name="refSemantics3" id="refSemantics2">SPARQL-sem-06</a>]</dt>
      <dd>
<cite><a href="arxiv.org/abs/cs/0605124">Semantics of SPARQL</a></cite>, Jorge P&eacute;rez, Marcelo Arenas, and Claudio Gutierrez, 
      2006</dd>
</dl>
</div>

<h2>F. <a name="acknowledgements" id="acknowledgements">謝辞</a>（参考情報）</h2>

<p>SPARQL RDFクエリ言語は、<a href="www.w3.org/2001/sw/DataAccess/">W3C RDFデータ・アクセス・ワーキンググループ</a>全体の成果であり、議論、コメントおよびレビューに対し、すべての<a href="www.w3.org/2001/sw/DataAccess/#who">現在および過去のメンバー</a>に感謝します。</p>

<p>さらに、我々は、ワーキンググループのコメント・リストを通じて、多くの人々とコメントや議論のやり取りを行いました。すべてのコメントがより良いドキュメントの作成に繋がりました。Andyはまた、SPARQLに関連する特定課題の調査に対し、特にJorge Pe&eacute;rez、Geoff Chappell、Bob MacGregor、Yosi Scharf、およびRichard Newmanに感謝しています。Ericは、Bj&ouml;rn H&ouml;hrmannの貴重な援助に対し謝辞を表します。</p>

<div class="changes">
	<h2><a name="chlog" id="chlog">変更履歴</a></h2>

    <p>これは、<a href="www.w3.org/TR/2007/PR-rdf-sparql-query-20071112/">2007年6月14日 勧告候補</a>の発表以降のこのドキュメントに行われた変更の高レベルな概要です。</p>

    <ul>
	<li>§9<a href="#solutionModifiers">ソリューション・シーケンスと修飾子</a>では、ソリューション集合（<tt>solution set</tt>）という用語はソリューション・シーケンス（<tt>solution sequence</tt>）に変更されました。</li>
	<li>メディア・タイプ<code>application/sparql-query</code>が承認されたため、その要求のステータスに関する文章を削除しました。</li>
    </ul>
</div>

<div class="nav">
<a href="validator.w3.org/check/referer">
	<img src="www.w3.org/Icons/valid-xhtml10" alt="Valid XHTML 1.0!" height="31" width="88"></a>
</div>
<hr>

</body>

</html>