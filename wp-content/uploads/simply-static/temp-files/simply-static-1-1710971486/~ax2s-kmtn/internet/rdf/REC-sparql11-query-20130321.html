<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>SPARQL 1.1クエリ言語</title>
<style type="text/css">code           { font-family: monospace; }

div.constraint,
div.issue,
div.note,
div.notice     { margin-left: 2em; }

ol.enumar      { list-style-type: decimal; }
ol.enumla      { list-style-type: lower-alpha; }
ol.enumlr      { list-style-type: lower-roman; }
ol.enumua      { list-style-type: upper-alpha; }
ol.enumur      { list-style-type: upper-roman; }


div.exampleInner pre { margin-left: 1em;
                       margin-top: 0em; margin-bottom: 0em}
div.exampleOuter {border: 4px double gray;
                  margin: 0em; padding: 0em}
div.exampleInner { background-color: #d5dee3;
                   border-top-width: 4px;
                   border-top-style: double;
                   border-top-color: #d3d3d3;
                   border-bottom-width: 4px;
                   border-bottom-style: double;
                   border-bottom-color: #d3d3d3;
                   padding: 4px; margin: 0em }
div.exampleWrapper { margin: 4px }
div.exampleHeader { font-weight: bold;
                    margin: 4px}

em.rfc2119 { text-transform: lowercase;
             font-variant: small-caps;
             font-style: normal; }</style>

<link rel="stylesheet" type="text/css" href="www.w3.org/TR/2013/REC-sparql11-query-20130321/local.css">
<link rel="stylesheet" type="text/css" href="www.w3.org/StyleSheets/TR/W3C-REC.css">
</head>

<body>

<p><a href="www.asahi-net.or.jp/~ax2s-kmtn/index.html"><img src="www.asahi-net.or.jp/~ax2s-kmtn/images/logo.gif" alt="CyberLibrarian" width="105" height="19"></a></p>

<p>【注意】 このドキュメントは、W3Cの<a href="www.w3.org/TR/2013/REC-sparql11-query-20130321/">SPARQL 1.1 Query Language W3C Recommendation 21 March 2013</a>の和訳です。<br>
このドキュメントの正式版はW3Cのサイト上にある英語版であり、このドキュメントには翻訳に起因する誤りがありえます。誤訳、誤植などのご指摘は、<a href="www.asahi-net.or.jp/~ax2s-kmtn/mail.html">訳者</a>までお願い致します。</p>

<p>First Update: 2013年7月21日</p>

<hr>

<div class="head">

<p><a href="www.w3.org/"><img src="www.w3.org/Icons/w3c_home" alt="W3C" height="48" width="72"></a></p>

<h1>
<a name="title" id="title"></a>SPARQL 1.1クエリ言語</h1>

<h2>
<a name="w3c-doctype" id="w3c-doctype"></a>W3C勧告 2013年3月21日</h2>

<dl>
  <dt>本バージョン:</dt>
  <dd><a href="www.w3.org/TR/2013/REC-sparql11-query-20130321/">http://www.w3.org/TR/2013/REC-sparql11-query-20130321/</a></dd>
  <dt>最新バージョン:</dt>
  <dd><a href="www.w3.org/TR/sparql11-query/">http://www.w3.org/TR/sparql11-query/</a></dd>
  <dt>旧バージョン:</dt>
  <dd><a href="www.w3.org/TR/2012/PR-sparql11-query-20121108/">http://www.w3.org/TR/2012/PR-sparql11-query-20121108/</a></dd>
  <dt>編集者:</dt>
  <dd>Steve Harris, Garlik, a part of Experian</dd>
  <dd>Andy Seaborne, The Apache Software Foundation</dd>
  <dt>旧編集者:</dt>
  <dd>Eric Prud'hommeaux, W3C</dd>
</dl>

<p>このドキュメントに対する<a href="www.w3.org/2013/sparql-errata#sparql11-query"><strong>正誤表</strong></a>を参照してください。いくつかの規範的な修正が含まれているかもしれません。</p>

<p><a href="www.w3.org/2003/03/Translations/byTechnology?technology=sparql11-query"><strong>翻訳版</strong></a>も参照してください。</p>

<p class="copyright"><a href="www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> &#xa9; 2013 <a href="www.w3.org/"><acronym title="World Wide Web Consortium">W3C</acronym></a><sup>&#xae;</sup> (<a href="www.csail.mit.edu/"><acronym title="Massachusetts Institute of Technology">MIT</acronym></a>, <a href="www.ercim.eu/"><acronym title="European Research Consortium for Informatics and Mathematics">ERCIM</acronym></a>, <a href="www.keio.ac.jp/">Keio</a>, <a href="ev.buaa.edu.cn/">Beihang</a>), All Rights Reserved. W3C <a href="www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p>

</div>

<hr>

<div>

<h2>
<a name="abstract" id="abstract"></a>要約</h2>

<p>RDFは、ウェブ上で情報を表すための、有向性の、ラベル付けされたグラフ・データ形式です。この仕様では、RDFに対するSPARQLクエリ言語の構文とセマンティクスを定義しています。SPARQLは、データがRDFそのものとして保存されているか、ミドルウェアを通してRDFとして見えるのかにかかわらず、さまざまなデータ情報源にまたがるクエリを表すために使用できます。SPARQLには、必須および任意のグラフ・パターンをその論理積と論理和とともに問い合わせる性能が含まれています。SPARQLは、ソースRDFグラフによる集約、サブクエリ、否定、式による値の作成、拡張可能な値テストやクエリの制約もサポートします。SPARQLクエリの結果は、結果集合またはRDFグラフでありえます。</p>

</div>
<div>

<h2>
<a name="status" id="status"></a>このドキュメントのステータス</h2>

<h4 id="may-be">置き換えられる可能性</h4>

<p><em>この項は、このドキュメントの公開時のステータスについて記述しています。他のドキュメントがこのドキュメントに取って代わることがありえます。現行のW3Cの刊行物およびこの技術報告の最新の改訂版のリストは、http://www.w3.org/TR/の<a href="www.w3.org/TR/">W3C技術報告インデックス</a>にあります。</em></p>

<h4 id="related">一連のドキュメント</h4>

<p>このドキュメントは、<a href="www.w3.org/2001/sw/DataAccess/">SPARQLワーキンググループ</a>が作成した以下の11のSPARQL 1.1勧告のうちの1つです。</p>

<ol>
  <li><a href="www.w3.org/TR/2013/REC-sparql11-overview-20130321">SPARQL 1.1概要</a></li>
  <li>
<a href="www.w3.org/TR/2013/REC-sparql11-query-20130321">SPARQL 1.1クエリ言語</a>（このドキュメント）</li>
  <li><a href="www.w3.org/TR/2013/REC-sparql11-update-20130321">SPARQL 1.1更新</a></li>
  <li><a href="www.w3.org/TR/2013/REC-sparql11-service-description-20130321">SPARQL 1.1サービス記述</a></li>
  <li><a href="www.w3.org/TR/2013/REC-sparql11-federated-query-20130321">SPARQL 1.1統合クエリ</a></li>
  <li><a href="www.w3.org/TR/2013/REC-sparql11-results-json-20130321">SPARQL 1.1クエリ結果JSONフォーマット</a></li>
  <li><a href="www.w3.org/TR/2013/REC-sparql11-results-csv-tsv-20130321">SPARQL 1.1クエリ結果CSVおよびTSVフォーマット</a></li>
  <li><a href="www.w3.org/TR/2013/REC-rdf-sparql-XMLres-20130321">SPARQLクエリ結果XMLフォーマット（第2版）</a></li>
  <li><a href="www.w3.org/TR/2013/REC-sparql11-entailment-20130321">SPARQL 1.1含意レジーム</a></li>
  <li><a href="www.w3.org/TR/2013/REC-sparql11-protocol-20130321">SPARQL 1.1プロトコル</a></li>
  <li><a href="www.w3.org/TR/2013/REC-sparql11-http-rdf-update-20130321">SPARQL 1.1グラフ・ストアHTTPプロトコル</a></li>
</ol>

<h4 class="no-toc no-num" id="status-changes">本質的な変更なし</h4>

<p><a href="www.w3.org/TR/2012/PR-sparql11-query-20121108/">旧バージョン</a>以降、このドキュメントには実質的な変更はありませんでした。マイナーな編集上の変更がある場合には、<a href="#changes-since-pr">変更履歴</a>に詳細が記述されており、<a href="www.asahi-net.or.jp/~ax2s-kmtn/internet/rdf/diff">色分けした差分</a>として見ることができます。</p>

<h4 class="no-toc no-num" id="please">コメントの送信</h4>

<p><a class="mailto" href="mailto:public-rdf-dawg-comments@w3.org">public-rdf-dawg-comments@w3.org</a>（<a class="http" href="lists.w3.org/Archives/Public/public-rdf-dawg-comments/">公開アーカイブ</a>）にコメントをお送りください。このドキュメントに対する<a href="www.w3.org/2009/sparql/">SPARQLワーキンググループ</a>の作業は完了していますが、コメントは<a href="www.w3.org/2013/sparql-errata">正誤表</a>や今後の改定で扱われることがあります。公開討論は、<a class="mailto" href="mailto:public-sparql-dev@w3.org">public-sparql-dev@w3.org</a>（<a class="http" href="lists.w3.org/Archives/Public/public-sparql-dev/">公開アーカイブ</a>）で歓迎します。</p>

<h4 class="no-toc no-num" id="endorsement">W3Cによる承認</h4>

<p><em>このドキュメントは、W3Cメンバー、ソフトウェア開発者、他のW3Cグループ、および他の利害関係者によりレビューされ、W3C勧告として管理者の協賛を得ました。これは確定済みドキュメントであり、参考資料として用いたり、別のドキュメントで引用することができます。勧告の作成におけるW3Cの役割は、仕様に注意を引き付け、広範囲な開発を促進することです。これによってウェブの機能性および相互運用性が増強されます。</em></p>

<h4 id="patents">特許</h4>

<p><em>このドキュメントは、<a href="www.w3.org/Consortium/Patent-Policy-20040205/">2004年2月5日のW3C特許方針</a>の下で活動しているグループによって作成されました。W3Cは、このグループの成果物に関連する<a href="www.w3.org/2004/01/pp-impl/35463/status" rel="disclosure">あらゆる特許の開示の公開リスト</a>を維持し、このページには特許の開示に関する指示も含まれています。<a href="www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">不可欠な請求権</a>（Essential Claim(s)）を含んでいると思われる特許に関して実際に知っている人は、<a href="www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">W3C特許方針の6項</a>に従って情報を開示しなければなりません。</em></p>

</div>
<div class="toc">

<h2>
<a name="contents" id="contents"></a>目次</h2>

<p class="toc">1 <b><a href="#introduction">はじめに</a></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;1.1 <a href="#docOutline">ドキュメントの概要</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;1.2 <a href="#docConventions">キュメントの慣習</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2.1 <a href="#docNamespaces">名前空間</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2.2 <a href="#docDataDesc">データの記述</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2.3 <a href="#docResultDesc">結果の記述</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.2.4 <a href="#docTerminology">用語</a><br>
2 <b><a href="#basicpatterns">シンプルなクエリの作成（参考情報）</a></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;2.1 <a href="#WritingSimpleQueries">シンプルなクエリの記述</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;2.2 <a href="#MultipleMatches">複数マッチ</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;2.3 <a href="#matchingRDFLiterals">RDFリテラルのマッチング</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.1 <a href="#matchLangTags">リテラルと言語タグとのマッチング</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.2 <a href="#matchNumber">リテラルと数値型とのマッチング</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.3.3 <a href="#matchArbDT">リテラルと任意のデータ型とのマッチング</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;2.4 <a href="#BlankNodesInResults">クエリ結果の空白ノード・ラベル</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;2.5 <a href="#CreatingValuesWithExpressions">式による値の作成</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;2.6 <a href="#constructGraph">RDFグラフの構築</a><br>
3 <b><a href="#termConstraint">RDF用語制約（参考情報）</a></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.1 <a href="#restrictString">文字列の値の制限</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.2 <a href="#restrictNumber">数値の制限</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;3.3 <a href="#otherTermConstraints">その他の用語制約</a><br>
4 <b><a href="#sparqlSyntax">SPARQL構文</a></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;4.1 <a href="#syntaxTerms">RDF用語構文</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.1.1 <a href="#QSynIRI">IRIの構文</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.1.1.1 <a href="#prefNames">接頭辞名</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.1.1.2 <a href="#relIRIs">相対IRI</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.1.2 <a href="#QSynLiterals">リテラルの構文</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.1.3 <a href="#QSynVariables">クエリ変数の構文</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.1.4 <a href="#QSynBlankNodes">空白ノードの構文</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;4.2 <a href="#QSynTriples">トリプル・パターンの構文</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.2.1 <a href="#predObjLists">述語-目的語のリスト</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.2.2 <a href="#objLists">目的語のリスト</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.2.3 <a href="#collections">RDFコレクション</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.2.4 <a href="#abbrevRdfType">rdf:type</a><br>
5 <b><a href="#GraphPattern">グラフ・パターン</a></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;5.1 <a href="#BasicGraphPatterns">基本グラフ・パターン</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.1.1 <a href="#bgpBNodeLabels">空白ノード・ラベル</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.1.2 <a href="#bgpExtend">基本グラフ・パターン・マッチングの拡張</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;5.2 <a href="#GroupPatterns">グループ・グラフ・パターン</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.1 <a href="#emptyGroupPattern">空のグループ・パターン</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.2 <a href="#scopeFilters">フィルタの範囲</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.2.3 <a href="#groupExamples">グループ・グラフ・パターンの例</a><br>
6 <b><a href="#optionals">オプション値の組み込み</a></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;6.1 <a href="#OptionalMatching">オプションのパターン・マッチング</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;6.2 <a href="#OptionalAndConstraints">オプションのパターン・マッチングにおける制約</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;6.3 <a href="#MultipleOptionals">複数のオプションのグラフ・パターン</a><br>
7 <b><a href="#alternatives">代替のマッチング</a></b><br>
8 <b><a href="#negation">否定</a></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;8.1 <a href="#neg-pattern">グラフ・パターンを用いたフィルタリング</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.1.1 <a href="#neg-notexists">パターンの不在に関するテスト</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.1.2 <a href="#neg-exists">パターンの存在に関するテスト</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;8.2 <a href="#neg-minus">ソリューションの除外</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;8.3 <a href="#neg-notexists-minus">NOT EXISTSとMINUSの関係と違い</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.3.1 <a href="#neg-example-1">例: 変数の共有</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.3.2 <a href="#neg-example-2">例: 固定パターン</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8.3.3 <a href="#idp899488">例: 内部FILTER</a><br>
9 <b><a href="#propertypaths">プロパティー・パス</a></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;9.1 <a href="#pp-language">プロパティー・パス構文</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;9.2 <a href="#propertypath-examples">例</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;9.3 <a href="#propertypath-syntaxforms">プロパティー・パスと同等パターン</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;9.4 <a href="#propertypath-arbitrary-length">任意の長さのパス・マッチング</a><br>
10 <b><a href="#assignment">割り当て</a></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;10.1 <a href="#bind">BIND: 変数への割り当て</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;10.2 <a href="#inline-data">VALUES: インライン・データの提供</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.2.1 <a href="#inline-data-syntax">VALUES構文</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10.2.2 <a href="#inline-data-examples">VALUESの例</a><br>
11 <b><a href="#aggregates">集約</a></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;11.1 <a href="#aggregateExample">集約の例</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;11.2 <a href="#groupby">GROUP BY</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;11.3 <a href="#having">HAVING</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;11.4 <a href="#aggregateRestrictions">集約射影制限</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;11.5 <a href="#aggregateExample2">集約の例（エラーがある場合）</a><br>
12 <b><a href="#subqueries">サブクエリ</a></b><br>
13 <b><a href="#rdfDataset">RDFデータセット</a></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;13.1 <a href="#exampleDatasets">RDFデータセットの例</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;13.2 <a href="#specifyingDataset">RDFデータセットの指定</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13.2.1 <a href="#unnamedGraph">デフォルト・グラフの指定</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13.2.2 <a href="#namedGraphs">名前付きグラフの指定</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13.2.3 <a href="#specDataset">FROMとFROM NAMEDの結合</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;13.3 <a href="#queryDataset">データセットのクエリ実行</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13.3.1 <a href="#accessByLabel">グラフ名へのアクセス</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13.3.2 <a href="#restrictByLabel">グラフIRIによる制限</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13.3.3 <a href="#restrictInQuery">ありうるグラフIRFの制限</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13.3.4 <a href="#namedAndDefaultGraph">名前付きグラフおよびデフォルト・グラフ</a><br>
14 <b><a href="#basic-federated-query">基本的な統合クエリ</a></b><br>
15 <b><a href="#solutionModifiers">ソリューション・シーケンスと修飾子</a></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;15.1 <a href="#modOrderBy">ORDER BY</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;15.2 <a href="#modProjection">射影</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;15.3 <a href="#modDuplicates">ソリューションの複製</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;15.4 <a href="#modOffset">OFFSET</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;15.5 <a href="#modResultLimit">LIMIT</a><br>
16 <b><a href="#QueryForms">クエリ形式</a></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;16.1 <a href="#select">SELECT</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.1.1 <a href="#selectproject">射影</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.1.2 <a href="#selectExpressions">SELECT式</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;16.2 <a href="#construct">CONSTRUCT</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.2.1 <a href="#templatesWithBNodes">空白ノードを持つテンプレート</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.2.2 <a href="#accessingRdfGraphs">RDFデータセットのグラフへのアクセス</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.2.3 <a href="#SolModandCONSTRUCT">ソリューション修飾子とCONSTRUCT</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.2.4 <a href="#constructWhere">CONSTRUCT WHERE</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;16.3 <a href="#ask">ASK</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;16.4 <a href="#describe">DESCRIBE（参考情報）</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.4.1 <a href="#explicitIRIs">明示的なIRI</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.4.2 <a href="#identifyingResources">資源の識別</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.4.3 <a href="#descriptionsOfResources">資源の記述</a><br>
17 <b><a href="#expressions">式と値のテスト</a></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;17.1 <a href="#operandDataTypes">オペランド・データ型</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;17.2 <a href="#evaluation">フィルタ評価</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.2.1 <a href="#invocation">呼び出し</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.2.2 <a href="#ebv">有効なブール値（EBV）</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;17.3 <a href="#OperatorMapping">演算子マッピング</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.3.1 <a href="#operatorExtensibility">演算子の拡張性</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;17.4 <a href="#SparqlOps">関数の定義</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.1 <a href="#func-forms">関数の形式</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.1.1 <a href="#func-bound">バインド</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.1.2 <a href="#func-if">IF</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.1.3 <a href="#func-coalesce">COALESCE</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.1.4 <a href="#func-filter-exists">NOT EXISTSとEXISTS</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.1.5 <a href="#func-logical-or">logical-or</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.1.6 <a href="#func-logical-and">logical-and</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.1.7 <a href="#func-RDFterm-equal">RDFterm-equal</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.1.8 <a href="#func-sameTerm">sameTerm</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.1.9 <a href="#func-in">IN</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.1.10 <a href="#func-not-in">NOT IN</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.2 <a href="#func-rdfTerms">RDF用語の関数</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.2.1 <a href="#func-isIRI">isIRI</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.2.2 <a href="#func-isBlank">isBlank</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.2.3 <a href="#func-isLiteral">isLiteral</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.2.4 <a href="#func-isNumeric">isNumeric</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.2.5 <a href="#func-str">str</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.2.6 <a href="#func-lang">lang</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.2.7 <a href="#func-datatype">datatype</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.2.8 <a href="#func-iri">IRI</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.2.9 <a href="#func-bnode">BNODE</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.2.10 <a href="#func-strdt">STRDT</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.2.11 <a href="#func-strlang">STRLANG</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.2.12 <a href="#func-uuid">UUID</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.2.13 <a href="#func-struuid">STRUUID</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3 <a href="#func-strings">文字列に関する関数</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.1 <a href="#idp1887976">SPARQL関数の文字列 </a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.1.1 <a href="#func-string">文字列の引数</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.1.2 <a href="#func-arg-compatibility">引数の互換性の規則</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.1.3 <a href="#idp1915512">文字列リテラルの返答の型</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.2 <a href="#func-strlen">STRLEN</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.3 <a href="#func-substr">SUBSTR</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.4 <a href="#func-ucase">UCASE</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.5 <a href="#func-lcase">LCASE</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.6 <a href="#func-strstarts">STRSTARTS</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.7 <a href="#func-strends">STRENDS</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.8 <a href="#func-contains">CONTAINS</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.9 <a href="#func-strbefore">STRBEFORE</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.10 <a href="#func-strafter">STRAFTER</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.11 <a href="#func-encode">ENCODE_FOR_URI</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.12 <a href="#func-concat">CONCAT</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.13 <a href="#func-langMatches">langMatches</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.14 <a href="#func-regex">REGEX</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.3.15 <a href="#func-replace">REPLACE</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.4 <a href="#func-numerics">数値の関数</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.4.1 <a href="#func-abs">abs</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.4.2 <a href="#func-round">round</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.4.3 <a href="#func-ceil">ceil</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.4.4 <a href="#func-floor">floor</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.4.5 <a href="#idp2130040">RAND</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.5 <a href="#func-date-time">日時の関数</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.5.1 <a href="#func-now">now</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.5.2 <a href="#func-year">year</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.5.3 <a href="#func-month">month</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.5.4 <a href="#func-day">day</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.5.5 <a href="#func-hours">hours</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.5.6 <a href="#func-minutes">minutes</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.5.7 <a href="#func-seconds">seconds</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.5.8 <a href="#func-timezone">timezone</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.5.9 <a href="#func-tz">tz</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.6 <a href="#func-hash">ハッシュ関数</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.6.1 <a href="#func-md5">MD5</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.6.2 <a href="#func-sha1">SHA1</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.6.3 <a href="#func-sha256">SHA256</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.6.4 <a href="#func-sha384">SHA384</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;17.4.6.5 <a href="#func-sha512">SHA512</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;17.5 <a href="#FunctionMapping">XPathコンストラクタ関数</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;17.6 <a href="#extensionFunctions">拡張可能な値テスト</a><br>
18 <b><a href="#sparqlDefinition">SPARQLの定義</a></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;18.1 <a href="#initDefinitions">初期定義</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.1.1 <a href="#sparqlBasicTerms">RDF用語</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.1.2 <a href="#simple_literal">Simple Literal</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.1.3 <a href="#sparqlDataset">RDFデータセット</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.1.4 <a href="#sparqlQueryVariables">クエリ変数</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.1.5 <a href="#sparqlTriplePatterns">トリプル・パターン</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.1.6 <a href="#sparqlBasicGraphPatterns">基本グラフ・パターン</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.1.7 <a href="#sparqlPropertyPaths">プロパティー・パス・パターン</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.1.8 <a href="#sparqlSolutions">ソリューション・マッピング</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.1.9 <a href="#sparqlSolMod">ソリューション・シーケンス修飾子</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.1.10 <a href="#idp2427544">SPARQLクエリ</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;18.2 <a href="#sparqlQuery">SPARQL代数への置換</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.1 <a href="#variableScope">変数の範囲</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.2 <a href="#convertGraphPattern">グラフ・パターンの変換</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.2.1 <a href="#sparqlExpandForms">構文形式の展開</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.2.2 <a href="#sparqlCollectFilters">FILTER要素の集約</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.2.3 <a href="#sparqlTranslatePathExpressions">プロパティー・パス式の置換</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.2.4 <a href="#sparqlTranslatePathPatterns">プロパティー・パス・パターンの置換</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.2.5 <a href="#sparqlTranslateBasicGraphPatterns">基本グラフ・パターンの置換</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.2.6 <a href="#sparqlTranslateGraphPatterns">グラフ・パターンの置換</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.2.7 <a href="#sparqlAddFilters">グループのフィルタ</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.2.8 <a href="#sparqlSimplification">単純化のステップ</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.3 <a href="#sparqlAlgebraExamples">マッピングされたグラフ・パターンの例</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.4 <a href="#convertGroupAggSelectExpressions">グループ、集約、HAVING、最後のVALUES句、SELECT式の変換</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.4.1 <a href="#sparqlGroupAggregate">グルーピングと集約</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.4.2 <a href="#sparqlHavingClause">HAVING</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.4.3 <a href="#sparqlAlgebraFinalValues">VALUES</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.4.4 <a href="#sparqlSelectExpressions">SELECT式</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.5 <a href="#convertSolMod">ソリューション修飾子の変換</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.5.1 <a href="#sparqlOrderBy">ORDER BY</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.5.2 <a href="#sparqlProjection">射影</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.5.3 <a href="#sparqlDistinct">DISTINCT</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.5.4 <a href="#sparqlReduced">REDUCED</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.5.5 <a href="#sparqlOffsetLimit">OFFSETとLIMIT</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.2.5.6 <a href="#sparqlAlgebraOutcome">最後の代数式</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;18.3 <a href="#BasicGraphPattern">基本グラフ・パターン</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.3.1 <a href="#BGPsparql">SPARQLの基本グラフ・パターン・マッチング</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.3.2 <a href="#BGPsparqlBNodes">空白ノードの処理</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;18.4 <a href="#PropertyPathPatterns">プロパティー・パス・パターン</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;18.5 <a href="#sparqlAlgebra">SPARQL代数</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.5.1 <a href="#aggregateAlgebra">集約代数</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.5.1.1 <a href="#setFunctions">集合関数</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.5.1.2 <a href="#defn_aggCount">Count</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.5.1.3 <a href="#defn_aggSum">Sum</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.5.1.4 <a href="#defn_aggAvg">Avg</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.5.1.5 <a href="#defn_aggMin">Min</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.5.1.6 <a href="#defn_aggMax">Max</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.5.1.7 <a href="#defn_aggGroupConcat">GroupConcat</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.5.1.8 <a href="#defn_aggSample">Sample</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;18.6 <a href="#sparqlAlgebraEval">評価セマンティクス</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;18.7 <a href="#sparqlBGPExtend">SPARQL基本グラフ・マッチングの拡張</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18.7.1 <a href="#sparqlBGPExtend-notes">注意</a><br>
19 <b><a href="#grammar">SPARQL文法</a></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;19.1 <a href="#queryString">SPARQLリクエスト文字列</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;19.2 <a href="#codepointEscape">コードポイント・エスケープ・シーケンス</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;19.3 <a href="#whitespace">空白</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;19.4 <a href="#grammarComments">コメント</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;19.5 <a href="#iriRefs">IRI参照</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;19.6 <a href="#grammarBNodes">空白ノードと空白ノード・ラベル</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;19.7 <a href="#grammarEscapes">文字列中のエスケープ・シーケンス</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;19.8 <a href="#sparqlGrammar">文法</a><br>
20 <b><a href="#conformance">適合性</a></b><br>
21 <b><a href="#security">セキュリティに関する留意点（参考情報）</a></b><br>
22 <b><a href="#mediaType">インターネット・メディア・タイプ、ファイル拡張子、およびマッキントッシュ・ファイル・タイプ</a></b><br>
</p>

<h3>
<a name="appendices" id="appendices"></a>付録</h3>

<p class="toc">A <b><a href="#sec-bibliography">参考文献</a></b><br>
&nbsp;&nbsp;&nbsp;&nbsp;A.1 <a href="#sec-normative-refs">規範的な参考文献</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;A.2 <a href="#sec-non-normative-refs">その他の参考文献</a><br>
</p>

</div>

<hr>

<div class="body">
<div class="div1">

<h2>
<a name="introduction" id="introduction"></a>1 はじめに</h2>

<p>RDFは、ウェブ上で情報を表すための、有向性の、ラベル付けされたグラフ・データの形式です。RDFは、異なる情報源を統合する手段の提供に加え、とりわけ、個人的な情報、ソーシャル・ネットワーク、デジタル・アーティファクトに関するメタデータを表すためにしばしば使用されます。この仕様では、RDF用クエリ言語SPARQLの構文およびセマンティクスを定義しています。</p>

<p>RDF用クエリ言語SPARQLは、<a href="www.w3.org/TR/rdf-dawg-uc/" class="inform">RDFデータ・アクセス・ユースケースおよび要件</a>[<a href="#UCNR">UCNR</a>]と<a href="www.w3.org/TR/sparql-features/" class="inform">SPARQL新機能と原理</a>[<a href="#UCNR2">UCNR2</a>]でRDFデータ・アクセス・ワーキンググループが指定しているユースケースおよび要件を満たすように設計されています。</p>

<div class="div2">

<h3>
<a name="docOutline" id="docOutline"></a>1.1 ドキュメントの概要</h3>

<p>項の先頭で特に注記がなければ、このドキュメントのすべての項と付録は規範的です。</p>

<p>ドキュメントのこの項（<a href="#introduction">1項</a>）では、SPARQLクエリ言語の仕様を紹介します。この仕様ドキュメントの構成と、仕様で使用されている慣習を示します。</p>

<p>仕様の<a href="#basicpatterns">2項</a>では、一連のクエリとクエリ結果の例により、SPARQLクエリ言語自体を紹介します。<a href="#termConstraint">3項</a>では、クエリの結果に現れるRDF用語において制約を表現するSPARQLの性能を示す例をより多く用いて、SPARQLクエリ言語の紹介を継続して行います。</p>

<p><a href="#sparqlSyntax">4項</a>では、SPARQLクエリ言語の構文の詳細を示します。これは、言語の完全な構文への手引きであり、文法構造がどのようにIRI、空白ノード、リテラル、変数を表すかを定義します。4項では、より冗長な表現に対する糖衣構文として役立ついくつかの文法構造の意味も定義します。</p>

<p><a href="#GraphPattern">5項</a>では、基本グラフ・パターンとグループ・グラフ・パターン、より複雑なSPARQLクエリ・パターンの構成要素を紹介します。6、7、8項では、SPARQLグラフ・パターンをより大きなグラフ・パターンに組み合わせる構成子を提示します。特に、<a href="#optionals">6項</a>では、クエリ・オプションの一部を作成する性能を紹介し、<a href="#alternatives">7項</a>では、代替グラフ・パターンの論理和を表す性能を紹介し、<a href="#negation">8項</a>では、情報の不在に関するテストを行うためのパターンを紹介します。</p>

<p><a href="#propertypaths">9項</a>では、グラフ・パターン・マッチングにプロパティー・パスを追加し、クエリのコンパクトな表現に加え、グラフで任意の長さのパスにマッチングさせる性能を提供します。</p>

<p><a href="#assignment">10項</a>では、SPARQLで可能な割り当ての形式について記述しています。</p>

<p><a href="#aggregates">11項</a>では、結果をグループ化して集約する方法を紹介します。これは、<a href="#subqueries">12項</a>で述べているようなサブクエリとして組み込むことができます。</p>

<p><a href="#rdfDataset">13項</a>は、クエリの一部を特定のソース・グラフに制約する性能を紹介します。13項では、クエリに対してソース・グラフを定義するSPARQLの仕組みも提示します。</p>

<p><a href="#basic-federated-query">14項</a>は、<a href="www.w3.org/TR/sparql11-federated-query/">SPARQL 1.1統合クエリ</a>という別のドキュメントを参照します。</p>

<p><a href="#solutionModifiers">15項</a>は、順序付け、スライス、プロジェクション、制限、ソリューションのシーケンスからの重複の排除によるクエリのソリューションに影響する構成子を定義します。</p>

<p><a href="#QueryForms">16項</a>では、異なる形式の結果を生む4種類のSPARQLクエリを定義します。</p>

<p><a href="#expressions">17項</a>では、SPARQLの拡張可能な値テストと式の枠組みを定義します。これは、クエリの結果に現われ、クエリが返す新しい値の演算も行う値を制約するために使用できる関数と演算子を提示します。</p>

<p><a href="#sparqlDefinition">18項</a>は、SPARQLグラフ・パターンとソリューション修飾子の評価に関する形式的な定義です。</p>

<p><a href="#grammar">19項</a>は、EBNF表記法で示されている文法で規定されているような、SPARQLクエリ言語と<a href="www.w3.org/TR/sparql11-update/">SPARQL更新</a>言語の構文の規範的な定義を含んでいます。</p>

</div>
<div class="div2">

<h3>
<a name="docConventions" id="docConventions"></a>1.2 キュメントの慣習</h3>

<div class="div3">

<h4>
<a name="docNamespaces" id="docNamespaces"></a>1.2.1 名前空間</h4>

<p>このドキュメントでは、特に注記がなければ、例では、次の名前空間は接頭辞バインディングを想定しています。</p>

<div style="text-align: center;">
<table style="border-collapse: collapse; border-color: #000000" border="1" cellpadding="5">
  <tr>
    <th>接頭辞</th>
    <th>IRI</th>
  </tr>
  <tr>
    <td><code>rdf:</code></td>
    <td><code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code></td>
  </tr>
  <tr>
    <td><code>rdfs:</code></td>
    <td><code>http://www.w3.org/2000/01/rdf-schema#</code></td>
  </tr>
  <tr>
    <td><code>xsd:</code></td>
    <td><code>http://www.w3.org/2001/XMLSchema#</code></td>
  </tr>
  <tr>
    <td><code>fn:</code></td>
    <td><code>http://www.w3.org/2005/xpath-functions#</code></td>
  </tr>
  <tr>
    <td><code>sfn:</code></td>
    <td><code>http://www.w3.org/ns/sparql#</code></td>
  </tr>
</table>

</div>
</div>
<div class="div3">

<h4>
<a name="docDataDesc" id="docDataDesc"></a>1.2.2 データの記述</h4>

<p>このドキュメントでは、各トリプルを明示的に表示するために<a class="inform" href="www.w3.org/TR/turtle/">Turtle</a>[<a href="#TURTLE">TURTLE</a>]を使用します。Turtleでは、接頭辞を用いてIRIを省略することが認められています。</p>

<pre class="data">@prefix dc:   &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix :     &lt;http://example.org/book/&gt; .
:book1  dc:title  "SPARQL Tutorial" .</pre>
</div>
<div class="div3">

<h4>
<a name="docResultDesc" id="docResultDesc"></a>1.2.3 結果の記述</h4>

<p>結果集合は、表形式で示されます。</p>

<div class="result">
<a name="table39" id="table39"></a>

<table class="resultTable">
  <tr>
    <th>x</th>
    <th>y</th>
    <th>z</th>
  </tr>
  <tr>
    <td>"Alice"</td>
    <td><code>&lt;http://example/a&gt;</code></td>
    <td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
  </tr>
</table>

</div>

<p>「バインディング」は、（<a href="#defn_QueryVariable">変数</a>、<a href="#defn_RDFTerm">RDF用語</a>）の対です。この結果集合には、<code>x</code>、<code>y</code>、<code>z</code>（列の見出しとして示されている）という3つの変数があります。各ソリューションは、表の本文の1つの列として示されています。ここでは、1つのソリューションがあり、変数<code>x</code>は<code>"Alice"</code>にバインドされており、変数<code>y</code>は<code>&lt;http://example/a&gt;</code>にバインドされており、変数<code>z</code>はRDF用語にバインドされていません。ソリューションでは、変数は、バインドされている必要はありません。</p>

</div>
<div class="div3">

<h4>
<a name="docTerminology" id="docTerminology"></a>1.2.4 用語</h4>

<p>SPARQL言語には、スペースを省略するRDF URI参照のサブセットであるIRIが含まれています。SPARQLクエリでは、すべてのIRIが絶対的であることに注意してください。IRIには、フラグメント識別子[<a href="#rfc3987">RFC3987</a>、3.1項]を含むことも含まないことも可能です。IRIには、URI[<a href="#rfc3986">RFC3986</a>]とURLが含まれます。SPARQL構文の省略形（<a href="#QSynIRI">相対IRIおよび接頭辞付き名前</a>）が解決されると、絶対IRIが作成されます。</p>

<p>次の用語は、<a class="norm" href="www.w3.org/TR/2004/REC-rdf-concepts-20040210/">RDF概念および抽象構文</a> <a href="#CONCEPTS">[CONCEPTS]</a>で定義されており、SPARQLで使用されます。</p>

<ul>
  <li>
<a class="type IRI" href="www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-URI-reference">IRI</a>（概念および抽象構文の用語「RDF URI参照」（<code>RDF URI reference</code>）に対応）</li>
  <li><a class="type literal" href="www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-literal">リテラル</a></li>
  <li><a class="type lexicalForm" href="www.w3.org/TR/rdf-concepts/#dfn-lexical-form">字句形式</a></li>
  <li><a class="type plainLiteral" href="www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-plain-literal">プレーン・リテラル</a></li>
  <li><a class="type langTag" href="www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-language-identifier">言語タグ</a></li>
  <li><a class="type typedLiteral" href="www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-typed-literal">型付きリテラル</a></li>
  <li>
<a class="type datatypeIRI" href="www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-datatype-URI">データ型URI</a>（概念および抽象構文の「データ型URI」（<code>datatype URI</code>）という用語に対応）</li>
  <li><a class="type bNode" href="www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-blank-node">空白ノード</a></li>
</ul>

<p>さらに、次の用語を定義しています。</p>

<ul>
  <li>
<a class="type" href="#defn_RDFTerm">RDF用語</a> - IRI、空白ノード、リテラルを含む</li>
  <li>
<a class="type" href="#defn_SimpleLiteral">シンプルなリテラル</a> - 言語タグやデータ型URIのないリテラルをカバーする</li>
</ul>

</div>
</div>
</div>
<div class="div1">

<h2>
<a name="basicpatterns" id="basicpatterns"></a>2 シンプルなクエリの作成（参考情報）</h2>

<p>SPARQLクエリのほとんどの形式には、<em>基本グラフ・パターン</em>と呼ばれる1組のトリプル・パターンが含まれています。それぞれの主語、述語、目的語が変数でありえることを除き、トリプル・パターンはRDFトリプルに類似しています。サブグラフからの<a href="#defn_RDFTerm">RDF用語</a>を変数に代替でき、結果がサブグラフに同等なRDFグラフである場合、基本グラフ・パターンはそのRDFデータのサブグラフに<em>マッチ</em>します。</p>

<div class="div2">

<h3>
<a name="WritingSimpleQueries" id="WritingSimpleQueries"></a>2.1 シンプルなクエリの記述</h3>

<p>次の例は、与えられたデータ・グラフから書名（title）を発見するためのPARQLクエリを示しています。クエリは、次の2つで構成されています。<code>SELECT</code>句はクエリの結果に現れる変数を識別し、<code>WHERE</code>句はデータ・グラフにマッチする基本グラフ・パターンを提供します。この例の基本グラフ・パターンは、目的語の位置に1つの変数（<code>?title</code>）を持つ、1つのトリプル・パターンから成ります。</p>

<div class="exampleGroup">

<p>データ:</p>

<pre class="data">&lt;http://example.org/book/book1&gt; &lt;http://purl.org/dc/elements/1.1/title&gt; "SPARQL Tutorial" .</pre>
<div class="queryGroup">

<p>クエリ:</p>

<pre class="query">SELECT ?title
WHERE
{
  &lt;http://example.org/book/book1&gt; &lt;http://purl.org/dc/elements/1.1/title&gt; ?title .
}</pre>

<p>上記のデータのこのクエリには、次の1つのソリューションがあります。</p>

<p>クエリ結果:</p>

<div class="result">
<a name="table109" id="table109"></a>

<table class="resultTable">
  <tr>
    <th>title</th>
  </tr>
  <tr>
    <td>"SPARQL Tutorial"</td>
  </tr>
</table>

</div>
</div>
</div>
</div>
<div class="div2">

<h3>
<a name="MultipleMatches" id="MultipleMatches"></a>2.2 複数マッチ</h3>

<p>クエリの結果は、クエリのグラフ・パターンがデータにマッチする方法に従った<a href="#defn_sparqlSolutionSequence">ソリューション・シーケンス</a>です。クエリに対し、0、1または複数のソリューションがありえます。</p>

<p>データ:</p>

<div class="exampleGroup">

<pre class="data">@prefix foaf:  &lt;<a href="xmlns.com/foaf/0.1/">http://xmlns.com/foaf/0.1/</a>&gt; .

_:a  foaf:name   "Johnny Lee Outlaw" .
_:a  foaf:mbox   &lt;mailto:jlow@example.com&gt; .
_:b  foaf:name   "Peter Goodguy" .
_:b  foaf:mbox   &lt;mailto:peter@example.org&gt; .
_:c  foaf:mbox   &lt;mailto:carol@example.org&gt; .</pre>

<p>クエリ:</p>

<div class="queryGroup">

<pre class="query">PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE
  { ?x foaf:name ?name .
    ?x foaf:mbox ?mbox }</pre>

<p>クエリ結果:</p>

<div class="result">

<table class="resultTable">
  <tr>
    <th>name</th>
    <th>mbox</th>
  </tr>
  <tr>
    <td>"Johnny Lee Outlaw"</td>
    <td>&lt;mailto:jlow@example.com&gt;</td>
  </tr>
  <tr>
    <td>"Peter Goodguy"</td>
    <td>&lt;mailto:peter@example.org&gt;</td>
  </tr>
</table>

</div>
</div>
</div>

<p>各ソリューションは、クエリ・パターンがデータにマッチするように、選択された変数をRDF用語にバインドできる1つの方法を提示します。結果集合は、すべての可能なソリューションを示します。上例では、次の2つのデータのサブセットが2つのマッチをもたらしました。</p>

<pre class="dataExcerpt untested"> _:a foaf:name  "Johnny Lee Outlaw" .
 _:a foaf:box   &lt;mailto:jlow@example.com&gt; .</pre>

<pre class="dataExcerpt untested"> _:b foaf:name  "Peter Goodguy" .
 _:b foaf:box   &lt;mailto:peter@example.org&gt; .</pre>

<p>これは、<a href="#BGPsparql">基本グラフ・パターン・マッチ</a>で、クエリ・パターンで使用されるすべての変数がすべてのソリューションにバインドされていなければなりません。</p>

</div>
<div class="div2">

<h3>
<a name="matchingRDFLiterals" id="matchingRDFLiterals"></a>2.3 RDFリテラルのマッチング</h3>

<p>次のデータには、3つのRDFリテラルが含まれています。</p>

<div class="exampleGroup">

<pre class="data">@prefix dt:   &lt;http://example.org/datatype#&gt; .
@prefix ns:   &lt;http://example.org/ns#&gt; .
@prefix :     &lt;http://example.org/ns#&gt; .
@prefix xsd:  &lt;<code>http://www.w3.org/2001/XMLSchema#&gt; .</code>

:x   ns:p     "cat"@en .
:y   ns:p     "42"^^xsd:integer .
:z   ns:p     "abc"^^dt:specialDatatype .</pre>

<p>Turtleでは<code>"cat"@en</code>が字句形式「cat」と言語タグ「en」を持つRDFリテラルであることに注意してください。<code>"42"^^xsd:integer</code>は、データ型<code>http://www.w3.org/2001/XMLSchema#integer</code>を持つ型付きリテラルであり、<code>"abc"^^dt:specialDatatype</code>は、データ型<code>http://example.org/datatype#specialDatatype</code>を持つ型付きリテラルです。</p>

</div>

<p>このRDFデータは、2.3.1～2.3.3項のクエリの例に用いるデータ・グラフです。</p>

<div class="div3">

<h4>
<a name="matchLangTags" id="matchLangTags"></a>2.3.1 リテラルと言語タグとのマッチング</h4>

<p>SPARQLの言語タグは、<a class="norm" href="www.rfc-editor.org/rfc/bcp/bcp47.txt">ベスト・コモン・プラクティス47</a>[<a href="#BCP47">BCP47</a>]で定められているように、<code>@</code>と言語タグを用いて表されます。</p>

<p>次のクエリでは、<code>"cat"</code>が<code>"cat"@en</code>と同じRDFリテラルではないため、ソリューションはありません。</p>

<div class="queryGroup">

<pre class="query">SELECT ?v WHERE { ?v ?p "cat" }</pre>
<div class="result">

<table class="resultTable">
  <tr>
    <th>&nbsp;&nbsp; v&nbsp;&nbsp;&nbsp;&nbsp; </th>
  </tr>
</table>

</div>

<p>しかし、次のクエリは、言語タグが指定されており、与えられたデータにマッチするため、変数<code>v</code>が<code>:x</code>にバインドされているソリューションが見つかるでしょう。</p>

<pre class="query">SELECT ?v WHERE { ?v ?p "cat"@en }</pre>
<div class="result">

<table class="resultTable">
  <tr>
    <th>v</th>
  </tr>
  <tr>
    <td>&lt;http://example.org/ns#x&gt;</td>
  </tr>
</table>

</div>
</div>
</div>
<div class="div3">

<h4>
<a name="matchNumber" id="matchNumber"></a>2.3.2 リテラルと数値型とのマッチング</h4>

<p>SPARQLクエリの整数は、データ型<code>xsd:integer</code>を持つRDF型付きリテラルです。例えば、<code>42</code>は、<code>"42"^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;</code>の省略形です。</p>

<p>次のクエリのパターンには、<code>:y</code>にバインドされている変数<code>v</code>を持つソリューションがあります。</p>

<div class="queryGroup">

<pre class="query">SELECT ?v WHERE { ?v ?p 42 }</pre>
<div class="result">
<a name="table60" id="table60"></a>

<table class="resultTable">
  <tr>
    <th>v</th>
  </tr>
  <tr>
    <td>&lt;http://example.org/ns#y&gt;</td>
  </tr>
</table>

</div>
</div>

<p><a href="#QSynLiterals">4.1.2項</a>では、<code>xsd:float</code>と<code>xsd:double</code>のSPARQL省略形を定義しています。</p>

</div>
<div class="div3">

<h4>
<a name="matchArbDT" id="matchArbDT"></a>2.3.3 リテラルと任意のデータ型とのマッチング</h4>

<p>次のクエリには、<code>:z</code>にバインドされている変数<code>v</code>を持つソリューションがあります。クエリ・プロセッサがデータ型のスペースの値を理解している必要はありません。字句形式とデータ型IRIの両方がマッチするため、リテラルはマッチします。</p>

<div class="queryGroup">

<pre class="query">SELECT ?v WHERE { ?v ?p "abc"^^&lt;http://example.org/datatype#specialDatatype&gt; }</pre>
<div class="result">
<a name="table61" id="table61"></a>

<table class="resultTable">
  <tr>
    <th>v</th>
  </tr>
  <tr>
    <td>&lt;http://example.org/ns#z&gt;</td>
  </tr>
</table>

</div>
</div>
</div>
</div>
<div class="div2">

<h3>
<a name="BlankNodesInResults" id="BlankNodesInResults"></a>2.4 クエリ結果の空白ノード・ラベル</h3>

<p>クエリの結果には、空白ノードを含むことができます。このドキュメントの例では、結果集合の空白ノードは、"_:"の後に空白ノード・ラベルが続く形で書かれています。</p>

<p>空白ノード・ラベルは結果集合（「<a class="inform" href="www.w3.org/TR/rdf-sparql-XMLres/">SPARQLクエリ結果XMLフォーマット</a>」と「<a href="www.w3.org/TR/sparql11-results-json/">SPARQL 1.1クエリ結果JSONフォーマット</a>」を参照）で有効であり、<code>CONSTRUCT</code>クエリ形式の場合は結果グラフで有効です。結果集合内での同じラベルの使用は、同じ空白ノードを表します。</p>

<div class="exampleGroup">
データ:
<pre class="data">@prefix foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name   "Alice" .
_:b  foaf:name   "Bob" .</pre>

<div class="queryGroup">
クエリ:
<pre class="query">PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?x ?name
WHERE  { ?x foaf:name ?name }</pre>

<div class="result">
<a name="table56" id="table56"></a>

<table class="resultTable">
  <tr>
    <th>x</th>
    <th>name</th>
  </tr>
  <tr>
    <td>_:c</td>
    <td>"Alice"</td>
  </tr>
  <tr>
    <td>_:d</td>
    <td>"Bob"</td>
  </tr>
</table>

</div>
</div>

<p>上記の結果は、結果におけるラベルがソリューション内のRDF用語が同じか異なるかを示すだけであるため、異なる空白ノード・ラベルでも同じく得ることができます。</p>

<div class="result untested">
<a name="table57" id="table57"></a>

<table class="resultTable">
  <tr>
    <th>x</th>
    <th>name</th>
  </tr>
  <tr>
    <td>_:r</td>
    <td>"Alice"</td>
  </tr>
  <tr>
    <td>_:s</td>
    <td>"Bob"</td>
  </tr>
</table>

</div>
</div>

<p>これらの2つの結果は同じ情報を持っていますが、2つのソリューションでは、クエリにマッチさせるために用いられる空白ノードが異なっています。結果集合のラベル<code>_:a</code>と、同じラベルを持つデータ・グラフの空白ノードとの間に関係がある必要はありません。</p>

<p>アプリケーションの作成者は、クエリの空白ノード・ラベルがデータの特定の空白ノードを参照することを期待すべきではありません。</p>

</div>
<div class="div2">

<h3>
<a name="CreatingValuesWithExpressions" id="CreatingValuesWithExpressions"></a>2.5 式による値の作成</h3>

<p>PARQL 1.1では、複数の式から値を作成できます。下記のクエリは、<a href="#func-concat">CONCAT</a>関数をいて、foafデータの名と姓を連結させ、その後に<a href="#selectExpressions"><code>SELECT</code>句内の式</a>を用いて値を割り当て、さらに<a href="#bind">BIND</a>形式を用いて値を割り当てる方法を示しています。</p>

<div class="exampleGroup">
データ:
<pre class="data">@prefix foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .
          
_:a  foaf:givenName   "John" .
_:a  foaf:surname  "Doe" .</pre>
<div class="queryGroup">
クエリ:
<pre class="query">PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ( CONCAT(?G, " ", ?S) AS ?name )
WHERE  { ?P foaf:givenName ?G ; foaf:surname ?S }</pre>
クエリ:
<pre class="query">PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name
WHERE  { 
   ?P foaf:givenName ?G ; 
      foaf:surname ?S 
   BIND(CONCAT(?G, " ", ?S) AS ?name)
}</pre>
<div class="result">
<a name="table59" id="table59"></a>

<table class="resultTable">
  <tr>
    <th>name</th>
  </tr>
  <tr>
    <td>"John Doe"</td>
  </tr>
</table>

</div>
</div>
</div>
</div>
<div class="div2">

<h3>
<a name="constructGraph" id="constructGraph"></a>2.6 RDFグラフの構築</h3>

<p>SPARQLには、いくつかの<a href="#QueryForms">クエリ形式</a>があります。<code>SELECT</code>というクエリ形式は、変数バインディングを返します。<code>CONSTRUCT</code>というクエリ形式はRDFグラフを返します。グラフは、クエリのグラフ・パターンをマッチングした結果に基づくRDFトリプルを作成するために用いられるテンプレートに基づいて構築されます。</p>

<div class="exampleGroup">

<p>データ:</p>

<pre class="data">@prefix org:    &lt;http://example.com/ns#&gt; .

_:a  org:employeeName   "Alice" .
_:a  org:employeeId     12345 .

_:b  org:employeeName   "Bob" .
_:b  org:employeeId     67890 .</pre>
<div class="queryGroup">

<p>クエリ:</p>

<pre class="query">PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX org:    &lt;http://example.com/ns#&gt;

CONSTRUCT { ?x foaf:name ?name }
WHERE  { ?x org:employeeName ?name }</pre>

<p>結果:</p>

<div class="result">

<pre class="resultGraph">@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .
      
_:x foaf:name "Alice" .
_:y foaf:name "Bob" .</pre>
</div>
</div>

<p>これは、次のとおり、<a href="www.w3.org/TR/rdf-syntax-grammar/">RDF/XML</a>でシリアル化できます。</p>

<div class="result">

<pre class="resultGraph" style="text-align: left;">&lt;rdf:RDF
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    xmlns:foaf="http://xmlns.com/foaf/0.1/"
    &gt;
  &lt;rdf:Description&gt;
    &lt;foaf:name&gt;Alice&lt;/foaf:name&gt;
  &lt;/rdf:Description&gt;
  &lt;rdf:Description&gt;
    &lt;foaf:name&gt;Bob&lt;/foaf:name&gt;
  &lt;/rdf:Description&gt;
&lt;/rdf:RDF&gt;</pre>
</div>
</div>
</div>
</div>
<div class="div1">

<h2>
<a name="termConstraint" id="termConstraint"></a>3 RDF用語制約（参考情報）</h2>

<p>グラフ・パターン・マッチングはソリューション・シーケンスを作成し、その各ソリューションは、RDF用語に対する変数バインディングの集合を持ちます。SPARQLの<code>FILTER</code>は、フィルタの式が真（<code>TRUE</code>）であるものにソリューションを制限します。</p>

<p>この項では、SPARQLの<code>FILTER</code>に関する非形式的な手引きを提供します。このセマンティクスは、<a href="#SparqlOps">包括的な関数ライブラリ</a>がある「<a href="#expressions">式と値のテスト</a>」の項で定められています。この項の例では、次の1つの入力グラフを共用しています。</p>

<div class="exampleGroup">
  データ:
  <pre class="data">@prefix dc:   &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix :     &lt;http://example.org/book/&gt; .
@prefix ns:   &lt;http://example.org/ns#&gt; .

:book1  dc:title  "SPARQL Tutorial" .
:book1  ns:price  42 .
:book2  dc:title  "The Semantic Web" .
:book2  ns:price  23 .</pre>
</div>
<div class="div2">

<h3>
<a name="restrictString" id="restrictString"></a>3.1 文字列の値の制限</h3>

<p><code><a href="#func-regex">regex</a></code>のようなSPARQLの<code>FILTER</code>関数は、RDFリテラルをテストできます。<code>regex</code>は、<a href="#func-string">文字列リテラル</a>のみにマッチします。<code>regex</code>は、<a href="#func-str">str</a>関数を用いて他のリテラルの字句形式にマッチさせるために使用できます。</p>

<p>クエリ:</p>

<div class="queryGroup">

<pre class="query">PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT  ?title
WHERE   { ?x dc:title ?title
          FILTER regex(?title, "^SPARQL") 
        }</pre>

<p>クエリ結果:</p>

<div class="result">
<a name="table63" id="table63"></a>

<table class="resultTable">
  <tr>
    <th>title</th>
  </tr>
  <tr>
    <td>"SPARQL Tutorial"</td>
  </tr>
</table>

</div>
</div>

<p>正規表現マッチでは、「<code>i</code>」フラグを用いて大文字・小文字を区別しないようにすることができます。</p>

<p>クエリ:</p>

<div class="queryGroup">

<pre class="query">PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT  ?title
WHERE   { ?x dc:title ?title
          FILTER regex(?title, "web", "i" ) 
        }</pre>

<p>クエリ結果:</p>

<div class="result">
<a name="table64" id="table64"></a>

<table class="resultTable">
  <tr>
    <th>title</th>
  </tr>
  <tr>
    <td>"The Semantic Web"</td>
  </tr>
</table>

</div>
</div>

<p>正規表現言語は、<a href="www.w3.org/TR/xpath-functions/#regex-syntax">XQuery 1.0とXPath 2.0関数および演算子で定められており</a>、<a href="www.w3.org/TR/xmlschema-2/#regexs">XMLスキーマ正規表現</a>に基づいています。</p>

</div>
<div class="div2">

<h3>
<a name="restrictNumber" id="restrictNumber"></a>3.2 数値の制限</h3>

<p>SPARQLの<code>FILTER</code>は、計算式を制限できます。</p>

<p>クエリ:</p>

<div class="queryGroup">

<pre class="query">PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  ns:  &lt;http://example.org/ns#&gt;
SELECT  ?title ?price
WHERE   { ?x ns:price ?price .
          FILTER (?price &lt; 30.5)
          ?x dc:title ?title . }</pre>

<p>クエリ結果:</p>

<div class="result">
<a name="table58" id="table58"></a>

<table class="resultTable">
  <tr>
    <th>title</th>
    <th>price</th>
  </tr>
  <tr>
    <td>"The Semantic Web"</td>
    <td>23</td>
  </tr>
</table>

</div>
</div>
</div>

<p><code>:book2</code>のみが<code>30.5</code>未満の価格を持っているため、<code>price</code>変数を制約することで、フィルタ条件の要求に従い、<code>:book2</code>のみがクエリにマッチします。</p>

<div class="div2">

<h3>
<a name="otherTermConstraints" id="otherTermConstraints"></a>3.3 その他の用語制約</h3>

<p><span class="type numeric">数値</span>型に加え、SPARQLは、<code>xsd:string</code>、<code>xsd:boolean</code>、<code>xsd:dateTime</code>という型をサポートしています（<a href="#operandDataTypes">オペランド・データ型</a>を参照してください）。<a href="#OperatorMapping">演算子マッピング</a>の項では、演算子について述べ、<a href="#SparqlOps">関数の定義</a>の項では、RDF用語に適用できる関数について述べています。</p>

</div>
</div>
<div class="div1">

<h2>
<a name="sparqlSyntax" id="sparqlSyntax"></a>4 SPARQL構文</h2>

<p>この項では、<a href="#sparqlBasicTerms">RDF用語</a>および<a href="#sparqlTriplePatterns">トリプル・パターン</a>に対してSPARQLが用いる構文をカバーしています。完全な文法は<a href="#grammar">19項</a>で示します。</p>

<div class="div2">

<h3>
<a name="syntaxTerms" id="syntaxTerms"></a>4.1 RDF用語構文</h3>
<div class="div3">

<h4>
<a name="QSynIRI" id="QSynIRI"></a>4.1.1 IRIの構文</h4>

<p><a href="#riri">iri</a>生成規則は、IRI[<a href="#rfc3987">RFC3987</a>]の集合を指定します。IRIは、URI[<a href="#rfc3986">RFC3986</a>]を一般化したものであり、URIおよびURLと完全に互換性があります。<a href="#rPrefixedName">PrefixedName</a>生成規則は、接頭辞名を指定します。接頭辞名からIRIへのマッピングについて、以下で説明しています。IRI参照（相対的または絶対的なIRI）は、<a href="#rIRIREF">IRIREF</a>生成規則によって指定され、「&lt;」と「&gt;」の区切り記号はIRI参照の一部にはなりません。相対IRIは、[<a href="#rfc3987">RFC3987</a>]の2.2 IRI参照とIRIに対するABNFの項の<code>irelative-ref</code>にマッチし、下記のIRIに解決されます。</p>

<p>SPARQL用語にはIRIが含まれていますが、RDF概念および抽象構文で定義されているRDF用語にはRDF URI参照が含まれています。「<code>&lt;</code>」、「<code>&gt;</code>」、「<code>"</code>」（ダブル引用符）、スペース、「<code>{</code>」、「<code>}</code>」、「<code>|</code>」、「<code>\</code>」、「<code>^</code>」、「<code>`</code>」を含むRDF URI参照は、IRIではありません。このようなRDF URI参照で構成されたRDFステートメントに対するSPARQLクエリの動作は定められていません。</p>

<div class="div4">

<h5>
<a name="prefNames" id="prefNames"></a>4.1.1.1 接頭辞名</h5>

<p><code>PREFIX</code>キーワードは、接頭辞ラベルをIRIに関連付けます。接頭辞名は、コロン「<code>:</code>」によって区切られた、接頭辞ラベルとローカル部分（local part）です。接頭辞名は、接頭辞に関連付けられたIRIとローカル部分とを連結することによって、IRIにマッピングされます。接頭辞ラベルまたはローカル部分は、空でありえます。先頭桁（leading digit）は、<a href="www.w3.org/TR/2006/REC-xml-names11-20060816/#NT-LocalPart">XMLローカル名</a>では認められていませんが、<a href="#rPN_LOCAL">SPARQLローカル名</a>では認められていることに注意してください。<a href="#rPN_LOCAL">SPARQLローカル名</a>によって、バックスラッシュの文字エスケープ（例えば、<code lang="en">ns:id\=123</code>）を用いると、IRIで認められている非英数字も使用可能になります。<a href="#rPN_LOCAL">SPARQLローカル名</a>には、<a href="www.w3.org/TR/curie/">CURIE</a>よりも構文上の制限が多くあります。</p>

</div>
<div class="div4">

<h5>
<a name="relIRIs" id="relIRIs"></a>4.1.1.2 相対IRI</h5>

<p>相対IRIは、<a class="norm" href="www.ietf.org/rfc/rfc3986.txt">URI（Uniform Resource Identifier）: 一般的構文</a>[<a href="#rfc3986">RFC3986</a>]にあるとおり、5.2項の基本アルゴリズムのみを用いて、基底IRIに組み合わされます。構文に基づく正規化もスキームに基づく正規化も（RFC3986の6.2.2および6.2.3項に記述されている）実行されません。IRI参照で追加的に認められている文字は、<a class="norm" href="www.ietf.org/rfc/rfc3987.txt">IRI（Internationalized Resource Identifiers）</a>[<a href="#rfc3987">RFC3987</a>]の6.5項にあるとおり、URI参照で無制限の文字が扱われているのと同じ方法で扱われます。</p>

<p><code>BASE</code>キーワードは、RFC3986の5.1.1項「コンテンツ内に組み込まれた基底URI」にあるとおり、相対IRIを解決するために用いられる基底IRIを定めます。5.1.2項「カプセル化されたエンティティーからの基底URI」は、xml:base指示子を持つSOAPエンベロープやContent-Locationヘッダーを持つマイム・マルチパート・ドキュメントのようなカプセル化されたドキュメントから、どのように基底IRIを持ってくることができるかを定めています。5.1.3「検索URIからの基底URI」で識別された「検索URI」は、特定のSPARQLクエリが検索されたURLです。上記のどれもが基底URIを指定しない場合は、デフォルト基底URI（5.1.4項「デフォルト基底URI」を参照）が用いられます。</p>

<p>次のフラグメントは、同じIRIを記述する別々の方法の一部です。</p>

<pre class="data">&lt;http://example.org/book/book1&gt;</pre>

<pre class="data">BASE &lt;http://example.org/book/&gt;
&lt;book1&gt;</pre>

<pre class="data">PREFIX book: &lt;http://example.org/book/&gt;
book:book1</pre>
</div>
</div>
<div class="div3">

<h4>
<a name="QSynLiterals" id="QSynLiterals"></a>4.1.2 リテラルの構文</h4>

<p>リテラルの一般的な構文は、言語タグのオプション（<code>@</code>で導入される）か、データ型IRIまたは接頭辞名のオプション（<code>^^</code>で導入される）かのどちらかを持つ文字列（ダブル引用符<code>"..."</code>、または、シングル引用符<code>'...'</code>で囲まれた)です。</p>

<p>便宜上、整数を直接記述（引用符と明示的なデータ型IRIなしに）でき、これはデータ型<code>xsd:integer</code>の型付きリテラルとして解釈され、数字の中に「.」があるけれども指数がない小数は<code>xsd:decimal</code>と解釈され、指数がある数<code>xsd:double</code>と解釈されます。型<code>xsd:boolean</code>の値は、真（<code>true</code>）または偽（<code>false</code>）と記述できます。</p>

<p>自身に引用符を含む、または、長くて改行文字を含むリテラル値の記述を容易にするために、SPARQLでは、リテラルを3つのシングル引用符またはダブル引用符で囲んだ引用構成子も提供されています。</p>

<p>SPARQLのリテラル構文の例は、次のとおりです。</p>

<ul>
<li><code>"chat"</code></li>
  <li>言語タグ「fr」を持つ<code>'chat'@fr</code>
</li>
  <li><code>"xyz"^^&lt;http://example.org/ns/userDatatype&gt;</code></li>
  <li><code>"abc"^^appNS:appDataType</code></li>
  <li><code>'''The librarian said, "Perhaps you would enjoy 'War and Peace'."'''</code></li>
  <li>
<code>1</code>、これは<code>"1"^^xsd:integer</code>と同じ</li>
  <li>
<code>1.3</code>、 これは<code>"1.3"^^xsd:decimal</code>と同じ</li>
  <li>
<code>1.300</code>、 これは<code>"1.300"^^xsd:decimal</code>と同じ</li>
  <li>
<code>1.0e6</code>、 これは<code>"1.0e6"^^xsd:double</code>と同じ</li>
  <li>
<code>true</code>、 これは<code>"true"^^xsd:boolean</code>と同じ</li>
  <li>
<code>false</code>、 これは<code>"false"^^xsd:boolean</code>と同じ</li>
</ul>

<p>生成規則<a href="#rINTEGER">INTEGER</a>、<a href="#rDECIMAL">DECIMAL</a>、<a href="#rDOUBLE">DOUBLE</a>、<a href="#rBooleanLiteral">BooleanLiteral</a>にマッチするトークンは、トークンの字句値と、対応するデータ型（<code>xsd:integer</code>、<code>xsd:decimal</code>、<code>xsd:double</code>、<code>xsd:boolean</code>）を持つ型付きテラルと同等です。</p>

</div>
<div class="div3">

<h4>
<a name="QSynVariables" id="QSynVariables"></a>4.1.3 クエリ変数の構文</h4>

<p>クエリ変数は「?」か「$」のどちらを用いてマーク付けされますが、「?」や「$」は変数名の一部ではありません。クエリでは、<code>$abc</code>と<code>?abc</code>は同じ変数を識別します。<a href="#grammar">SPARQL文法</a>では、変数に対して<a href="#rVARNAME">可能な名前</a>が与えられます。</p>

</div>
<div class="div3">

<h4>
<a name="QSynBlankNodes" id="QSynBlankNodes"></a>4.1.4 空白ノードの構文</h4>

<p>グラフ・パターンの<a class="norm" href="www.w3.org/TR/rdf-concepts/#section-blank-nodes">空白ノード</a>は、問い合わされたデータの特定の空白ノードの参照としてではなく、変数として機能します。</p>

<p>空白ノードは、「<code>_:abc</code>」などのラベル形式か、省略形「<code>[]</code>」のどちらかで示されます。クエリ構文の1箇所でしか使うことができない空白ノードは<code>[]</code>で示すことができます。ユニークな空白ノードは、トリプル・パターンを形成するために用いられるでしょう。ラベル「<code>abc</code>」を持つ空白ノードに対する空白ノード・ラベルは「<code>_:abc</code>」と書かれます。同じ空白ノード・ラベルは、同じクエリ内の2つの異なる基本グラフ・パターンに使用することはできません。</p>

<p><code>[:p :v]</code>構成子は、トリプル・パターンで用いることができます。これは、すべてを含んだ述語-目的語の対の主語として用いられる空白ノード・ラベルを作成します。作成された空白ノードは、さらに他のトリプル・パターンの主語と目的語の位置でも使用できます。</p>

<p>次の2つの形式</p>

<pre class="query untested">[ :p "v" ] .</pre>

<pre class="query untested">[] :p "v" .</pre>

<p>は、ユニークな空白ノード・ラベル（ここでは「<code>b57</code>」）を割り当てると、次の記述と同等です。</p>

<pre class="query untested">_:b57 :p "v" .</pre>

<p>割り当てられたこの空白ノード・ラベルは、さらに別のトリプル・パターンの主語または目的語として使用できます。例えば、主語として用いると次のようになります。</p>

<pre class="query untested">[ :p "v" ] :q "w" .</pre>

<p>これは、次の2つのトリプルと同等です。</p>

<pre class="query untested">_:b57 :p "v" .
_:b57 :q "w" .</pre>

<p>そして、目的語として用いると次のようになります。</p>

<pre class="query untested">:x :q [ :p "v" ] .</pre>

<p>これは、次の2つのトリプルと同等です。</p>

<pre class="query untested">:x  :q _:b57 .
_:b57 :p "v" .</pre>

<p>省略化された空白ノード構文は、<a href="#predObjLists">共通の主語</a>と<a href="#objLists">共通の述語</a>に対する他の省略語と組み合わせることができます。</p>

<pre class="query untested">  [ foaf:name  ?name ;
    foaf:mbox  &lt;mailto:alice@example.org&gt; ]</pre>

<p>これは、あるユニークに割り当てられた空白ノード・ラベル「<code>b18</code>」に対する次の基本グラフ・パターンの記述と同じです。</p>

<pre class="query untested">  _:b18  foaf:name  ?name .
  _:b18  foaf:mbox  &lt;mailto:alice@example.org&gt; .</pre>
</div>
</div>
<div class="div2">

<h3>
<a name="QSynTriples" id="QSynTriples"></a>4.2 トリプル・パターンの構文</h3>

<p><a href="#defn_TriplePattern">トリプル・パターン</a>は、主語、述語、目的語として書かれます。いくつかの共通するトリプル・パターン構成子を省略して書く方法があります。</p>

<p>次の例は、同じクエリを表します。</p>

<pre class="query">PREFIX  dc: &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT  ?title
WHERE   { &lt;http://example.org/book/book1&gt; dc:title ?title }  </pre>

<pre class="query">PREFIX  dc: &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  : &lt;http://example.org/book/&gt;

SELECT  $title
WHERE   { :book1  dc:title  $title }</pre>

<pre class="query">BASE    &lt;http://example.org/book/&gt;
PREFIX  dc: &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT  $title
WHERE   { &lt;book1&gt;  dc:title  ?title }</pre>
<div class="div3">

<h4>
<a name="predObjLists" id="predObjLists"></a>4.2.1 述語-目的語のリスト</h4>

<p>共通の主語を持つトリプル・パターンは、主語を1度だけ記述し、「<code>;</code>」表記法を用いて1つ以上のトリプル・パターンで用いられるように記述できます。</p>

<pre class="query untested">    ?x  foaf:name  ?name ;
        foaf:mbox  ?mbox .</pre>

<p>これは、次のトリプル・パターンの記述と同じです。</p>

<pre class="query untested">    ?x  foaf:name  ?name .
    ?x  foaf:mbox  ?mbox .</pre>
</div>
<div class="div3">

<h4>
<a name="objLists" id="objLists"></a>4.2.2 目的語のリスト</h4>

<p>トリプル・パターンが主語と述語の両方を共有する場合、目的語を「<code>,</code>」で区切ることができます。</p>

<pre class="query untested">    ?x foaf:nick  "Alice" , "Alice_" .</pre>

<p>上記は、次のトリプル・パターンの記述と同じです。</p>

<pre class="query untested">   ?x  foaf:nick  "Alice" .
   ?x  foaf:nick  "Alice_" .</pre>

<p>次のように、目的語のリストを述語-目的語のリストと組み合わせることができます。</p>

<pre class="query untested">   ?x  foaf:name ?name ; foaf:nick  "Alice" , "Alice_" .</pre>

<p>これは、次と同等です。</p>

<pre class="query untested">   ?x  foaf:name  ?name .
   ?x  foaf:nick  "Alice" .
   ?x  foaf:nick  "Alice_" .</pre>
</div>
<div class="div3">

<h4>
<a name="collections" id="collections"></a>4.2.3 RDFコレクション</h4>

<p>「(element1 element2 ...)」という構文を用いてトリプル・パターンに<a class="norm" href="www.w3.org/TR/2004/REC-rdf-mt-20040210/#collections">RDFコレクション</a>を記述できます。形式「<code>()</code>」は、<code><a href="www.w3.org/1999/02/22-rdf-syntax-ns#nil">http://www.w3.org/1999/02/22-rdf-syntax-ns#nil</a></code>というIRIの代替です。<code>(1 ?x 3 4)</code>のようなコレクション要素とともに用いれば、空白ノードを持つトリプル・パターンがコレクションに割り当てられます。コレクションの先頭の空白ノードは、他のトリプル・パターンの主語または目的語として使用できます。コレクション構文で割り当てられた空白ノードは、クエリのほかの場所では出現しません。</p>

<pre class="query untested">(1 ?x 3 4) :p "w" .</pre>

<p>上記は、次に対する糖衣構文です（<code>b0</code>、<code>b1</code>、<code>b2</code>、<code>b3</code>がクエリの他のどこかで出現しないことを意味する）。</p>

<pre class="query untested">    _:b0  rdf:first  1 ;
          rdf:rest   _:b1 .
    _:b1  rdf:first  ?x ;
          rdf:rest   _:b2 .
    _:b2  rdf:first  3 ;
          rdf:rest   _:b3 .
    _:b3  rdf:first  4 ;
          rdf:rest   rdf:nil .
    _:b0  :p         "w" . </pre>

<p>RDFコレクションは、入れ子にすることができ、他の構文を含むことができます。</p>

<pre class="query untested">(1 [:p :q] ( 2 ) ) .</pre>

<p>上記は、次に対する糖衣構文です。</p>

<pre class="query untested">    _:b0  rdf:first  1 ;
          rdf:rest   _:b1 .
    _:b1  rdf:first  _:b2 .
    _:b2  :p         :q .
    _:b1  rdf:rest   _:b3 .
    _:b3  rdf:first  _:b4 .
    _:b4  rdf:first  2 ;
          rdf:rest   rdf:nil .
    _:b3  rdf:rest   rdf:nil .</pre>
</div>
<div class="div3">

<h4>
<a name="abbrevRdfType" id="abbrevRdfType"></a>4.2.4 rdf:type</h4>

<p>キーワード「<code>a</code>」は、トリプル・パターンで述語として使用でき、<code><a href="www.w3.org/1999/02/22-rdf-syntax-ns#type">http://www.w3.org/1999/02/22-rdf-syntax-ns#type</a></code>というIRIの代替です。このキーワードは大文字・小文字を区別します。</p>

<pre class="query untested">  ?x  a  :Class1 .
  [ a :appClass ] :p "v" .</pre>

<p>上記は、次に対する糖衣構文です。</p>

<pre class="query untested">  ?x    rdf:type  :Class1 .
  _:b0  rdf:type  :appClass .
  _:b0  :p        "v" .</pre>
</div>
</div>
</div>
<div class="div1">

<h2>
<a name="GraphPattern" id="GraphPattern"></a>5 グラフ・パターン</h2>

<p>SPARQLはグラフ・パターン・マッチングを基本としています。より複雑なグラフ・パターンは、小さなパターンを様々な方法で組み合わせて作成できます。</p>

<ul>
<li>
<a href="#BasicGraphPatterns">基本グラフ・パターン</a>、1組のトリプル・パターンがマッチしなければなりません。</li>
  <li>
<a href="#GroupPatterns">グループ・グラフ・パターン</a>、1組のグラフ・パターンがすべてマッチしなければなりません。</li>
  <li>
<a href="#optionals">オプション・グラフ・パターン</a>、追加パターンによってソリューションを拡張することができます。</li>
  <li>
<a href="#alternatives">代替グラフ・パターン</a>、2つ以上の可能なパターンを試します。</li>
  <li>
<a href="#queryDataset">名前付きグラフのパターン</a>、パターンが名前付きグラフにマッチします。</li>
</ul>

<p>この項では、論理積でパターンを組み合わせる2つの形式について説明します。それらは、トリプル・パターンを組み合わせる基本グラフ・パターンと、他のすべてのパターンを組み合わせるグループ・グラフ・パターンです。</p>

<p>最も外側のクエリのグラフ・パターンは、クエリ・パターンと呼ばれます。これは、文法上、次の<code>GroupGraphPattern</code>で識別されます。</p>

<div class="grammarExtract">
<div class="grammarTable">

<table>
  <tr valign="baseline">
    <td><code>[17]&nbsp;&nbsp;</code></td>
    <td><code><a href="#rWhereClause">WhereClause</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'WHERE'</span>? <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
  </tr>
</table>

</div>
</div>
<div class="div2">

<h3>
<a name="BasicGraphPatterns" id="BasicGraphPatterns"></a>5.1 基本グラフ・パターン</h3>

<p>基本グラフ・パターンはトリプル・パターンの集合です。SPARQLのグラフ・パターン・マッチングは、マッチした基本グラフ・パターンの結果を組み合わせるという観点で定義されます。</p>

<p>オプションのフィルタを有する、トリプル・パターンのシーケンスは、1つの基本グラフ・パターンから成ります。他のグラフ・パターンが、基本グラフ・パターンを終了させます。</p>

<div class="div3">

<h4>
<a name="bgpBNodeLabels" id="bgpBNodeLabels"></a>5.1.1 空白ノード・ラベル</h4>

<p>形式<code>_:abc</code>の空白ノードを用いるときには、空白ノードのラベルは基本グラフ・パターンで有効です。1つのラベルは、任意のクエリにおける1つの基本グラフ・パターンのみで使用できます。</p>

</div>
<div class="div3">

<h4>
<a name="bgpExtend" id="bgpExtend"></a>5.1.2 基本グラフ・パターン・マッチングの拡張</h4>

<p>SPARQLは、サブグラフ・マッチングで基本グラフ・パターンを評価します。これは、シンプルな含意のために定義されています。以下の記述のような、<a href="#sparqlBGPExtend">ある特定の状況</a>が与えられれば、SPARQLを他の形式の含意に拡張できます。<a href="www.w3.org/TR/sparql11-entailment/">SPARQL 1.1含意レジーム</a>のドキュメントは、いくつかの特定の含意レジームについて記述しています。</p>

</div>
</div>
<div class="div2">

<h3>
<a name="GroupPatterns" id="GroupPatterns"></a>5.2 グループ・グラフ・パターン</h3>

<p>SPARQLのクエリ文字列では、グループ・グラフ・パターンは中括弧（<code>{}</code>）で区切られます。例えば、このクエリのクエリ・パターンは、1つの基本グラフ・パターンからなるグループ・グラフ・パターンです。</p>

<div class="exampleGroup">
<div class="queryGroup">

<pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE  {
          ?x foaf:name ?name .
          ?x foaf:mbox ?mbox .
       }</pre>
</div>
</div>
<div class="exampleGroup">
<div class="queryGroup">
トリプル・パターンを2つの基本グラフ・パターンにグルーピングしたクエリから同じソリューションが得られるでしょう。例えば、次のクエリは、異なる構造を持っていますが、上記のクエリと同じソリューションをもたらすでしょう。
    <pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE  { { ?x foaf:name ?name . }
         { ?x foaf:mbox ?mbox . }
       }</pre>
</div>
</div>
<div class="div3">

<h4>
<a name="emptyGroupPattern" id="emptyGroupPattern"></a>5.2.1 空のグループ・パターン</h4>

<p>グループ・パターン</p>

<pre class="query untested">{ }</pre>

<p>は、任意のグラフ（空のグラフを含む）を、変数をバインドしない1つのソリューションにマッチさせます。例えば、</p>

<pre class="query untested">SELECT ?x
WHERE {}</pre>

<p>は、変数<code>x</code>がバインドされていない1つのソリューションとマッチします。</p>

</div>
<div class="div3">

<h4>
<a name="scopeFilters" id="scopeFilters"></a>5.2.2 フィルタの範囲</h4>

<p><code>FILTER</code>キーワードによって表される制約は、フィルタが出現するすべてのグループにまたがるソリューションに対する制限です。次のパターンはすべて、同じソリューションを持ちます。</p>

<div class="exampleGroup">
<div class="queryGroup">

<pre class="query"> {  ?x foaf:name ?name .
    ?x foaf:mbox ?mbox .
    FILTER regex(?name, "Smith")
 }</pre>
</div>
</div>
<div class="exampleGroup">
<div class="queryGroup">

<pre class="query"> {  FILTER regex(?name, "Smith")
    ?x foaf:name ?name .
    ?x foaf:mbox ?mbox .
 }</pre>
</div>
</div>
<div class="exampleGroup">
<div class="queryGroup">

<pre class="query"> {  ?x foaf:name ?name .
    FILTER regex(?name, "Smith")
    ?x foaf:mbox ?mbox .
 }</pre>
</div>
</div>
</div>
<div class="div3">

<h4>
<a name="groupExamples" id="groupExamples"></a>5.2.3 グループ・グラフ・パターンの例</h4>

<div class="exampleGroup">
<div class="queryGroup">

<pre class="query">  {
    ?x foaf:name ?name .
    ?x foaf:mbox ?mbox .
  }</pre>
</div>
</div>

<p>は、1つの基本グラフ・パターンからなるグループで、その基本グラフ・パターンは、2つのトリプル・パタ ーンから構成されています。</p>

<div class="exampleGroup">
<div class="queryGroup">

<pre class="query">  {
    ?x foaf:name ?name . FILTER regex(?name, "Smith")
    ?x foaf:mbox ?mbox .
  }</pre>
</div>
</div>

<p>は、1つの基本グラフ・パターンとフィルタからなるグループで、その基本グラフ・パターンは、2つのトリプル・パターンから構成されています。フィルタは基本グラフ・パターンを2つの基本グラフ・パターンに分割しません。</p>

<div class="exampleGroup">
<div class="queryGroup">

<pre class="query">  {
    ?x foaf:name ?name .
    {}
    ?x foaf:mbox ?mbox .
  }</pre>
</div>
</div>

<p>は、1つのトリプル・パターンからなる基本グラフ・パターン、空のグループ、1つのトリプル・パターンからなる別の基本グラフ・パターンという、3つの要素のグループです。</p>

</div>
</div>
</div>
<div class="div1">

<h2>
<a name="optionals" id="optionals"></a>6 オプション値の組み込み</h2>

<p>基本グラフ・パターンでは、アプリケーションは、ソリューションが生成されるようにクエリ・パターンの全体がマッチしなければならないようなクエリを作成できます。少なくとも1つの基本グラフ・パターンを持つグループ・グラフ・パターンのみを含むクエリのすべてのソリューションでは、すべての変数は、あるソリューションのあるRDF用語にバインドされます。しかし、すべてのRDFグラフにおいて、正規の、完全な構成を想定することはできません。情報が利用できるソリューションに情報を追加できるクエリを持つことができると便利ですが、クエリ・パターンの一部がマッチしないという理由でソリューションを拒絶すべきではありません。オプションのマッチングは、この機能を提供します。オプション部分がマッチしない場合は、バインディングを作成しませんが、ソリューションは排除しません。</p>

<div class="div2">

<h3>
<a name="OptionalMatching" id="OptionalMatching"></a>6.1 オプションのパターン・マッチング</h3>

<p>グラフ・パターンのオプション部分は、次のグラフ・パターンに当てはまるOPTIONALキーワードで構文的に指定されます。</p>

<pre class="query untested"><i>pattern</i> OPTIONAL { <i>pattern</i> }</pre>
<div class="exampleGroup">

<p>構文形式</p>

<pre class="query untested">{ OPTIONAL { <i>pattern</i> } }</pre>

<p>は次と同等です。</p>

<pre class="query untested">{ { } OPTIONAL { <i>pattern</i> } }</pre>

<p><code>OPTIONAL</code>キーワードは左結合的で、</p>

<pre class="query untested"><i>pattern</i> OPTIONAL { <i>pattern</i> } OPTIONAL { pattern }</pre>

<p>次と同じです。</p>

<pre class="query untested">{ <i>pattern</i> OPTIONAL { <i>pattern</i> } } OPTIONAL { pattern }</pre>

<p>オプションのマッチでは、オプションのグラフ・パターンがグラフにマッチし、その結果、1つ以上のソリューションに対し、バインディングを定義し追加するか、追加のバインディングを加えずにソリューションをそのままにします。</p>

<p>データ:</p>

<pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix rdf:        &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .

_:a  rdf:type        foaf:Person .
_:a  foaf:name       "Alice" .
_:a  foaf:mbox       &lt;mailto:alice@example.com&gt; .
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  rdf:type        foaf:Person .
_:b  foaf:name       "Bob" .</pre>
<div class="queryGroup">
    クエリ:
<pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE  { ?x foaf:name  ?name .
         OPTIONAL { ?x  foaf:mbox  ?mbox }
       }</pre>

<p>上記のデータを用いると、クエリ結果は次の通りです。</p>

<div class="result">
<a name="table92" id="table92"></a>

<table class="resultTable">
  <tr>
    <th>name</th>
    <th>mbox</th>
  </tr>
  <tr>
    <td>"Alice"</td>
    <td>&lt;mailto:alice@example.com&gt;</td>
  </tr>
  <tr>
    <td>"Alice"</td>
    <td>&lt;mailto:alice@work.example&gt;</td>
  </tr>
  <tr>
    <td>"Bob"</td>
    <td></td>
  </tr>
</table>

</div>
</div>
</div>

<p>名前が<code>"Bob"</code>であるソリューションの<code>mbox</code>の値はありません。</p>

<p>このクエリはデータ内の人名を発見します。述語<code>mbox</code>と、同じ主語を持つトリプルがある場合、ソリューションにはそのトリプルの目的語も含まれるでしょう。この例では、クエリのオプションのマッチ部分では1つのトリプル・パターンのみが得られますが、一般に、オプションの部分は任意のグラフ・パターンでありえます。オプションのグラフ・パターンの全体は、クエリのソリューションに影響するように、オプションのグラフ・パターンにマッチしなければなりません。</p>

</div>
<div class="div2">

<h3>
<a name="OptionalAndConstraints" id="OptionalAndConstraints"></a>6.2 オプションのパターン・マッチングにおける制約</h3>

<p>オプションのグラフ・パターンでは、制約を付与できます。例えば、次のとおりです。</p>

<div class="exampleGroup">

<pre class="data">@prefix dc:   &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix :     &lt;http://example.org/book/&gt; .
@prefix ns:   &lt;http://example.org/ns#&gt; .

:book1  dc:title  "SPARQL Tutorial" .
:book1  ns:price  42 .
:book2  dc:title  "The Semantic Web" .
:book2  ns:price  23 .</pre>
<div class="queryGroup">

<pre class="query">PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  ns:  &lt;http://example.org/ns#&gt;
SELECT  ?title ?price
WHERE   { ?x dc:title ?title .
          OPTIONAL { ?x ns:price ?price . FILTER (?price &lt; 30) }
        }</pre>
<div class="result">
<a name="table93" id="table93"></a>

<table class="resultTable">
  <tr>
    <th>title</th>
    <th>price</th>
  </tr>
  <tr>
    <td>"SPARQL Tutorial"</td>
    <td></td>
  </tr>
  <tr>
    <td>"The Semantic Web"</td>
    <td>23</td>
  </tr>
</table>

</div>
</div>
</div>

<p>「SPARQL Tutorial」というタイトルの本には、価格が表示されません。なぜならば、オプションのグラフ・パターンが変数「<code>price</code>」を伴うソリューションをもたらさなかったからです。</p>

</div>
<div class="div2">

<h3>
<a name="MultipleOptionals" id="MultipleOptionals"></a>6.3 複数のオプションのグラフ・パターン</h3>

<p>グラフ・パターンは再帰的に定義されます。グラフ・パターンは0以上のオプションのグラフ・パターンを持つことができ、クエリ・パターンのどの部分もオプション部分を持つことができます。この例には、2つのオプションのグラフ・パターンがあります。</p>

<div class="exampleGroup">
  データ:<pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice" .
_:a  foaf:homepage   &lt;http://work.example.org/alice/&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       &lt;mailto:bob@work.example&gt; .</pre>
<div class="queryGroup">
クエリ:
<pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox ?hpage
WHERE  { ?x foaf:name  ?name .
         OPTIONAL { ?x foaf:mbox ?mbox } .
         OPTIONAL { ?x foaf:homepage ?hpage }
       }</pre>

<p>クエリ結果:</p>

<div class="result">
<a name="table94" id="table94"></a>

<table class="resultTable">
  <tr>
    <th>name</th>
    <th>mbox</th>
    <th>hpage</th>
  </tr>
  <tr>
    <td>"Alice"</td>
    <td></td>
    <td>&lt;http://work.example.org/alice/&gt;</td>
  </tr>
  <tr>
    <td>"Bob"</td>
    <td>&lt;mailto:bob@work.example&gt;</td>
    <td></td>
  </tr>
</table>

</div>
</div>
</div>
</div>
</div>
<div class="div1">

<h2>
<a name="alternatives" id="alternatives"></a>7 代替のマッチング</h2>

<p>SPARQLは、いくつかの代替グラフ・パターンの1つがマッチするようにグラフ・パターンを組み合わせる方法を備えています。1つ以上の代替がマッチすれば、すべてのありえるパターンのソリューションが見つかります。</p>

<p>パターン代替は、<code>UNION</code>キーワードで構文的に指定されます。</p>

<div class="exampleGroup">
データ:
<pre class="data">@prefix dc10:  &lt;http://purl.org/dc/elements/1.0/&gt; .
@prefix dc11:  &lt;http://purl.org/dc/elements/1.1/&gt; .

_:a  dc10:title     "SPARQL Query Language Tutorial" .
_:a  dc10:creator   "Alice" .

_:b  dc11:title     "SPARQL Protocol Tutorial" .
_:b  dc11:creator   "Bob" .

_:c  dc10:title     "SPARQL" .
_:c  dc11:title     "SPARQL (updated)" .</pre>
<div class="queryGroup">
クエリ:
<pre class="query">PREFIX dc10:  &lt;http://purl.org/dc/elements/1.0/&gt;
PREFIX dc11:  &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?title
WHERE  { { ?book dc10:title  ?title } UNION { ?book dc11:title  ?title } }</pre>

<p>クエリ結果:</p>

<div class="result">
<a name="table97" id="table97"></a>

<table class="resultTable">
  <tr>
    <th>title</th>
  </tr>
  <tr>
    <td>"SPARQL Protocol Tutorial"</td>
  </tr>
  <tr>
    <td>"SPARQL"</td>
  </tr>
  <tr>
    <td>"SPARQL (updated)"</td>
  </tr>
  <tr>
    <td>"SPARQL Query Language Tutorial"</td>
  </tr>
</table>

</div>
</div>

<p>このクエリは、バージョン1.0、バージョン1.1のどちらの<a class="inform" href="dublincore.org/">ダブリン・コア</a>のプロパティーを用いてタイトルが記録されているかに関係なく、データ中の本のタイトルを発見します。情報の記録方法を厳密に判別するために、クエリは2つの代替に対して異なる変数を用いることができます。</p>

<div class="queryGroup">

<pre class="query">PREFIX dc10:  &lt;http://purl.org/dc/elements/1.0/&gt;
PREFIX dc11:  &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?x ?y
WHERE  { { ?book dc10:title ?x } UNION { ?book dc11:title  ?y } }</pre>
<div class="result">
<a name="table98" id="table98"></a>

<table class="resultTable">
  <tr>
    <th>x</th>
    <th>y</th>
  </tr>
  <tr>
    <td></td>
    <td>"SPARQL (updated)"</td>
  </tr>
  <tr>
    <td></td>
    <td>"SPARQL Protocol Tutorial"</td>
  </tr>
  <tr>
    <td>"SPARQL"</td>
    <td></td>
  </tr>
  <tr>
    <td>"SPARQL Query Language Tutorial"</td>
    <td></td>
  </tr>
</table>

</div>
</div>

<p>これは、<code>UNION</code>の左辺のソリューションにバインドされた変数<code>x</code>と、右辺のソリューションにバインドされた<code>y</code>を持った結果を返すでしょう。<code>UNION</code>パターンのどちらの部分にもマッチしない場合、グラフ・パターンはマッチしないでしょう。</p>

<p><code>UNION</code>パターンはグラフ・パターンを組み合わせます。それぞれの代替に、1つ以上のトリプル・パターンを含むことができます。</p>

<div class="queryGroup">

<pre class="query">PREFIX dc10:  &lt;http://purl.org/dc/elements/1.0/&gt;
PREFIX dc11:  &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?title ?author
WHERE  { { ?book dc10:title ?title .  ?book dc10:creator ?author }
         UNION
         { ?book dc11:title ?title .  ?book dc11:creator ?author }
       }</pre>
<div class="result">
<a name="table99" id="table99"></a>

<table class="resultTable">
  <tr>
    <th>title</th>
    <th>author</th>
  </tr>
  <tr>
    <td>"SPARQL Query Language Tutorial"</td>
    <td>"Alice"</td>
  </tr>
  <tr>
    <td>"SPARQL Protocol Tutorial"</td>
    <td>"Bob"</td>
  </tr>
</table>

</div>
</div>
</div>

<p>ダブリン・コアの同じバージョンのタイトルと著者の両方の述語がある場合にのみ、このクエリは本にマッチするでしょう。</p>

</div>
<div class="div1">

<h2>
<a name="negation" id="negation"></a>8 否定</h2>

<p>SPARQLクエリ言語には、2つの形式の否定が組み込まれています。1つは、フィルタリング結果に基づくもので、グラフ・パターンがフィルタリングされるクエリ・ソリューションのコンテキストにおいてマッチするか否かに依存します。もう1つは、別のパターンと関係のあるソリューションの除外に基づくものです。</p>

<div class="div2">

<h3>
<a name="neg-pattern" id="neg-pattern"></a>8.1 グラフ・パターンを用いたフィルタリング</h3>

<p>クエリ・ソリューションのフィルタリングは、<code>FILTER</code>式内で<code>NOT EXISTS</code>と<code>EXISTS</code>を用いて行います。フィルタの範囲の規則が<a href="#scopeFilters">フィルタが出現するすべてのグループに適用される</a>ことに注意してください。</p>

<div class="div3">

<h4>
<a name="neg-notexists" id="neg-notexists"></a>8.1.1 パターンの不在に関するテスト</h4>

<p><code>NOT EXISTS</code>というフィルタ式は、フィルタが存在するグループ・グラフ・パターンの変数の値が与えられた場合に、グラフ・パターンがデータセットと一致するか否かをテストします。これによって、追加のバインディングは作成されません。</p>

<div class="exampleGroup">

<p>データ:</p>

<pre class="data">@prefix  :       &lt;http://example/&gt; .
@prefix  rdf:    &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix  foaf:   &lt;http://xmlns.com/foaf/0.1/&gt; .

:alice  rdf:type   foaf:Person .
:alice  foaf:name  "Alice" .
:bob    rdf:type   foaf:Person .     </pre>

<p>クエリ:</p>

<div class="queryGroup">

<pre class="query">PREFIX  rdf:    &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; 
PREFIX  foaf:   &lt;http://xmlns.com/foaf/0.1/&gt; 

SELECT ?person
WHERE 
{
    ?person rdf:type  foaf:Person .
    FILTER NOT EXISTS { ?person foaf:name ?name }
}     </pre>

<p>クエリ結果:</p>

<div class="result">

<table class="resultTable">
<tbody>
  <tr>
    <th>person</th>
  </tr>
  <tr>
    <td>&lt;http://example/bob&gt;</td>
  </tr>
</tbody>
</table>

</div>
</div>
</div>
</div>
<div class="div3">

<h4>
<a name="neg-exists" id="neg-exists"></a>8.1.2 パターンの存在に関するテスト</h4>

<p><code>EXISTS</code>というフィルタ式も提供されています。これは、データ内でパターンが発見できるか否かをテストします。これによって、追加のバインディングは作成されません。。</p>

<div class="exampleGroup">

<p>クエリ:</p>

<div class="queryGroup">

<pre class="query">PREFIX  rdf:    &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; 
PREFIX  foaf:   &lt;http://xmlns.com/foaf/0.1/&gt; 

SELECT ?person
WHERE 
{
    ?person rdf:type  foaf:Person .
    FILTER EXISTS { ?person foaf:name ?name }
}</pre>

<p>クエリ結果:</p>

<div class="result">

<table class="resultTable">
<tbody>
  <tr>
    <th>person</th>
  </tr>
  <tr>
    <td>&lt;http://example/alice&gt;</td>
  </tr>
</tbody>
</table>

</div>
</div>
</div>
</div>
</div>
<div class="div2">

<h3>
<a name="neg-minus" id="neg-minus"></a>8.2 ソリューションの除外</h3>

<p>SPARQLが提供する別の形式の否定は<code>MINUS</code>で、両方の引数を評価した後に、右側のソリューションと互換性がない左側のソリューションを割り出します。</p>

<div class="exampleGroup">
データ:
<pre class="data">@prefix :       &lt;http://example/&gt; .
@prefix foaf:   &lt;http://xmlns.com/foaf/0.1/&gt; .

:alice  foaf:givenName "Alice" ;
        foaf:familyName "Smith" .

:bob    foaf:givenName "Bob" ;
        foaf:familyName "Jones" .

:carol  foaf:givenName "Carol" ;
        foaf:familyName "Smith" .</pre>
<div class="queryGroup">
クエリ:
<pre class="query">PREFIX :       &lt;http://example/&gt;
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT DISTINCT ?s
WHERE {
   ?s ?p ?o .
   MINUS {
      ?s foaf:givenName "Bob" .
   }
}</pre>

<p>結果:</p>

<div class="result">

<table class="resultTable">
  <tr>
    <th>s</th>
  </tr>
  <tr>
    <td>&lt;http://example/carol&gt;</td>
  </tr>
  <tr>
    <td>&lt;http://example/alice&gt;</td>
  </tr>
</table>

</div>
</div>
</div>
</div>
<div class="div2">

<h3>
<a name="neg-notexists-minus" id="neg-notexists-minus"></a>8.3 NOT EXISTSとMINUSの関係と違い</h3>

<p><code>NOT EXISTS</code>と<code>MINUS</code>は、否定に関する2つの考え方を表しています。1つは、バインディングがクエリ・パターンによって既に決定されている場合に、データ内にパターンが存在するか否かのテストに基づくもので、もう1つは、2つのパターンの評価に基づくマッチの除外に基づくものです。場合によっては、これらは異なる答えを出す可能性があります。</p>

<div class="div3">

<h4>
<a name="neg-example-1" id="neg-example-1"></a>8.3.1 例: 変数の共有</h4>

<pre class="data">@prefix : &lt;http://example/&gt; .
:a :b :c .</pre>

<pre class="query">SELECT *
{ 
  ?s ?p ?o
  FILTER NOT EXISTS { ?x ?y ?z }
}</pre>

<p>これは、<code>{ ?x ?y ?z }</code>が任意の<code>?s ?p ?o</code>とマッチし、したがって、<code>NOT EXISTS { ?x ?y ?z }</code>が任意のソリューションを排除するため、ソリューションのない結果集合となります。</p>

<div class="result">

<table class="resultTable">
  <tr>
    <th>s</th>
    <th>p</th>
    <th>o</th>
  </tr>
</table>

</div>

<p>一方で、<code>MINUS</code>の場合、最初の（<code>?s ?p ?o</code>）と2番目の（<code>?x ?y ?z</code>）との間には共有する変数がないため、バインディングは排除されません。</p>

<pre class="query">SELECT *
{ 
   ?s ?p ?o 
   MINUS 
     { ?x ?y ?z }
}</pre>

<p>結果:</p>

<div class="result">

<table class="resultTable">
  <tr>
    <th>s</th>
    <th>p</th>
    <th>o</th>
  </tr>
  <tr>
    <td>&lt;http://example/a&gt;</td>
    <td>&lt;http://example/b&gt;</td>
    <td>&lt;http://example/c&gt;</td>
  </tr>
</table>

</div>
</div>
<div class="div3">

<h4>
<a name="neg-example-2" id="neg-example-2"></a>8.3.2 例: 固定パターン</h4>

<p>別のケースは、例に具体的なパターン（変数ではない）がある場合です。</p>

<pre class="query">PREFIX : &lt;http://example/&gt;
SELECT * 
{ 
  ?s ?p ?o 
  FILTER NOT EXISTS { :a :b :c }
}</pre>

<p>これは、クエリ・ソリューションのない結果集合となります。</p>

結果:
<div class="result">

<table class="resultTable">
  <tr>
    <th>s</th>
    <th>p</th>
    <th>o</th>
  </tr>
</table>

</div>

<p>一方で、</p>

<pre class="query">PREFIX : &lt;http://example/&gt;
SELECT * 
{ 
  ?s ?p ?o 
  MINUS { :a :b :c }
}</pre>

<p>は、1つのクエリ・ソリューションがある結果集合となります。</p>

<p>結果:</p>

<div class="result">

<table class="resultTable">
  <tr>
    <th>s</th>
    <th>p</th>
    <th>o</th>
  </tr>
  <tr>
    <td>&lt;http://example/a&gt;</td>
    <td>&lt;http://example/b&gt;</td>
    <td>&lt;http://example/c&gt;</td>
  </tr>
</table>

</div>

<p>これは、バインディングのマッチがなく、したがって、ソリューションが排除されないためです。</p>

</div>
<div class="div3">

<h4>
<a name="idp899488" id="idp899488"></a>8.3.3 例: 内部FILTER</h4>

<p>フィルタでは、グループからの変数が<a href="#scopeFilters">範囲内</a>（in scope）であるという理由からも、違いは生じます。この例では、<code>NOT EXISTS</code>内の<code>FILTER</code>は、対象のソリューションに対し?nという値を利用できます。</p>

<pre class="data">@prefix : &lt;http://example.com/&gt; .
:a :p 1 .
:a :q 1 .
:a :q 2 .

:b :p 3.0 .
:b :q 4.0 .
:b :q 5.0 .</pre>

<p><code>FILTER NOT EXISTS</code>を用いた場合、テストは、<code>?x :p ?n</code>の個々のソリューションに関するものです。</p>

<pre class="query">PREFIX : &lt;http://example.com/&gt;
SELECT * WHERE {
        ?x :p ?n
        FILTER NOT EXISTS {
                ?x :q ?m .
                FILTER(?n = ?m)
        }
}</pre>
<div class="result">

<table class="resultTable">
  <tr>
    <th>x</th>
    <th>n</th>
  </tr>
  <tr>
    <td>&lt;http://example.com/b&gt;</td>
    <td>3.0</td>
  </tr>
</table>

</div>

<p>一方で、<code>MINUS</code>の場合、パターン内の<code>FILTER</code>は、?nに対する値を持たず、常にバインドされません。</p>

<pre class="query">PREFIX : &lt;http://example/&gt;
SELECT * WHERE {
        ?x :p ?n
        MINUS {
                ?x :q ?m .
                FILTER(?n = ?m)
        }
}</pre>
<div class="result">

<table class="resultTable">
  <tr>
    <th>x</th>
    <th>n</th>
  </tr>
  <tr>
    <td>&lt;http://example.com/b&gt;</td>
    <td>3.0</td>
  </tr>
  <tr>
    <td>&lt;http://example.com/a&gt;</td>
    <td>1</td>
  </tr>
</table>

</div>
</div>
</div>
</div>
<div class="div1">

<h2>
<a name="propertypaths" id="propertypaths"></a>9 プロパティー・パス</h2>

<p>プロパティー・パスは、2つのグラフ・ノード間のグラフ上の経路です。簡単な例は、きっかり1の長さのプロパティー・パスで、これはトリプル・パターンです。パスの終点は、RDF用語か変数でありえます。変数をパス自体の一部として用いることはできず、終点としてのみ用いることができます。</p>

<p>プロパティー・パスにより、一部のSPARQLの基本グラフ・パターンに対し、より簡潔な表現が可能となり、任意の長さのパスで2つの資源の連結とマッチする性能が追加されます。</p>

<div class="div2">

<h3>
<a name="pp-language" id="pp-language"></a>9.1 プロパティー・パス構文</h3>

<p>下記の記述では、<i><tt>iri</tt></i>は、<a href="#QSynIRI">完全形か接頭辞付き名前で省略したIRI</a>、または、キーワード<tt>a</tt>のいずれかです。<i><tt>elt</tt></i>はパス要素で、それ自体をパス構成子で構成することができます。</p>

<table border="1" cellspacing="0">
<tbody>
  <tr>
    <th>構文形式</th>
    <th>プロパティー・パス式名</th>
    <th>マッチ</th>
  </tr>
  <tr>
    <td><tt><i>iri</i></tt></td>
    <td>PredicatePath</td>
    <td>IRI。長さ1のパス。</td>
  </tr>
  <tr>
    <td><tt>^<i>elt</i></tt></td>
    <td>InversePath</td>
    <td>逆パス（主語から述語)。</td>
  </tr>
  <tr>
    <td><tt><i>elt1</i> / <i>elt2</i></tt></td>
    <td>SequencePath</td>
    <td>
<tt><i>elt2</i></tt>が後続する<tt><i>elt1</i></tt>のシーケンス・パス。</td>
  </tr>
  <tr>
    <td> <tt><i>elt1</i> | <i>elt2</i></tt>
</td>
    <td>AlternativePath</td>
    <td>
<tt><i>elt1</i></tt>または<tt><i>elt2</i></tt>の代替パス（すべての可能性が試みられる）。</td>
  </tr>
  <tr>
    <td><tt><i>elt</i>*</tt></td>
    <td>ZeroOrMorePath</td>
    <td>0以上の<tt><i>elt</i></tt>のマッチでパスの主語と目的語を結合するパス。</td>
  </tr>
  <tr>
    <td><tt><i>elt</i>+</tt></td>
    <td>OneOrMorePath</td>
    <td>1つ以上の<tt><i>elt</i></tt>のマッチでパスの主語と目的語を結合するパス。</td>
  </tr>
  <tr>
    <td><tt><i>elt</i>?</tt></td>
    <td>ZeroOrOnePath</td>
    <td>0または1つの<tt><i>elt</i></tt>のマッチでパスの主語と目的語を結合するパス。</td>
  </tr>
  <tr>
    <td>
<tt>!<i>iri</i></tt> or <tt>!(<i>iri<sub>1</sub></i>| ...|<i>iri<sub>n</sub></i>)</tt>
</td>
    <td>NegatedPropertySet</td>
    <td>否定のプロパティー集合。<tt><i>iri<sub>i</sub></i></tt>の1つではないIRI。<tt>!<i>iri</i></tt>は<tt>!<i>(iri)</i></tt>の省略形。</td>
  </tr>
  <tr>
    <td>
<tt>!^<i>iri</i></tt> or <tt>!(^<i>iri<sub>1</sub></i>| ...|^<i>iri<sub>n</sub></i>)</tt>
</td>
    <td>NegatedPropertySet</td>
    <td>除外されたマッチが逆パスに基づく場合の、否定のプロパティー集合。<br>
つまり、逆パスとして<i>iri<sub>1</sub></i>...<i>iri<sub>n</sub></i>の1つではない。<tt>!^<i>iri</i></tt>は、<tt>!(^<i>iri</i>)</tt>の省略形。</td>
  </tr>
  <tr>
    <td><tt>!(<i>iri<sub>1</sub></i>| ...|<i>iri<sub>j</sub></i>|^<i>iri<sub>j+1</sub></i>| ...|^<i>iri<sub>n</sub></i>)</tt></td>
    <td>NegatedPropertySet</td>
    <td>否定のプロパティー集合のforwardおよびreverseプロパティーの組み合わせ。</td>
  </tr>
  <tr>
    <td><tt>(<i>elt</i>)</tt></td>
    <td></td>
    <td>グループ・パス<tt><i>elt</i></tt>、括弧コントロール優先。</td>
  </tr>
</tbody>
</table>

<p>否定のプロパティー集合のIRIや逆のIRIの順序は重要ではなく、それらは混在した順序で出現する場合があります。</p>

<p>構文形式の優先順位は、次の上から下への順です。</p>

<ul>
  <li>IRI、接頭辞名</li>
  <li>否定のプロパティー集合</li>
  <li>グループ</li>
  <li>単項演算子 <tt>*</tt>、<tt>?</tt>、<tt>+</tt>
</li>
  <li>単項 ^逆リンク</li>
  <li>二項演算子 <tt>/</tt>
</li>
  <li>二項演算子 <tt>|</tt>
</li>
</ul>

<p>グループ内の優先順位は、左から右です。</p>

</div>
<div class="div2">

<h3>
<a name="propertypath-examples" id="propertypath-examples"></a>9.2 例</h3>

<p><i>選択肢</i>: 片方または両方とマッチします。</p>

<pre class="query">  { :book1 dc:title|rdfs:label ?displayString }</pre>

<p>これは、次のように記述することが可能でした。</p>

<pre class="query">  { :book1 &lt;http://purl.org/dc/elements/1.1/title&gt; | &lt;http://www.w3.org/2000/01/rdf-schema#label&gt; ?displayString }</pre>

<p><i>シーケンス</i>: アリスが知っているあらゆる人々の名前を見つけます。</p>

<pre class="query">  {
    ?x foaf:mbox &lt;mailto:alice@example&gt; .
    ?x foaf:knows/foaf:name ?name .
  }</pre>

<p><i>シーケンス</i>: 「<tt>foaf:knows</tt>」が2リンク離れた人々の名前を見つけます。</p>

<pre class="query">  { 
    ?x foaf:mbox &lt;mailto:alice@example&gt; .
    ?x foaf:knows/foaf:knows/foaf:name ?name .
  }</pre>

<p>これは、次のSPARQLクエリと同じです。</p>

<pre class="query">  SELECT ?x ?name 
  {
     ?x  foaf:mbox &lt;mailto:alice@example&gt; .
     ?x  foaf:knows [ foaf:knows [ foaf:name ?name ]]. 
  }</pre>

<p>あるいは、変数を明示的に用いると、次のとおりです。</p>

<pre class="query">  SELECT ?x ?name
  {
    ?x  foaf:mbox &lt;mailto:alice@example&gt; .
    ?x  foaf:knows ?a1 .
    ?a1 foaf:knows ?a2 .
    ?a2 foaf:name ?name .
  }</pre>

<p><i>重複のフィルタリング</i>: アリスが知っている人はおそらくアリスを知っているため、上記の例にはアリス自身が含まれている可能性があります。これは、次の方法で回避できます。</p>

<pre class="query">  { ?x foaf:mbox &lt;mailto:alice@example&gt; .
    ?x foaf:knows/foaf:knows ?y .
    FILTER ( ?x != ?y )
    ?y foaf:name ?name 
  }</pre>

<p><i>逆プロパティー・パス</i>: これらの2つは同じクエリです。2番目は、主語と目的語の役割を取り替え、プロパティーの方向を正反対にしています。</p>

<pre class="query">  { ?x foaf:mbox &lt;mailto:alice@example&gt; }</pre>

<pre class="query">  { &lt;mailto:alice@example&gt; ^foaf:mbox ?x }</pre>

<p><i>逆パス・シーケンス</i>: <tt>?x</tt>が知っている人を知っている人々をすべて見つけます。</p>

<pre class="query">  {
    ?x foaf:knows/^foaf:knows ?y .  
    FILTER(?x != ?y)
  }</pre>

<p>これは、次と同等です（<code>?gen1</code>はシステムが生成した変数）</p>

<pre class="query">  {
    ?x foaf:knows ?gen1 .
    ?y foaf:knows ?gen1 .  
    FILTER(?x != ?y)
  }</pre>

<p><i>任意の長さのマッチ</i>: <tt>foaf:knows</tt>によってアリスから到達可能なすべての人々の名前を見つけます。</p>

<pre class="query">  {
    ?x foaf:mbox &lt;mailto:alice@example&gt; .
    ?x foaf:knows+/foaf:name ?name .
  }</pre>

<p><i>任意の長さのパスの代替</i>:</p>

<pre class="query">  { ?ancestor (ex:motherOf|ex:fatherOf)+ &lt;#me&gt; }</pre>

<p><i>任意の長さのパス・マッチ</i>: 同じく、一部の制限付き推論の形式も可能です。例えば、RDFSの場合、資源のすべてのタイプとスーパータイプ:</p>

<pre class="query">  { &lt;http://example/thing&gt; rdf:type/rdfs:subClassOf* ?type }</pre>

<p>すべての資源およびそのすべての推論されるタイプ:</p>

<pre class="query">  { ?x rdf:type/rdfs:subClassOf* ?type }</pre>

<p><i>サブプロパティー</i>:</p>

<pre class="query">  { ?x ?p ?v . ?p rdfs:subPropertyOf* :property }</pre>

<p><i>否定のプロパティー・パス</i>: 結合しているノードを見つけますが、rdf:type（または、逆のrdf:type）によってではありません。</p>

<pre class="query">  { ?x !(rdf:type|^rdf:type) ?y }</pre>

<p><i>RDFコレクションの要素</i>:</p>

<pre class="query">  { :list rdf:rest*/rdf:first ?element }</pre>

<p><i>注意: このパス式では、結果の順序を保証されません。</i></p>

</div>
<div class="div2">

<h3>
<a name="propertypath-syntaxforms" id="propertypath-syntaxforms"></a>9.3 プロパティー・パスと同等パターン</h3>

<p>SPARQLプロパティー・パスは、RDFトリプルを、有向性の、巡回的である可能性のある、名前付きの辺を有するグラフとして扱います。一部のプロパティー・パスは、トリプル・パターンおよびSPARQL UNIONグラフ・パターンへの<a href="#sparqlTranslatePathExpressions">置換</a>と同等です。同等のパターンに導入された変数は結果の一部でなく、他では未使用であるため、プロパティー・パス式の評価は重複につながる場合があります。それらは、クエリで得られた変数のみへの結果の暗黙的な射影によって非表示になります。</p>

<p>例えば、次のデータでは:</p>

<pre class="data">@prefix :       &lt;http://example/&gt; .

:order  :item :z1 .
:order  :item :z2 .

:z1 :name "Small" .
:z1 :price 5 .

:z2 :name "Large" .
:z2 :price 5 .</pre>

<p>クエリ:</p>

<pre class="query">PREFIX :   &lt;http://example/&gt;
SELECT * 
{  ?s :item/:price ?x . }</pre>

<p>結果:</p>

<div class="result">

<table class="resultTable">
  <tr>
    <th>s</th>
    <th>x</th>
  </tr>
  <tr>
    <td>&lt;http://example/order&gt;</td>
    <td>5</td>
  </tr>
  <tr>
    <td>&lt;http://example/order&gt;</td>
    <td>5</td>
  </tr>
</table>

</div>

<p>一方で、クエリが中間変数（<code>?_a</code>）を含めるように記述されていれば、結果の中の列は重複しません。</p>

<pre class="query">PREFIX :   &lt;http://example/&gt;
SELECT * 
{  ?s :item ?_a .
   ?_a :price ?x . }</pre>

<p>結果:</p>

<div class="result">

<table class="resultTable">
  <tr>
    <th>s</th>
    <th>_a</th>
    <th>x</th>
  </tr>
  <tr>
    <td>&lt;http://example/order&gt;</td>
    <td>&lt;http://example/z1&gt;</td>
    <td>5</td>
  </tr>
  <tr>
    <td>&lt;http://example/order&gt;</td>
    <td>&lt;http://example/z2&gt;</td>
    <td>5</td>
  </tr>
</table>

</div>

<p>クエリに集約の操作も含まれている場合、グラフ・パターンに対する同等性は特に重要です。注文の総額は、以下のとおりです。</p>

<pre class="query">  PREFIX :   &lt;http://example/&gt;
  SELECT (sum(?x) AS ?total)
  { 
    :order :item/:price ?x
  }</pre>
<div class="result">
<table class="resultTable">
  <tr>
    <th>total</th>
  </tr>
  <tr>
    <td>10</td>
  </tr>
</table>

</div>
</div>
<div class="div2">

<h3>
<a name="propertypath-arbitrary-length" id="propertypath-arbitrary-length"></a>9.4 任意の長さのパス・マッチング</h3>

<p>任意の長さのプロパティー・パスによる主語と目的語の結合性は、「0以上」のプロパティー・パス演算子である<code>*</code>と、「1以上」のプロパティー・パス演算子である<code>+</code>を用いて見つけることができます。「0または1」の結合プロパティー・パス演算子である<code>?</code>もあります。</p>

<p>これらの個々の演算子は、演算子で制限されているとおりに、パスのステップを繰り返し用いて、プロパティー・パス式により主語と目的語の結合の発見を試みます。</p>

<p>例えば、資源のスーパータイプを含む、ありえるすべてのタイプの資源は、次の記述で発見できます。</p>

<pre class="query">  PREFIX  rdfs:   &lt;http://www.w3.org/2000/01/rdf-schema#&gt; . 
  PREFIX  rdf:    &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
  SELECT ?x ?type
  { 
    ?x rdf:type/rdfs:subClassOf* ?type
  }</pre>

<p>同様に、すべての人々<code>:x</code>の発見は、<code>foaf:knows</code>の関係により結合します。</p>

<pre class="query">  PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
  PREFIX :     &lt;http://example/&gt;
  SELECT ?person
  { 
    :x foaf:knows+ ?person
  }</pre>

<p>パスの繰り返し自体により重複が発生することはあっても、この結合性のマッチングにより重複が発生することはありません（これには、結合を生成できる方法の数は含まれてはいません）。</p>

<p>マッチしたグラフには、循環が含まれる可能性があります。結合性マッチングは、マッチングの循環によって、未定義や無限の結果が生じないように定義されています。</p>

</div>
</div>
<div class="div1">

<h2>
<a name="assignment" id="assignment"></a>10 割り当て</h2>

<p>新しい変数を式の値にバインドすることにより、式の値をソリューション・マッピングに追加することができ、これはRDF用語となります。その後、変数はクエリで使用でき、結果として返すこともできます。</p>

<p>
これは、<a href="#assignment"><code>BIND</code>キーワード</a>、 <a href="#selectExpressions"><code>SELECT</code>句の式</a>、<a href="#groupby"><code>GROUP BY</code>句の式</a>という3つの構文形式で可能です。割り当ての形式は、<code>(<i>expression</i> AS ?var)</code>です。</p>

<p>式の評価がエラーとなった場合には、変数はそのソリューションにバインドされないままとなりますが、クエリの評価は継続します。</p>

<p>直接<a href="#inline-data"><code>VALUES</code></a>をインライン・データに用いて、データをクエリに含むこともできます。</p>

<div class="div2">

<h3>
<a name="bind" id="bind"></a>10.1 BIND: 変数への割り当て</h3>

<p><code>BIND</code>形式により、基本グラフ・パターンまたはプロパティー・パス式の変数への値の割り当てが可能となります。<code>BIND</code>の使用によって、先行する基本グラフ・パターンは終了します。<code>BIND</code>句によって導入される変数が、<code>BIND</code>の使用前に、グループ・グラフ・パターンで使用されていることはありません。</p>

<p>例:</p>

<div class="exampleGroup">

<p>データ:</p>

<pre class="data">@prefix dc:   &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix :     &lt;http://example.org/book/&gt; .
@prefix ns:   &lt;http://example.org/ns#&gt; .

:book1  dc:title     "SPARQL Tutorial" .
:book1  ns:price     42 .
:book1  ns:discount  0.2 .

:book2  dc:title     "The Semantic Web" .
:book2  ns:price     23 .
:book2  ns:discount  0.25 .</pre>

<p>クエリ:</p>

<pre class="query">PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  ns:  &lt;http://example.org/ns#&gt;

SELECT  ?title ?price
{  ?x ns:price ?p .
   ?x ns:discount ?discount
   BIND (?p*(1-?discount) AS ?price)
   FILTER(?price &lt; 20)
   ?x dc:title ?title . 
}</pre>

<p>同等のクエリ（<code>BIND</code>により、基本グラフ・パターンは終了します。<code>FILTER</code>は、グループ・グラフ・パターンの全体に適用されます。）</p>

<pre class="query">PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  ns:  &lt;http://example.org/ns#&gt;

SELECT  ?title ?price
{  { ?x ns:price ?p .
     ?x ns:discount ?discount
     BIND (?p*(1-?discount) AS ?price)
   }
   {?x dc:title ?title . }
   FILTER(?price &lt; 20)
}</pre>

<p>結果:</p>

<div class="result">

<table class="resultTable">
  <tr>
    <th>title</th>
    <th>price</th>
  </tr>
  <tr>
    <td>?"The Semantic Web"</td>
    <td>17.25</td>
  </tr>
</table>

</div>
</div>
</div>
<div class="div2">

<h3>
<a name="inline-data" id="inline-data"></a>10.2 VALUES: インライン・データの提供</h3>

<p>データは、VALUESを用いて、グラフ・パターンに直接記述するか、クエリに追加することができます。<code>VALUES</code>は、インライン・データを、<a href="#defn_algJoin">join</a>オペレーションによるクエリ評価の結果と結合した<a href="#defn_sparqlSolutionSequence">ソリューション・シーケンス</a>として提供します。これは、アプリケーションに用いてクエリ結果に特定の要件を提供することができ、また、<code>SERVICE</code>キーワードで<a href="#basic-federated-query">統合クエリ</a>を提供するSPARQLのクエリ・エンジンの実装に用いて、遠隔のクエリ・サービスに対してより制約のあるクエリを送信することもできます。</p>

<div class="div3">

<h4>
<a name="inline-data-syntax" id="inline-data-syntax"></a>10.2.1 VALUES構文</h4>

<p><code>VALUES</code>により、データ・ブロックで複数の変数を指定することができます。たった1つの変数と複数の値を指定するという一般的なケースに対しては、特別な構文があります。</p>

<p>次の例には、<code>?x</code>と<code>?y</code>の2つの変数から成る表があります。2列目には<code>?y</code>に対する値がありません。</p>

<pre class="data">VALUES (?x ?y) {
  (:uri1 1)
  (:uri2 UNDEF)
}</pre>

<p>別の方法として、次のように、1つの変数と複数の値がある場合、</p>

<pre class="data">VALUES ?z { "abc" "def" }</pre>

<p>これは、次の一般的な形式を用いるのと同じです。</p>

<pre class="data">VALUES (?z) { ("abc") ("def") }</pre>
</div>
<div class="div3">

<h4>
<a name="inline-data-examples" id="inline-data-examples"></a>10.2.2 VALUESの例</h4>

<p>データの<code>VALUES</code>ブロックは、クエリ・パターン、または、<a href="#subqueries">サブクエリ</a>を含む<code>SELECT</code>クエリの終点に出現可能です。</p>

<div class="exampleGroup">

<p>データ:</p>

<pre class="data">@prefix dc:   &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix :     &lt;http://example.org/book/&gt; .
@prefix ns:   &lt;http://example.org/ns#&gt; .

:book1  dc:title  "SPARQL Tutorial" .
:book1  ns:price  42 .
:book2  dc:title  "The Semantic Web" .
:book2  ns:price  23 .</pre>

<p>クエリ:</p>

<pre class="query">PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt; 
PREFIX :     &lt;http://example.org/book/&gt; 
PREFIX ns:   &lt;http://example.org/ns#&gt; 

SELECT ?book ?title ?price
{
   VALUES ?book { :book1 :book3 }
   ?book dc:title ?title ;
         ns:price ?price .
}</pre>

<p>結果:</p>

<div class="result">
<a name="table110" id="table110"></a>

<table class="resultTable">
  <tr>
    <th>book</th>
    <th>title</th>
    <th>price</th>
  </tr>
  <tr>
    <td>&lt;http://example.org/book/book1&gt;</td>
    <td>"SPARQL Tutorial"</td>
    <td>42</td>
  </tr>
</table>

</div>
</div>

<p><code>VALUES</code>句において、変数が特別なソリューションに対する値を持っていない場合は、RDF用語ではなくキーワード<code>UNDEF</code>が用いられます。</p>

<pre class="query">PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt; 
PREFIX :     &lt;http://example.org/book/&gt; 
PREFIX ns:   &lt;http://example.org/ns#&gt; 

SELECT ?book ?title ?price
{
   ?book dc:title ?title ;
         ns:price ?price .
   VALUES (?book ?title)
   { (UNDEF "SPARQL Tutorial")
     (:book2 UNDEF)
   }
}</pre>
<div class="result">
<a name="table111" id="table111"></a>

<table class="resultTable">
  <tr>
    <th>book</th>
    <th>title</th>
    <th>price</th>
  </tr>
  <tr>
    <td>&lt;http://example.org/book/book1&gt;</td>
    <td>"SPARQL Tutorial"</td>
    <td>42</td>
  </tr>
  <tr>
    <td>&lt;http://example.org/book/book2&gt;</td>
    <td>"The Semantic Web"</td>
    <td>23</td>
  </tr>
</table>

</div>

<p>この例では、<code>VALUES</code>は<code>SELECT</code>クエリの結果に対して実行するように指定されていたかもしれません。</p>

<pre class="query">PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt; 
PREFIX :     &lt;http://example.org/book/&gt; 
PREFIX ns:   &lt;http://example.org/ns#&gt; 

SELECT ?book ?title ?price
{
   ?book dc:title ?title ;
         ns:price ?price .
}
VALUES (?book ?title)
{ (UNDEF "SPARQL Tutorial")
  (:book2 UNDEF)
}</pre>

<p>これは異なるクエリですが、この例では、同じ結果となります。</p>

</div>
</div>
</div>
<div class="div1">

<h2>
<a name="aggregates" id="aggregates"></a>11 集約</h2>

<p>集約（aggregate）は、グループのソリューションに対して式を適用します。デフォルトでは、ソリューションの集合は1つのグループで構成され、すべてのソリューションを含んでいます。</p>

<p>グループは、<code>GROUP BY</code>構文で指定できます。</p>

<p>SPARQLのバージョン1.1で定義されている集約は、<code>COUNT</code>、<code>SUM</code>、<code>MIN</code>、<code>MAX</code>、<code>AVG</code>、<code>GROUP_CONCAT</code>と<code>SAMPLE</code>です。</p>

<p>集約は、クエリの実行者が、1つのソリューションではなく、ソリューションのグループに対する演算結果を求めている場合に用いられます。例えば、個々の値ではなく、特定の変数が取る最大値などです。</p>

<div class="div2">

<h3>
<a name="aggregateExample" id="aggregateExample"></a>11.1 集約の例</h3>
<div class="exampleGroup">

<p>データ:</p>

<pre class="data">@prefix : &lt;http://books.example/&gt; .

:org1 :affiliates :auth1, :auth2 .
:auth1 :writesBook :book1, :book2 .
:book1 :price 9 .
:book2 :price 5 .
:auth2 :writesBook :book3 .
:book3 :price 7 .
:org2 :affiliates :auth3 .
:auth3 :writesBook :book4 .
:book4 :price 7 .</pre>

<p>クエリ:</p>

<pre class="query">PREFIX : &lt;http://books.example/&gt;
SELECT (SUM(?lprice) AS ?totalPrice)
WHERE {
  ?org :affiliates ?auth .
  ?auth :writesBook ?book .
  ?book :price ?lprice .
}
GROUP BY ?org
HAVING (SUM(?lprice) &gt; 10)</pre>

<p>結果:</p>

<div class="result">

<table class="resultTable">
  <tr>
    <th>totalPrice</th>
  </tr>
  <tr>
    <td>21</td>
  </tr>
</table>

</div>
</div>

<p>この例では、集約の2つの機能を示しています。<code>GROUP BY</code>は、1つ以上の式（このケースでは、<code>?org</code>）に従ってクエリ・ソリューションをグループ化します。また、<code>HAVING</code>は、<code>FILTER</code>式に似てていますが、個々のソリューションではなくグループに対して機能します。</p>

<p>例は、<code>GROUP BY</code>式でソリューションをグループ化し（つまり、<code>?org</code>が特定の値を取るすべてのソリューションは、同じグループ内に出現する）、そのグループに対し集合関数<code>SUM</code>で評価して作成されています。その後、グループは<code>HAVING</code>式でフィルタリングされ、<code>SUM(?lprice)</code>によって、10以下のグループがすべて削除されます。</p>

<p>集約クエリとサブクエリでは、クエリ・パターンには出現するけれども<code>GROUP BY</code>句内には存在しない変数は、集約される場合には、単に射影することも、選択式で使用することもできます。<code>SAMPLE</code>集約は、この目的に使用できます。詳細については、<a href="#aggregateRestrictions">射影制限</a>の項を参照してください。</p>

<p><a href="#selectExpressions">関数に従って</a>、クエリまたはサブクエリから射影するためには、集約式を別名にする必要がある（ここでも、<code>BIND</code>句と同様に、キーワード<code>AS</code>を用いる）ということに注意すべきです。上例では、これは変数<code>?totalPrice</code>を用いて行われます。他の集約の射影や<code>WHERE</code>句で既に使用されている名前を有する変数を集約が射影するとエラーとなります。</p>

</div>
<div class="div2">

<h3>
<a name="groupby" id="groupby"></a>11.2 GROUP BY</h3>

<p>ソリューションに対する集約の値を計算するため、最初にソリューションを1つ以上のグループに分割し、各グループに対して集約の値を算出します。</p>

<p>集約が<code>SELECT</code>、<code>HAVING</code>や<code>ORDER BY</code>のクエリ・レベルで用いられていても、<code>GROUP BY</code>用語が用いられていなければ、すべてのソリューションが属する1つの暗黙的なグループと見なされます。</p>

<p><code>GROUP BY</code>句内では、バインディングのキーワード<code>AS</code>は、<code>GROUP BY (?x + ?y AS ?z)</code>のように使用できます。これは<code>{ ... BIND (?x + ?y AS ?z) } GROUP BY ?z</code>と同等です。</p>

<p>例えば、ソリューション・シーケンスS（{?x→2, ?y→3}, {?x→2, ?y→5}, {?x→6, ?y→7}）の場合、?xという値でソリューションをグループ化したいと思うかもしれませんし、グループごとに?yという値の平均を計算したいと思うかもしれません。</p>

<p>これは、次のように書くことができます。</p>

<pre class="query">SELECT (AVG(?y) AS ?avg)
WHERE {
  ?a :x ?x ;
     :y ?y .
}
GROUP BY ?x</pre>
</div>
<div class="div2">

<h3>
<a name="having" id="having"></a>11.3 HAVING</h3>

<p><code>FILTER</code>がグループ化されていないソリューション集合で機能するのと同じように、<code>HAVING</code>はグループ化されたソリューション集合で機能します。</p>

<p>次の項で述べているように、<code>HAVING</code>式にはグループ化されたクエリからの射影と同じ評価規則があります。</p>

<p><code>HAVING</code>の使用の一例を、以下で示しています。</p>

<pre class="query">PREFIX : &lt;http://data.example/&gt;
SELECT (AVG(?size) AS ?asize)
WHERE {
  ?x :size ?size
}
GROUP BY ?x
HAVING(AVG(?size) &gt; 10)</pre>

<p>これは、主語でグループ化されて、平均サイズを返すでしょうが、それは、平均サイズが10より大きい場合のみです。</p>

</div>
<div class="div2">

<h3>
<a name="aggregateRestrictions" id="aggregateRestrictions"></a>11.4 集約射影制限</h3>

<p>集約を用いたクエリ・レベルでは、1つの例外を除き、集約と定数で構成される式のみを射影できます。<code>GROUP BY</code>が、1つの変数のみで構成される1つ以上の単純式とともに与えられれば、それらの変数はレベルから射影できます。</p>

<p>例えば、?xが<code>GROUP BY</code>用語として与えられた場合、次のクエリは正当です。</p>

<pre class="query">PREFIX : &lt;http://example.com/data/#&gt;
SELECT ?x (MIN(?y) * 2 AS ?min)
WHERE {
  ?x :p ?y .
  ?x :q ?z .
} GROUP BY ?x (STR(?z))</pre>

<p>これは単純変数式でないため、<code>STR(?z)</code>を射影することが正当ではないだろうということに注意してください。しかし、<code>GROUP BY (STR(?z) AS ?strZ)</code>の場合、<code>?strZ</code>に射影できるでしょう。</p>

<p><code>GROUP BY</code>変数を用いていない他の式や集約は、<code>SAMPLE</code>集約を用いて、それらのグループから非確定的な値を射影できます。</p>

</div>
<div class="div2">

<h3>
<a name="aggregateExample2" id="aggregateExample2"></a>11.5 集約の例（エラーがある場合）</h3>

<p>この項では、集約を用いたクエリの例を示し、集約が存在する場合に、結果においてエラーがどのように扱われるかを例示します。</p>

<p>データ:</p>

<pre class="data">@prefix : &lt;http://example.com/data/#&gt; .

:x :p 1, 2, 3, 4 .
:y :p 1, _:b2, 3, 4 .:z :p 1.0, 2.0, 3.0, 4 .</pre>

<p>クエリ:</p>

<pre class="query">PREFIX : &lt;http://example.com/data/#&gt;
SELECT ?g (AVG(?p) AS ?avg) ((MIN(?p) + MAX(?p)) / 2 AS ?c)
WHERE {
  ?g :p ?p .
}
GROUP BY ?g</pre>

<p>結果:</p>

<div class="result">

<table class="resultTable">
  <tr>
    <th>g</th>
    <th>avg</th>
    <th>c</th>
  </tr>
  <tr>
    <td>&lt;http://example.com/data/#x&gt;</td>
    <td>2.5</td>
    <td>2.5</td>
  </tr>
  <tr>
    <td>&lt;http://example.com/data/#y&gt;</td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>&lt;http://example.com/data/#z&gt;</td>
    <td>2.5</td>
    <td>2.5</td>
  </tr>
</table>

</div>

<p>:yグループのバインディングがAvg({1, _:b2, 3, 4})の評価として結果に含まれておらず、(_:b2 + 4) / 2はエラーで、ソリューションからバインディングが削除されることに注意してください。</p>

</div>
</div>
<div class="div1">

<h2>
<a name="subqueries" id="subqueries"></a>12 サブクエリ</h2>

<p>サブクエリは通常、クエリ内の部分式の結果の数を制限するなど、他の方法では得られない結果を得るために、SPARQLクエリを他のクエリに組み込む方法です。</p>

<p>SPARQLクエリの評価にはボトム・アップの性質があるため、必然的にサブクエリが最初に評価され、その結果が外部のクエリに射影されます。</p>

<p>外部のクエリには、サブクエリから射影された変数のみが見える（または、<a href="#variableScope">範囲内</a>である）ことに注意してください。</p>

<h3 id="subquery-example">例</h3>

<p>データ:</p>

<div class="exampleGroup">

<pre class="data">@prefix : &lt;http://people.example/&gt; .

:alice :name "Alice", "Alice Foo", "A. Foo" .
:alice :knows :bob, :carol .
:bob :name "Bob", "Bob Bar", "B. Bar" .
:carol :name "Carol", "Carol Baz", "C. Baz" .</pre>

<p>アリスを知っており、名前を持っているすべての人に関し、名前（ソート順序が最下位もの）を返します。</p>

<p>クエリ:</p>

<pre class="query">PREFIX : &lt;http://people.example/&gt;
PREFIX : &lt;http://people.example/&gt;
SELECT ?y ?minName
WHERE {
  :alice :knows ?y .
  {
    SELECT ?y (MIN(?name) AS ?minName)
    WHERE {
      ?y :name ?name .
    } GROUP BY ?y
  }
}</pre>
</div>

<p>結果:</p>

<div class="result">

<table class="resultTable">
<tbody>
  <tr>
    <th>y</th>
    <th>minName</th>
  </tr>
  <tr>
    <td>:bob</td>
    <td>"B. Bar"</td>
  </tr>
  <tr>
    <td>:carol</td>
    <td>"C. Baz"</td>
  </tr>
</tbody>
</table>

</div>

<p>この結果は、最初に内部クエリを評価することで得られます。</p>

<pre class="query">SELECT ?y (MIN(?name) AS ?minName)
WHERE {
  ?y :name ?name .
} GROUP BY ?y</pre>

<p>これにより、次のソリューション・シーケンスが生成されます。</p>

<div class="result">

<table class="resultTable">
<tbody>
  <tr>
    <th>y</th>
    <th>minName</th>
  </tr>
  <tr>
    <td>:alice</td>
    <td>"A. Foo"</td>
  </tr>
  <tr>
    <td>:bob</td>
    <td>"B. Bar"</td>
  </tr>
  <tr>
    <td>:carol</td>
    <td>"C. Baz"</td>
  </tr>
</tbody>
</table>

</div>

<p>これは、次のように、外部クエリの結果と結合されます。</p>

<div class="result">

<table class="resultTable">
<tbody>
  <tr>
    <th>y</th>
  </tr>
  <tr>
    <td>:bob</td>
  </tr>
  <tr>
    <td>:carol</td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div1">

<h2>
<a name="rdfDataset" id="rdfDataset"></a>13 RDFデータセット</h2>

<p>RDFデータ・モデルは、主語、述語、目的語のトリプルから成るグラフとして情報を表します。多くのRDFデータを蓄積すると、複数のRDFグラフと各グラフに関する記録情報が保持され、それによって、アプリケーションは1つ以上のグラフの情報を含むクエリを作成できます。</p>

<p>SPARQLのクエリは、グラフのコレクションを表す<em>RDFデータセット</em>に対して実行されます。1つのRDFデータセットは、名前のない1つのグラフ（デフォルト・グラフ）と、名前付きグラフがそれぞれにIRIで識別される0以上の名前付きグラフから成ります。SPARQLのクエリは、<a href="#queryDataset">13.3 データセットのクエリ</a>の項で述べるように、クエリ・パターンの異なる部分を異なるグラフに対してマッチさせることができます。</p>

<p>RDFデータセットには、0の名前付きグラフを含むことができます。RDFデータセットには、常に1つのデフォルト・グラフが含まれます。クエリは、デフォルト・グラフのマッチングを含る必要はありません。クエリは、名前付きグラフのマッチングを含むことができるだけです。</p>

<p>基本グラフ・パターンをマッチングさせるために用いるグラフは、<i>アクティブ・グラフ</i>です。前項までは、すべてのクエリは、アクティブ・グラフとしてのRDFデータセットのデフォルト・グラフである、1つのグラフに対して実行したものを示してきました。<code>GRAPH</code>キーワードは、アクティブ・グラフを、クエリの一部に対するデータセット内のすべての名前付きグラフのうちの1つにするために用いられます。</p>

<div class="div2">

<h3>
<a name="exampleDatasets" id="exampleDatasets"></a>13.1 RDFデータセットの例</h3>

<p>RDFデータセットの定義は、名前付きグラフとデフォルト・グラフの関係を制限しません。異なるグラフで情報を繰り返すことができ、グラフ間の関係を公開できます。次の2つの有益な処理があります。</p>

<ul>
<li>名前付きグラフに関する来歴情報を含む情報をデフォルト・グラフに持つこと</li>
  <li>名前付きグラフの情報をデフォルト・グラフに含むこと</li>
</ul>
<div class="exampleGroup">
<b>例1:</b>

<pre class="data"># <b>Default graph</b>
@prefix dc: &lt;http://purl.org/dc/elements/1.1/&gt; .

&lt;http://example.org/bob&gt;    dc:publisher  "Bob" .
&lt;http://example.org/alice&gt;  dc:publisher  "Alice" .</pre>

<pre class="data"># <b>Named graph: http://example.org/bob</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Bob" .
_:a foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .</pre>

<pre class="data"># <b>Named graph: http://example.org/alice</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Alice" .
_:a foaf:mbox &lt;mailto:alice@work.example.org&gt; .</pre>
</div>

<p>この例では、デフォルト・グラフには、2つの名前付きグラフの公開者名が含まれています。名前付きグラフのトリプルは、この例のデフォルト・グラフでは表示されません。</p>

<p id="ex_2"><b>例2:</b></p>

<p>RDFデータは、グラフの<a class="norm" href="www.w3.org/TR/rdf-mt/#graphdefs">RDFマージ</a>[<a href="#RDF-MT">RDF-MT</a>]によって組み合わすことができます。RDFデータセットにおける、グラフの1つの可能な処理は、デフォルト・グラフを名前付きグラフの情報の一部またはすべてのRDFマージにすることです。</p>

<p>次の例では、名前付きグラフには、以前と同じトリプルが含まれています。RDFデータセットは、デフォルト・グラフに名前付きグラフのRDFマージを含んでおり、再ラベル付けを行って空白ノードを異なったものにしておきます。</p>

<div class="exampleGroup">

<pre class="data"># <b>Default graph</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:x foaf:name "Bob" .
_:x foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .

_:y foaf:name "Alice" .
_:y foaf:mbox &lt;mailto:alice@work.example.org&gt; .</pre>

<pre class="data"># <b>Named graph: http://example.org/bob</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Bob" .
_:a foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .</pre>

<pre class="data"># <b>Named graph: http://example.org/alice</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Alice" .
_:a foaf:mbox &lt;<a href="mailto:alice@work.example">mailto:alice@work.example</a>&gt; .</pre>

<p>RDFマージでは、マージされたグラフの空白ノードと、マージされているグラフからの空白ノードとは共有されません。</p>

</div>
</div>
<div class="div2">

<h3>
<a name="specifyingDataset" id="specifyingDataset"></a>13.2 RDFデータセットの指定</h3>

<p>SPARQLクエリは、RDFデータセットを記述するために、<code>FROM</code>句と<code>FROM NAMED</code>句を用いて、マッチングに用いるデータセットを指定できます。クエリがそのようなデータセットの記述を提供していれば、それは、データセットの記述がクエリで提供されない場合にクエリ・サービスが使用する任意のデータセットの代わりに使用しています。また、RDFデータセットは、<a class="inform" href="www.w3.org/TR/sparql11-protocol/">SPARQLプロトコル要求で指定</a>することもできます。その場合、プロトコルの記述により、クエリ自体のあらゆる記述は無効になります。クエリ・サービスがデータセットの記述を許容できない場合には、サービスはクエリ要求を拒否するかもしれません。</p>

<p><code>FROM</code>と<code>FROM NAMED</code>キーワードによって、クエリは参照によってRDFデータセットを指定できます。これは、データセットが、与えられたIRI（すなわち、与えられたIRI参照の絶対形式）によって識別された資源の表現から得られるグラフを含むべきであるということを示しています。いくつかの<code>FROM</code>と<code>FROM NAMED</code>句から生じるデータセットは次の通りです。</p>

<ul>
  <li>
<code>FROM</code>句で参照されたグラフのRDFマージから成るデフォルト・グラフ、および</li>
  <li>1組（IRI、グラフ）の対で、各<code>FROM NAMED</code>句から1つずつ。</li>
</ul>

<p><code>FROM</code>句はないけれども複数の<code>FROM NAMED</code>句がある場合は、データセットにはデフォルト・グラフに対する空のグラフが含まれています。</p>

<div class="div3">

<h4>
<a name="unnamedGraph" id="unnamedGraph"></a>13.2.1 デフォルト・グラフの指定</h4>

<p>各<code>FROM</code>句には、デフォルト・グラフを作成するために用いるグラフを示すIRIが含まれています。これは、グラフを名前付きグラフとして位置づけるものではありません。</p>

<p>この例では、RDFデータセットは、1つのデフォルト・グラフを含み、名前付きグラフを含んでいません。</p>

<div class="exampleGroup">

<pre class="data"><b># Default graph (located at http://example.org/foaf/aliceFoaf)
</b>@prefix  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name     "Alice" .
_:a  foaf:mbox     &lt;mailto:alice@work.example&gt; .</pre>
<div class="queryGroup">

<pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT  ?name
FROM    &lt;http://example.org/foaf/aliceFoaf&gt;
WHERE   { ?x foaf:name ?name }</pre>
<div class="result">
<a name="table102" id="table102"></a>

<table class="resultTable">
  <tr>
    <th>name</th>
  </tr>
  <tr>
    <td>"Alice"</td>
  </tr>
</table>

</div>
</div>
</div>

<p>クエリが1つ以上の<code>FROM</code>句を提供し、デフォルト・グラフを示すために1つ以上のIRIを提供する場合、デフォルト・グラフは与えられたIRIによって識別される資源の表現から得られたグラフの<a class="norm" href="www.w3.org/TR/rdf-mt/#graphdefs">RDFマージ</a>です。</p>

</div>
<div class="div3">

<h4>
<a name="namedGraphs" id="namedGraphs"></a>13.2.2 名前付きグラフの指定</h4>

<p><code>FROM NAMED</code>句を用いれば、クエリは、RDFデータセットの名前付きグラフにIRIを提供できます。各IRIは、RDFデータセットの1つの名前付きグラフを提供するために用いられます。2つ以上の<code>FROM NAMED</code>句で同じIRIを用いると、データセットに現れる当該IRIを持つ1つの名前付きグラフになります。</p>

<pre class="data"><b># Graph: http://example.org/bob</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Bob" .
_:a foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .</pre>

<pre class="data"><b># Graph: http://example.org/alice</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Alice" .
_:a foaf:mbox &lt;mailto:alice@work.example&gt; .</pre>
<div class="queryGroup">

<pre class="query">...
FROM NAMED &lt;http://example.org/alice&gt;
FROM NAMED &lt;http://example.org/bob&gt;
...</pre>
</div>

<p><code>FROM NAMED</code>構文は、IRIが対応するグラフを識別するということを示唆しますが、RDFデータセットのIRIとグラフとの関係は間接的です。IRIが資源を識別し、資源はグラフで（あるいは、より正確には、グラフをシリアル化したドキュメントで）表されます。<a class="inform" href="www.w3.org/TR/webarch/#intro">詳細</a>については[<a href="#WEBARCH">WEBARCH</a>]を参照してください。</p>

</div>
<div class="div3">

<h4>
<a name="specDataset" id="specDataset"></a>13.2.3 FROMとFROM NAMEDの結合</h4>

<p><code>FROM</code>句と<code>FROM NAMED</code>句は、同じクエリ内で使用できます。</p>

<div class="exampleGroup">

<pre class="data"># <b>Default graph (located at http://example.org/dft.ttl)
</b>@prefix dc: &lt;http://purl.org/dc/elements/1.1/&gt; .

&lt;http://example.org/bob&gt;    dc:publisher  "Bob Hacker" .
&lt;http://example.org/alice&gt;  dc:publisher  "Alice Hacker" .</pre>

<pre class="data"># <b>Named graph: http://example.org/bob</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Bob" .
_:a foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .</pre>

<pre class="data"># <b>Named graph: http://example.org/alice</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Alice" .
_:a foaf:mbox &lt;mailto:alice@work.example.org&gt; .</pre>

<pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?who ?g ?mbox
FROM &lt;http://example.org/dft.ttl&gt;
FROM NAMED &lt;http://example.org/alice&gt;
FROM NAMED &lt;http://example.org/bob&gt;
WHERE
{
   ?g dc:publisher ?who .
   GRAPH ?g { ?x foaf:mbox ?mbox }
}</pre>
</div>

<p>このクエリに対するRDFデータセットには、1つのデフォルト・グラフと2つの名前付きグラフが含まれています。<code>GRAPH</code>キーワードに関しては、以下で説明しています。</p>

<p>データセットを構築するために必要なアクションは、データセットの記述のみでは決められません。2つの<code>FROM</code>句、または、1つの<code>FROM</code>句と1つの<code>FROM NAMED</code>句を用いてデータセットの記述にIRIが2度付与されている場合は、きっかり1回または、きっかり2回の試みでIRIに関連付けられた1つのRDFグラフを得たとは想定しません。したがって、データセットの記述に存在する2つから得られたトリプル中の空白ノードのアイデンティティに関する想定を行えません。概して、グラフの同等性に関する想定を行えません。</p>

</div>
</div>
<div class="div2">

<h3>
<a name="queryDataset" id="queryDataset"></a>13.3 データセットのクエリ実行</h3>

<p>グラフのコレクションにクエリを実行する際には、<code>GRAPH</code>キーワードを用いて、名前付きグラフに対してパターンをマッチングさせます。<code>GRAPH</code>は、IRIを提供して1つのグラフを選択するか、クエリのRDFデータセット内のすべての名前付きグラフのIRIの範囲をカバーする変数を使用できます。</p>

<p><code>GRAPH</code>を用いれば、クエリのその一部でグラフ・パターンをマッチングさせるためのアクティブ・グラフが変更されます。<code>GRAPH</code>を用いない場合は、マッチングは、デフォルトのグラフを用いて行われます。</p>

<p>以下の例では、次の2つのグラフを用います。</p>

<div class="exampleGroup">

<pre class="data"><b># Named graph: http://example.org/foaf/aliceFoaf
</b>@prefix  foaf:     &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix  rdf:      &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix  rdfs:     &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .

_:a  foaf:name     "Alice" .
_:a  foaf:mbox     &lt;mailto:alice@work.example&gt; .
_:a  foaf:knows    _:b .

_:b  foaf:name     "Bob" .
_:b  foaf:mbox     &lt;mailto:bob@work.example&gt; .
_:b  foaf:nick     "Bobby" .
_:b  rdfs:seeAlso  &lt;http://example.org/foaf/bobFoaf&gt; .

&lt;http://example.org/foaf/bobFoaf&gt;
     rdf:type      foaf:PersonalProfileDocument .</pre>

<pre class="data"><b># Named graph: http://example.org/foaf/bobFoaf
</b>@prefix  foaf:     &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix  rdf:      &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix  rdfs:     &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .

_:z  foaf:mbox     &lt;mailto:bob@work.example&gt; .
_:z  rdfs:seeAlso  &lt;http://example.org/foaf/bobFoaf&gt; .
_:z  foaf:nick     "Robert" .

&lt;http://example.org/foaf/bobFoaf&gt;
     rdf:type      foaf:PersonalProfileDocument .</pre>
</div>
<div class="div3">

<h4>
<a name="accessByLabel" id="accessByLabel"></a>13.3.1 グラフ名へのアクセス</h4>

<p>次のクエリは、データセットの各名前付きグラフにグラフ・パターンをマッチングさせ、マッチしたグラフのIRIにバインドされた<code>src</code>変数を持つソリューションを作成します。グラフ・パターンは、データセットの各名前付きグラフであるアクティブ・グラフとマッチします。</p>

<div class="queryGroup">

<pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?src ?bobNick
FROM NAMED &lt;http://example.org/foaf/aliceFoaf&gt;
FROM NAMED &lt;http://example.org/foaf/bobFoaf&gt;
WHERE
  {
    GRAPH ?src
    { ?x foaf:mbox &lt;mailto:bob@work.example&gt; .
      ?x foaf:nick ?bobNick
    }
  }</pre>

<p>クエリの結果は、情報が発見されたグラフの名前と、Bobのnickの値を提示します。</p>

<div class="result">
<a name="table105" id="table105"></a>

<table class="resultTable">
  <tr>
    <th>src</th>
    <th>bobNick</th>
  </tr>
  <tr>
    <td>&lt;http://example.org/foaf/aliceFoaf&gt;</td>
    <td>"Bobby"</td>
  </tr>
  <tr>
    <td>&lt;http://example.org/foaf/bobFoaf&gt;</td>
    <td>"Robert"</td>
  </tr>
</table>

</div>
</div>
</div>
<div class="div3">

<h4>
<a name="restrictByLabel" id="restrictByLabel"></a>13.3.2 グラフIRIによる制限</h4>

<p>クエリは、グラフIRIの提供により、特定のグラフに適用されたマッチングを制限できます。これは、IRIで名前付けされたグラフに、アクティブ・グラフを設定します。このクエリは、グラフ <code>http://example.org/foaf/bobFoaf</code>で示されているように、Bobのnickを検索します。</p>

<div class="queryGroup">

<pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX data: &lt;http://example.org/foaf/&gt;

SELECT ?nick
FROM NAMED &lt;http://example.org/foaf/aliceFoaf&gt;
FROM NAMED &lt;http://example.org/foaf/bobFoaf&gt;
WHERE
  {
     GRAPH data:bobFoaf {
         ?x foaf:mbox &lt;mailto:bob@work.example&gt; .
         ?x foaf:nick ?nick }
  }</pre>

<p>これにより、次の1つのソリューションが得られます。</p>

<div class="result">
<a name="table106" id="table106"></a>

<table class="resultTable">
  <tr>
    <th>nick</th>
  </tr>
  <tr>
    <td>"Robert"</td>
  </tr>
</table>

</div>
</div>
</div>
<div class="div3">

<h4>
<a name="restrictInQuery" id="restrictInQuery"></a>13.3.3 ありうるグラフIRFの制限</h4>

<p><code>GRAPH</code>句で用いられる変数は、もう1つの<code>GRAPH</code>句、または、データセットのデフォルト・グラフにマッチしたグラフ・パターンでも使用できます。</p>

<p>次のクエリは、Bobのプロフィール・ドキュメントを発見するためにIRI <code>http://example.org/foaf/aliceFoaf</code>を持つグラフを用いており、そのグラフに別のパターンをマッチさせます。AliceのFOAFファイルからファイルの変数<code>whom</code>にマッチングさせるため用いられる空白ノードは、プロフィール・ドキュメントの空白ノードと同じではないため（異なるグラフに存在する）、2番目の<code>GRAPH</code>句のパターンは、最初の<code>GRAPH</code>句（変数<code>whom</code>）で発見されたのと同じメールボックス（変数<code>mbox</code>によって示される）を持つ人の空白ノード（変数<code>w</code>）を発見します。</p>

<div class="queryGroup">

<pre class="query">PREFIX  data:  &lt;http://example.org/foaf/&gt;
PREFIX  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX  rdfs:  &lt;http://www.w3.org/2000/01/rdf-schema#&gt;

SELECT ?mbox ?nick ?ppd
FROM NAMED &lt;http://example.org/foaf/aliceFoaf&gt;
FROM NAMED &lt;http://example.org/foaf/bobFoaf&gt;
WHERE
{
  GRAPH data:aliceFoaf
  {
    ?alice foaf:mbox &lt;mailto:alice@work.example&gt; ;
           foaf:knows ?whom .
    ?whom  foaf:mbox ?mbox ;
           rdfs:seeAlso ?ppd .
    ?ppd  a foaf:PersonalProfileDocument .
  } .
  GRAPH ?ppd
  {
      ?w foaf:mbox ?mbox ;
         foaf:nick ?nick
  }
}</pre>
<div class="result">
<a name="table107" id="table107"></a>

<table class="resultTable">
  <tr>
    <th>mbox</th>    <th>nick</th>
    <th>ppd</th>
  </tr>
  <tr>
    <td>&lt;mailto:bob@work.example&gt;</td>
    <td>"Robert"</td>
    <td>&lt;http://example.org/foaf/bobFoaf&gt;</td>
  </tr>
</table>

</div>
</div>
</div>

<p>変数<code>nick</code>を含むパターンが<code>ppd</code>によって特定のパーソナル・プロフィール・ドキュメントに制限されているため、Bobの<code>nick</code>を示しているAliceのFOAFファイルのトリプルは、Bobにnickを提供するために用いられていません。</p>

<div class="div3">

<h4>
<a name="namedAndDefaultGraph" id="namedAndDefaultGraph"></a>13.3.4 名前付きグラフおよびデフォルト・グラフ</h4>

<p>クエリ・パターンは、デフォルト・グラフと名前付グラフの両方を含むことができます。この例では、アグリゲータは、2回の別の機会に1つのウェブ資源を読み込みました。グラフには、アグリゲータに読み込まれるたびに、ローカル・システムによってIRIが与えられます。これらのグラフはほぼ同じですが、「Bob」のEメール・アドレスが変更されました。</p>

<p>この例では、デフォルト・グラフは、来歴情報を記録するために用いられており、実際に読み込まれたRDFデータは2つの別々のグラフに保持され、システムはそれぞれに異なるIRIを与えます。RDFデータセットは、2つの名前付きグラフとそれらに関する情報で構成されます。</p>

<p>RDFデータセット:</p>

<div class="exampleGroup">

<pre class="data"># <b>Default graph</b>
@prefix dc: &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix g:  &lt;tag:example.org,2005-06-06:&gt; .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .

g:graph1 dc:publisher "Bob" .
g:graph1 dc:date "2004-12-06"^^xsd:date .

g:graph2 dc:publisher "Bob" .
g:graph2 dc:date "2005-01-10"^^xsd:date .</pre>

<pre class="data"># <b>Graph: locally allocated IRI: tag:example.org,2005-06-06:graph1</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Alice" .
_:a foaf:mbox &lt;mailto:alice@work.example&gt; .

_:b foaf:name "Bob" .
_:b foaf:mbox &lt;mailto:bob@oldcorp.example.org&gt; .</pre>

<pre class="data"># <b>Graph: locally allocated IRI: tag:example.org,2005-06-06:graph2</b>
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a foaf:name "Alice" .
_:a foaf:mbox &lt;mailto:alice@work.example&gt; .

_:b foaf:name "Bob" .
_:b foaf:mbox &lt;mailto:bob@newcorp.example.org&gt; .</pre>

<p>このクエリは、Eメール・アドレスを発見し、人名と情報が発見された日時を詳細化します。</p>

<div class="queryGroup">

<pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt;

SELECT ?name ?mbox ?date
WHERE
  {  ?g dc:publisher ?name ;
        dc:date ?date .
    GRAPH ?g
      { ?person foaf:name ?name ; foaf:mbox ?mbox }
  }</pre>

<p>結果は、「Bob」のEメール・アドレスが変更されたことを示します。</p>

<div class="result">
<a name="table108" id="table108"></a>

<table class="resultTable">
  <tr>
    <th>name</th>
    <th>mbox</th>
    <th>date</th>
  </tr>
  <tr>
    <td>"Bob"</td>
    <td>&lt;mailto:bob@oldcorp.example.org&gt;</td>
    <td>"2004-12-06"^^xsd:date</td>
  </tr>
  <tr>
    <td>"Bob"</td>
    <td>&lt;mailto:bob@newcorp.example.org&gt;</td>
    <td>"2005-01-10"^^xsd:date</td>
  </tr>
</table>

</div>
</div>
</div>
</div>
</div>
</div>
<div class="div1">

<h2>
<a name="basic-federated-query" id="basic-federated-query"></a>14 基本的な統合クエリ</h2>

<p>このドキュメントには、SPARQL統合拡張用の構文を組み込んでいます。</p>

<p>この機能は、<a href="www.w3.org/TR/sparql11-federated-query/">SPARQL 1.1統合クエリ</a>のドキュメントで定義されています。</p>

</div>
<div class="div1">

<h2>
<a name="solutionModifiers" id="solutionModifiers"></a>15 ソリューション・シーケンスと修飾子</h2>

<p>クエリ・パターンは、各<a href="#defn_sparqlSolutionMapping">ソリューション</a>が変数からRDF用語への部分関数である、順不同のソリューションのコレクションを作成します。次に、これらのソリューションは、シーケンス（ソリューション・シーケンス）として処理されます。最初は特に順序付けのないシーケンスで、後で、任意のシーケンス修飾子を適用して別のシーケンスを作成します。最終的に、この後者のシーケンスを用いて、<a href="#QueryForms">SPARQLクエリ形式</a>の結果の1つを生成します。</p>

<p><span class="definedTerm">ソリューション・シーケンス修飾子</span>は、次のいずれか1つです。</p>

<ul>
  <li>
<a href="#modOrderBy">Order</a>修飾子: ソリューションを順序付けします。</li>
  <li>
<a href="#modProjection">Projection</a>修飾子: ある変数を選択します。</li>
  <li>
<a href="#modDistinct">Distinct</a>修飾子: 確実にシーケンス中のソリューションをユニークにします。</li>
  <li>
<a href="#modReduced">Reduced</a>修飾子: Distinctではないソリューションの排除を許可します。</li>
  <li>
<a href="#modOffset">Offset</a>修飾子: 全体のソリューションのシーケンス中のどこからソリューションが始まるかを制御します。</li>
  <li>
<a href="#modResultLimit">Limit</a>修飾子: ソリューションの数を制限します。</li>
</ul>

<p>修飾子は、上記リストで示されている順序で適用されます。</p>

<div class="div2">

<h3>
<a name="modOrderBy" id="modOrderBy"></a>15.1 ORDER BY</h3>

<p><code>ORDER BY</code>句は、ソリューション・シーケンスの順序を定めます。</p>

<p><code>ORDER BY</code>句の後には、式と、オプションの順序修飾子（<code>ASC()</code>か<code>DESC()</code>のどちらか）で構成された順序コンパレータ（order comparator）のシーケンスが続きます。各順序付けコンパレータは、昇順（<code>ASC()</code>修飾子、または、修飾子なしで示される）か、降順（<code>DESC()</code>修飾子で示される）です。</p>

<div class="exampleGroup">
<div class="queryGroup">

<pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?name
WHERE { ?x foaf:name ?name }
ORDER BY ?name</pre>
</div>
</div>
<div class="exampleGroup">
<div class="queryGroup">

<pre class="query">PREFIX     :    &lt;http://example.org/ns#&gt;
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?name
WHERE { ?x foaf:name ?name ; :empId ?emp }
ORDER BY DESC(?emp)</pre>
</div>
</div>
<div class="exampleGroup">
<div class="queryGroup">

<pre class="query">PREFIX     :    &lt;http://example.org/ns#&gt;
PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?name
WHERE { ?x foaf:name ?name ; :empId ?emp }
ORDER BY ?name DESC(?emp)</pre>
</div>
</div>

<p><a href="#op_lt">「&lt;」という演算子</a>（<a href="#OperatorMapping">演算子マッピング</a>および<a href="#operatorExtensibility">17.3.1 演算子の拡張性</a>を参照）は、数値（<code>numerics</code>）、シンプルなリテラル（<code>simple literals</code>）、<code>xsd:strings</code>、<code>xsd:booleans</code>、<code>xsd:dateTimes</code>の対の相対順序を定めます。IRIの対は、<code>simple literals</code>として比較し、順序付けられます。</p>

<p>SPARQLは、次の、別の方法では順序付けられない数種のRDF用語間の順序も定めます。</p>

<ol>
  <li>（最も順序が低い） このソリューションの変数または式に割り当てられていない値</li>
  <li>空白ノード</li>
  <li>IRI</li>
  <li>RDFリテラル</li>
</ol>

<p>プレーン・リテラルは、同じ字句形式の型<code>xsd:string</code>を持つRDFリテラルよりも順序が低いです。</p>

<p>SPARQLは、可能な限りのあらゆるRDF用語の全体的な順序付けを定めるわけではありません。以下は、相対順序が定められていない対の用語のいくつかの例です。</p>

<ul>
  <li>"a" と "a"@en_gb（シンプルなリテラルと言語タグ付きリテラル）</li>
  <li>"a"@en_gb と "b"@en_gb（言語タグを持つ2つのリテラル）</li>
  <li>"a" と "1"^^xsd:integer（シンプルなリテラルとサポートされているデータ型を持つリテラル）</li>
  <li>"1"^^my:integer と "2"^^my:integer（2つのサポートされていないデータ型）</li>
  <li>"1"^^xsd:integer と "2"^^my:integer（サポートしているデータ型とサポートされていないデータ型）</li>
</ul>

<p>この変数バインディングのリストは、昇順です。</p>

<div class="result">

<table class="resultTable">
<thead>
  <tr>
    <th>RDF Term</th>
    <th>Reason</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td></td>
    <td>Unbound results sort earliest.</td>
  </tr>
  <tr>
    <td><code>_:z</code></td>
    <td>Blank nodes follow unbound.</td>
  </tr>
  <tr>
    <td><code>_:a</code></td>
    <td>There is no relative ordering of blank nodes.</td>
  </tr>
  <tr>
    <td><code>&lt;http://script.example/Latin&gt;</code></td>
    <td>IRIs follow blank nodes.</td>
  </tr>
  <tr>
    <td><code>&lt;http://script.example/Кириллица&gt;</code></td>
    <td>The character in the 23rd position, "К", has a unicode codepoint 0x41A, which is higher than 0x4C ("L").</td>
  </tr>
  <tr>
    <td><code>&lt;http://script.example/漢字&gt;  </code></td>
    <td>The character in the 23rd position, "漢", has a unicode codepoint 0x6F22, which is higher than 0x41A ("К").</td>
  </tr>
  <tr>
    <td><code>"http://script.example/Latin"</code></td>
    <td>Simple literals follow IRIs.</td>
  </tr>
  <tr>
    <td><code>"http://script.example/Latin"^^xsd:string</code></td>
    <td>xsd:strings follow simple literals.</td>
  </tr>
</tbody>
</table>

</div>

<p>順序付けコンパレータに対する2つのソリューションの昇順は、ソリューションのバインディングを式に代入し、それを<a href="#op_lt">「&lt;」演算子</a>で比較することで定めることができます。降順は昇順の逆です。</p>

<p>2つのソリューションの相対順序は、シーケンス内の最初の順序付けコンパレータに対する2つのソリューションの相対順序です。ソリューション・バインディングの置換が同じRDF用語を作成するソリューションの場合は、順序は次の順序付けコンパレータに対する2つのソリューションの相対順序です。2つのソリューションに対して評価が行われた順序の式が別々のRDF用語を作成しない場合、2つのソリューションの相対順序は未定義です。</p>

<p>ソリューションのシーケンスの順序付けは、常に、その内部に同数のソリューションを持つシーケンスになります。</p>

<p>ソリューション・シーケンスで<code>CONSTRUCT</code>または<code>DESCRIBE</code>クエリに対し<code>ORDER BY</code>を使用すると、<code>SELECT</code>のみが結果のシーケンスを返すため、直接的な効果はありません。<code>LIMIT</code>や<code>OFFSET</code>と組み合わせて用いれば、<code>ORDER BY</code>は、ソリューション・シーケンスの異なる部分から生じる結果を返すために使用できます。<code>ASK</code>クエリは、<code>ORDER BY</code>、<code>LIMIT</code>、または、<code>OFFSET</code>を含みません。</p>

</div>
<div class="div2">

<h3>
<a name="modProjection" id="modProjection"></a>15.2 射影</h3>

<p>ソリューション・シーケンスは変数のサブセットのみを含むものに変換できます。シーケンスの各ソリューションに対し、SELECTクエリ形式を用いて変数の指定選択を用いることで新しいソリューションが作成されます。</p>

<p>以下の例では、FOAFプロパティーを用いて、RDFグラフで記述された人名のみを抽出するためのクエリを示しています。</p>

<div class="exampleGroup">

<pre class="data">@prefix foaf:        &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice" .
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       &lt;mailto:bob@work.example&gt; .</pre>
<div class="queryGroup">

<pre class="query">PREFIX foaf:       &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name
WHERE
 { ?x foaf:name ?name }</pre>
<div class="result">

<table class="resultTable">
  <tr>
    <th>name</th>
  </tr>
  <tr>
    <td>"Bob"</td>
  </tr>
  <tr>
    <td>"Alice"</td>
  </tr>
</table>

</div>
</div>
</div>
</div>
<div class="div2">

<h3>
<a name="modDuplicates" id="modDuplicates"></a>15.3 ソリューションの複製</h3>

<p><code>DISTINCT</code>または<code>REDUCED</code>というクエリ修飾子を用いないソリューション・シーケンスは、複製のソリューションを保持するでしょう。</p>

<div class="exampleGroup">

<p>データ:</p>

<pre class="data">@prefix  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:x    foaf:name   "Alice" .
_:x    foaf:mbox   &lt;mailto:alice@example.com&gt; .

_:y    foaf:name   "Alice" .
_:y    foaf:mbox   &lt;mailto:asmith@example.com&gt; .

_:z    foaf:name   "Alice" .
_:z    foaf:mbox   &lt;mailto:alice.smith@example.com&gt; .</pre>
<div class="queryGroup">

<p>クエリ:</p>

<pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name WHERE { ?x foaf:name ?name }</pre>
<div class="result">

<p>結果:</p>

<table class="resultTable">
  <tr>
    <th>name</th>
  </tr>
  <tr>
    <td>"Alice"</td>
  </tr>
  <tr>
    <td>"Alice"</td>
  </tr>
  <tr>
    <td>"Alice"</td>
  </tr>
</table>

</div>
</div>

<p><code>DISTINCT</code>および<code>REDUCED</code>の修飾子は、クエリの結果に重複が含まれるかどうかに影響を与えます。</p>

<div class="div3">

<h4>
<a name="modDistinct" id="modDistinct"></a>15.3.1 DISTINCT</h4>

<p><code>DISTINCT</code>ソリューション修飾子は、重複するソリューションを排除します。同じ変数を同じRDF用語にバインドする1つのソリューションのみが、クエリから返されます。</p>

<div class="queryGroup">

<pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT DISTINCT ?name WHERE { ?x foaf:name ?name }</pre>
<div class="result">

<table class="resultTable">
  <tr>
    <th>name</th>
  </tr>
  <tr>
    <td>"Alice"</td>
  </tr>
</table>

</div>
</div>

<p id="defunSELECT"><a href="#solutionModifiers">ソリューション・シーケンス修飾子の順序</a>にあるように、limitかoffsetのいずれかが適用される前に重複が排除されることに注意してください。</p>

</div>
<div class="div3">

<h4>
<a name="modReduced" id="modReduced"></a>15.3.2 REDUCED</h4>

<p><code>DISTINCT</code>修飾子は、ソリューション集合から重複したソリューションを確実に排除しますが、<code>REDUCED</code>は、単にそれらを排除することを許可するだけです。<code>REDUCED</code>ソリューション集合の変数バインディング集合のカーディナリティーは、少なくとも1で、多くとも<code>DISTINCT</code>または<code>REDUCED</code>修飾子を用いないソリューション集合のカーディナリティーを超えません。例えば、上記のデータを用いた場合、次のクエリは、</p>

<div class="queryGroup">

<pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT REDUCED ?name WHERE { ?x foaf:name ?name }</pre>

<p>1、2（ここで示しているもの）、または、3つのソリューションを持つことができます。</p>

<div class="result">

<table class="resultTable">
  <tr>
    <th>name</th>
  </tr>
  <tr>
    <td>"Alice"</td>
  </tr>
  <tr>
    <td>"Alice"</td>
  </tr>
</table>

</div>
</div>
</div>
</div>
</div>
<div class="div2">

<h3>
<a name="modOffset" id="modOffset"></a>15.4 OFFSET</h3>

<p><code>OFFSET</code>は、指定された数のソリューションの後でソリューションが始まるようにします。<code>OFFSET</code>を0にすれば効果はありません。</p>

<p>クエリのソリューションの異なるサブセットを選択するために<code>LIMIT</code>と<code>OFFSET</code>を用いても、<code>ORDER BY</code>を用いて順序を予測できるようにしないと、有効ではないでしょう。</p>

<div class="exampleGroup">
<div class="queryGroup">

<pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT  ?name
WHERE   { ?x foaf:name ?name }
ORDER BY ?name
LIMIT   5
OFFSET  10</pre>
</div>
</div>
</div>
<div class="div2">

<h3>
<a name="modResultLimit" id="modResultLimit"></a>15.5 LIMIT</h3>

<p><code>LIMIT</code>句は、返されるソリューションの数に上限を設けます。<code>OFFSET</code>が適用された後で、実際のソリューションの数がlimitより大きい場合は、最大で、limitの数のソリューションが返されるでしょう。</p>

<div class="exampleGroup">
<div class="queryGroup">

<pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?name
WHERE { ?x foaf:name ?name }
LIMIT 20</pre>
</div>
</div>

<p><code>LIMIT</code>を0にすれば、結果を返さないでしょう。limitは負の数であってはなりません。</p>

</div>
</div>
<div class="div1">

<h2>
<a name="QueryForms" id="QueryForms"></a>16 クエリ形式</h2>

<p>SPARQLには、4つのクエリ形式があります。これらのクエリ形式は、パターン・マッチングのソリューションを用いて、結果集合またはRDFグラフを作成します。クエリ形式は、次の通りです。</p>

<blockquote>
  <dl>
  <dt><a href="#select">SELECT</a></dt>
  <dd>クエリ・パターンにバインドされた変数の、すべてまたはサブセットを返す。</dd>
  <dt><a href="#construct">CONSTRUCT</a></dt>
  <dd>1組のトリプル・テンプレートに変数を代入して構築したRDFグラフを返す。</dd>
  <dt><a href="#ask">ASK</a></dt>
  <dd>クエリ・パターンがマッチするかどうかを示すブール値を返す。</dd>
  <dt><a href="#describe">DESCRIBE</a></dt>
  <dd>発見した資源に関して記述したRDFグラフを返す。</dd>
  </dl>
</blockquote>

<p><code>SELECT</code>クエリからの結果集合、または、<code>ASK</code>クエリのブール演算結果をシリアル化するために<a class="inform" href="www.w3.org/TR/sparql11-results-json/">SPARQL 1.1クエリ結果JSONフォーマット</a>、<a class="inform" href="www.w3.org/TR/rdf-sparql-XMLres/">SPARQLクエリ結果XMLフォーマット</a>、<a class="inform" href="www.w3.org/TR/sparql11-results-csv-tsv/">SPARQL 1.1クエリ結果CSVおよびTSVフォーマット</a>などのフォーマットを使用できます。</p>

<div class="div2">

<h3>
<a name="select" id="select"></a>16.1 SELECT</h3>

<p>結果のSELECT形式は、変数とそのバインディングを直接返します。これは、必須の変数を射影するオペレーションと、新しい変数バインディングのクエリ・ソリューションへの導入とを組み合わせます。</p>

<div class="div3">

<h4>
<a name="selectproject" id="selectproject"></a>16.1.1 射影</h4>

<p>変数名のリストがSELECT句で与えられれば、特定の変数とそのバインディングが返されます。<code>SELECT *</code>という構文は、クエリ中のその時点で<a href="#variableScope">範囲内</a>にある変数をすべて選択するための省略形です。これは、<code>MINUS</code>の右側の<code>FILTER</code>でのみ使用されている変数を除外し、サブクエリを対象に入れます。</p>

<p><code>SELECT *</code>の使用は、クエリに<code>GROUP BY</code>句がない場合にのみ認められています。</p>

<div class="exampleGroup">

<pre class="data">@prefix  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a    foaf:name   "Alice" .
_:a    foaf:knows  _:b .
_:a    foaf:knows  _:c .

_:b    foaf:name   "Bob" .

_:c    foaf:name   "Clare" .
_:c    foaf:nick   "CT" .	    </pre>
<div class="queryGroup">

<pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?nameX ?nameY ?nickY
WHERE
  { ?x foaf:knows ?y ;
       foaf:name ?nameX .
    ?y foaf:name ?nameY .
    OPTIONAL { ?y foaf:nick ?nickY }
  }</pre>
<div class="result">
<a name="table33" id="table33"></a>

<table class="resultTable">
  <tr>
    <th>nameX</th>
    <th>nameY</th>
    <th>nickY</th>
  </tr>
  <tr>
    <td>"Alice"</td>
    <td>"Bob"</td>
    <td></td>
  </tr>
  <tr>
    <td>"Alice"</td>
    <td>"Clare"</td>
    <td>"CT"</td>
  </tr>
</table>

</div>

<p>結果集合は、ローカルAPIからアクセスできますが、JSON、XML、CSV、TSVのいずれかにシリアル化することも可能です。</p>

<p><a class="inform" href="www.w3.org/TR/sparql11-results-json/">SPARQL 1.1クエリ結果JSONフォーマット</a>:</p>

<div class="result">

<pre class="resultSet">{
  "head": {
    "vars": [ "nameX" , "nameY" , "nickY" ]
  } ,
  "results": {
    "bindings": [
      {
        "nameX": { "type": "literal" , "value": "Alice" } ,
        "nameY": { "type": "literal" , "value": "Bob" }
      } ,
      {
        "nameX": { "type": "literal" , "value": "Alice" } ,
        "nameY": { "type": "literal" , "value": "Clare" } ,
        "nickY": { "type": "literal" , "value": "CT" }
      }
    ]
  }
}</pre>
</div>

<p><a class="inform" href="www.w3.org/TR/rdf-sparql-XMLres/">SPARQLクエリ結果XMLフォーマット</a>:</p>

<div class="result">

<pre class="resultSet">&lt;?xml version="1.0"?&gt;
&lt;sparql xmlns="http://www.w3.org/2005/sparql-results#"&gt;
  &lt;head&gt;
    &lt;variable name="nameX"/&gt;
    &lt;variable name="nameY"/&gt;
    &lt;variable name="nickY"/&gt;
  &lt;/head&gt;
  &lt;results&gt;
    &lt;result&gt;
      &lt;binding name="nameX"&gt;
        &lt;literal&gt;Alice&lt;/literal&gt;
      &lt;/binding&gt;
      &lt;binding name="nameY"&gt;
        &lt;literal&gt;Bob&lt;/literal&gt;
      &lt;/binding&gt;
   &lt;/result&gt;
    &lt;result&gt;
      &lt;binding name="nameX"&gt;
        &lt;literal&gt;Alice&lt;/literal&gt;
      &lt;/binding&gt;
      &lt;binding name="nameY"&gt;
        &lt;literal&gt;Clare&lt;/literal&gt;
      &lt;/binding&gt;
      &lt;binding name="nickY"&gt;
        &lt;literal&gt;CT&lt;/literal&gt;
      &lt;/binding&gt;
    &lt;/result&gt;
  &lt;/results&gt;
&lt;/sparql&gt;</pre>
</div>
</div>
</div>
</div>
<div class="div3">

<h4>
<a name="selectExpressions" id="selectExpressions"></a>16.1.2 SELECT式</h4>

<p>SELECT句は、パターン・マッチングのどの変数を結果に含むかの選定に加え、新しい変数の導入も行えます。SELECT式の割り当て規則は、BINDの割り当てと同じです。この式は、クエリ・ソリューションに既にある変数バインディング、または、SELECT句で以前に定義された変数バインディングを組み合わせて、クエリ・ソリューション内にバインディングを生成します。</p>

<p><code>(expr AS v)</code>のスコーピングは、即座に適用されます。<code>SELECT</code>式では、変数は、後で同じSELECT句内の式で使用できますが、同じ<code>SELECT</code>句内で再度指定することはできません。</p>

<p>例:</p>

<div class="exampleGroup">

<p>データ:</p>

<pre class="data">@prefix dc:   &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix :     &lt;http://example.org/book/&gt; .
@prefix ns:   &lt;http://example.org/ns#&gt; .

:book1  dc:title  "SPARQL Tutorial" .
:book1  ns:price  42 .
:book1  ns:discount 0.2 .

:book2  dc:title  "The Semantic Web" .
:book2  ns:price  23 .
:book2  ns:discount 0.25 .</pre>

<p>クエリ:</p>

<div class="queryGroup">

<pre class="query">PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  ns:  &lt;http://example.org/ns#&gt;
SELECT  ?title (?p*(1-?discount) AS ?price)
{ ?x ns:price ?p .
  ?x dc:title ?title . 
  ?x ns:discount ?discount 
}</pre>

<p>結果:</p>

<div class="result">

<table class="resultTable">
  <tr>
    <th>title</th>
    <th>price</th>
  </tr>
  <tr>
    <td>"The Semantic Web"</td>
    <td>17.25</td>
  </tr>
  <tr>
    <td>"SPARQL Tutorial"</td>
    <td>33.6</td>
  </tr>
</table>

</div>
</div>
</div>

<p>新しい変数は、構文上、それが同じSELECT句内で以前に導入されていれば、式でも使用できます。</p>

<div class="exampleGroup">
<div class="queryGroup">

<pre class="query">PREFIX  dc:  &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX  ns:  &lt;http://example.org/ns#&gt;
SELECT  ?title (?p AS ?fullPrice) (?fullPrice*(1-?discount) AS ?customerPrice)
{ ?x ns:price ?p .
   ?x dc:title ?title . 
   ?x ns:discount ?discount 
}</pre>

<p>結果:</p>

<div class="result">

<table class="resultTable">
  <tr>
    <th>title</th>
    <th>fullPrice</th>
    <th>customerPrice</th>
  </tr>
  <tr>
    <td>"The Semantic Web"</td>
    <td>23</td>
    <td>17.25</td>
  </tr>
  <tr>
    <td>"SPARQL Tutorial"</td>
    <td>42</td>
    <td>33.6</td>
  </tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="div2">

<h3>
<a name="construct" id="construct"></a>16.2 CONSTRUCT</h3>

<p><code>CONSTRUCT</code>クエリ形式は、グラフ・テンプレートで指定された1つのRDFグラフを返します。結果は、各クエリのソリューションをソリューション・シーケンスに取り込み、グラフ・テンプレートに変数を代入し、和集合によってトリプルを1つのRDFグラフに結合して作成されたRDFグラフです。</p>

<p>このようなインスタンス化が、主語または述語の位置にあるリテラルなどの、バインドされていない変数または不正なRDF構成子を含むトリプルを作成する場合は、そのトリプルは出力RDFグラフに含まれません。グラフ・テンプレートは、変数を持たないトリプル（基底的または明示的なトリプルとして知られる）を含むことができ、これらはCONSTRUCTクエリ形式が返した出力RDFグラフにも表示されます。</p>

<div class="exampleGroup">

<pre class="data">@prefix  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a    foaf:name   "Alice" .
_:a    foaf:mbox   &lt;mailto:alice@example.org&gt; .</pre>
<div class="queryGroup">

<pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX vcard:   &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt;
CONSTRUCT   { &lt;http://example.org/person#Alice&gt; vcard:FN ?name }
WHERE       { ?x foaf:name ?name }</pre>

<p>は、FOAF情報からvcardプロパティーを作成します。</p>

<div class="result">

<pre class="resultGraph" style="text-align:left;">@prefix vcard: &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt; .

&lt;http://example.org/person#Alice&gt; vcard:FN "Alice" .</pre>
</div>
</div>
</div>
<div class="div3">

<h4>
<a name="templatesWithBNodes" id="templatesWithBNodes"></a>16.2.1 <a id="tempatesWithBNodes"></a>空白ノードを持つテンプレート</h4>

<p>テンプレートは、空白ノードを含んだRDFグラフを作成できます。空白ノード・ラベルは、各ソリューションに対するテンプレートで有効です。同じラベルが1つのテンプレートで2回出現する場合は、各クエリ・ソリューションに対して作成された1つの空白ノードが存在するでしょうが、別のクエリ・ソリューションによって生成されたトリプルに対する別の空白ノードが存在するでしょう。</p>

<div class="exampleGroup">

<pre class="data">@prefix  foaf:  &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a    foaf:givenname   "Alice" .
_:a    foaf:family_name "Hacker" .

_:b    foaf:firstname   "Bob" .
_:b    foaf:surname     "Hacker" .</pre>
<div class="queryGroup">

<pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX vcard:   &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt;

CONSTRUCT { ?x  vcard:N _:v .
            _:v vcard:givenName ?gname .
            _:v vcard:familyName ?fname }
WHERE
 {
    { ?x foaf:firstname ?gname } UNION  { ?x foaf:givenname   ?gname } .
    { ?x foaf:surname   ?fname } UNION  { ?x foaf:family_name ?fname } .
 }</pre>

<p>は、FOAF情報に対応するvcardプロパティーを作成します。</p>

<div class="result">

<pre class="resultGraph" style="text-align:left;">@prefix vcard: &lt;http://www.w3.org/2001/vcard-rdf/3.0#&gt; .

_:v1 vcard:N         _:x .
_:x vcard:givenName  "Alice" .
_:x vcard:familyName "Hacker" .

_:v2 vcard:N         _:z .
_:z vcard:givenName  "Bob" .
_:z vcard:familyName "Hacker" .</pre>
</div>
</div>
</div>

<p>テンプレートで変数<code>x</code>を用いると（この例では、データ内でラベル<code>_:a</code>と<code>_:b</code>を持つ空白ノードにバインドされているでしょう）、結果として生成されるRDFグラフの中に別の空白ノード・ラベル（<code>_:v1</code>と<code>_:v2</code>）が生成されます。</p>

</div>
<div class="div3">

<h4>
<a name="accessingRdfGraphs" id="accessingRdfGraphs"></a>16.2.2 RDFデータセットのグラフへのアクセス</h4>

<p><code>CONSTRUCT</code>を用いて、ターゲットのRDFデータセットからグラフの部分または全体を抽出することが可能です。この最初の例は、IRIラベル<code>http://example.org/aGraph</code>を持つグラフ（それがデータセットにあれば）を返します。さもなければ、空のグラフを返します。</p>

<div class="exampleGroup">
<div class="queryGroup">

<pre class="query">CONSTRUCT { ?s ?p ?o } WHERE { GRAPH &lt;http://example.org/aGraph&gt; { ?s ?p ?o } . }</pre>
</div>
</div>

<p>グラフへのアクセスは、他の情報を条件としている場合があります。例えば、デフォルト・グラフがデータセットの名前付きグラフに関するメタデータを含んでいる場合、次のようなクエリは、名前付きグラフに関する情報に基づく1つのグラフを抽出できます。</p>

<div class="exampleGroup">
<div class="queryGroup">

<pre class="query">PREFIX  dc: &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX app: &lt;http://example.org/ns#&gt;
PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;

CONSTRUCT { ?s ?p ?o } WHERE
 {
   GRAPH ?g { ?s ?p ?o } .
   ?g dc:publisher &lt;http://www.w3.org/&gt; .
   ?g dc:date ?date .
   FILTER ( app:customDate(?date) &gt; "2005-02-28T00:00:00Z"^^xsd:dateTime ) .
 }</pre>
</div>
</div>

<p>ここでは、<code>app:customDate</code>が<a href="#extensionFunctions">拡張関数</a>を識別し、日付フォーマットを<code>xsd:dateTime</code>というRDF用語に変えました。</p>

</div>
<div class="div3">

<h4>
<a name="SolModandCONSTRUCT" id="SolModandCONSTRUCT"></a>16.2.3 ソリューション修飾子とCONSTRUCT</h4>

<p>クエリのソリューション修飾子は、<code>CONSTRUCT</code>クエリの結果に影響を与えます。この例では、<code>CONSTRUCT</code>テンプレートからの出力グラフは、グラフ・パターン・マッチング2つのソリューションのみから形成されます。クエリは、ヒット率で格付けされたトップ2のサイトを持つ人々の名前を持つグラフを出力します。RDFグラフ中のトリプルは順序付けされていません。</p>

<div class="exampleGroup">

<pre class="data">@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix site: &lt;http://example.org/stats#&gt; .

_:a foaf:name "Alice" .
_:a site:hits 2349 .

_:b foaf:name "Bob" .
_:b site:hits 105 .

_:c foaf:name "Eve" .
_:c site:hits 181 .</pre>
<div class="queryGroup">

<pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX site: &lt;http://example.org/stats#&gt;

CONSTRUCT { [] foaf:name ?name }
WHERE
{ [] foaf:name ?name ;
     site:hits ?hits .
}
ORDER BY desc(?hits)
LIMIT 2</pre>
<div class="result">

<pre class="resultGraph">@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .
_:x foaf:name "Alice" .
_:y foaf:name "Eve" .</pre>
</div>
</div>
</div>
</div>
<div class="div3">

<h4>
<a name="constructWhere" id="constructWhere"></a>16.2.4 CONSTRUCT WHERE</h4>

<p>CONSTRUCTクエリ形式の省略形は、テンプレートとパターンが同じである場合や、パターンが単なる基本グラフ・パターンである場合に提供されます（<code>FILTER</code>および複雑なグラフ・パターンは、省略形が認められていません）。省略形では、キーワード<code>WHERE</code>は必須です。</p>

<p>次の2つのクエリは同じで、最初のクエリは2番目クエリの省略形です。</p>

<pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
CONSTRUCT WHERE { ?x foaf:name ?name } </pre>

<pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

CONSTRUCT { ?x foaf:name ?name } 
WHERE
{ ?x foaf:name ?name }</pre>
</div>
</div>
<div class="div2">

<h3>
<a name="ask" id="ask"></a>16.3 ASK</h3>

<p>アプリケーションは、クエリ・パターンにソリューションがあるか否かをテストするために<code>ASK</code>形式を使用できます。ありえるクエリのソリューションに関する情報は返さず、ソリューションが存在しているか否かのみです。</p>

<div class="exampleGroup">

<pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice" .
_:a  foaf:homepage   &lt;http://work.example.org/alice/&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       &lt;mailto:bob@work.example&gt; .</pre>
<div class="queryGroup">

<pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
ASK  { ?x foaf:name  "Alice" }</pre>
<div class="result">

<pre class="resultAsk">true</pre>
</div>

<p>この結果集合の<a class="inform" href="www.w3.org/TR/rdf-sparql-XMLres/">SPARQLクエリ結果XMLフォーマット</a>の形式は、次のようになります。</p>

<div class="result">

<pre class="resultSet">&lt;?xml version="1.0"?&gt;
&lt;sparql xmlns="http://www.w3.org/2005/sparql-results#"&gt;
  &lt;head&gt;&lt;/head&gt;
  &lt;boolean&gt;true&lt;/boolean&gt;
&lt;/sparql&gt;</pre>
</div>
</div>

<p>同じデータを用いた場合、次の例は、Aliceの<code>mbox</code>が記述されていないため、マッチを返しません。</p>

<div class="queryGroup">

<pre class="query">PREFIX foaf:    &lt;http://xmlns.com/foaf/0.1/&gt;
ASK  { ?x foaf:name  "Alice" ;
          foaf:mbox  &lt;mailto:alice@work.example&gt; }</pre>
<div class="result">

<pre class="resultAsk">false</pre>
</div>
</div>
</div>
</div>
<div class="div2">

<h3>
<a name="describe" id="describe"></a>16.4 DESCRIBE（参考情報）</h3>

<p><code>DESCRIBE</code>形式は、資源に関するRDFデータを含んだ1つの結果RDFグラフを返します。SPARQLのクエリではこのデータは規定されておらず、この場合には、クエリのクライアントがデータ情報源内のRDFの構造を知っている必要があるでしょうが、その代わりにSPARQLクエリ・プロセッサがこのデータを決定します。クエリ・パターンを用いて結果集合を作成します。<code>DESCRIBE</code>形式は、IRIで直接指定された任意の資源と一緒に、識別された各資源をソリューションに取り込み、ターゲットのRDFデータセットを含んでいる利用可能な任意の情報から得られる「記述」を持ってくることによって、1つのRDFグラフを組み立てます。記述はクエリ・サービスが決定します。<code>DESCRIBE *</code>という構文は、クエリ内のすべての変数を記述するための省略形です。</p>

<div class="div3">

<h4>
<a name="explicitIRIs" id="explicitIRIs"></a>16.4.1 明示的なIRI</h4>

<p><code>DESCRIBE</code>句自身がIRIを取り込んで資源を識別することができます。最もシンプルな<code>DESCRIBE</code>クエリは、次のような<code>DESCRIBE</code>句内にIRIのみがあるものです。</p>

<div class="exampleGroup">
<div class="queryGroup">

<pre class="query">DESCRIBE &lt;http://example.org/&gt;</pre>
</div>
</div>
</div>
<div class="div3">

<h4>
<a name="identifyingResources" id="identifyingResources"></a>16.4.2 資源の識別</h4>

<p>記述される資源は、クエリ変数へのバインディングから結果集合に取り込むこともできます。これによって、次のような、資源がIRIによって識別されるのか、データセットの空白ノードによって識別されるのかの記述が可能になります。</p>

<div class="exampleGroup">
<div class="queryGroup">

<pre class="query">PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
DESCRIBE ?x
WHERE    { ?x foaf:mbox &lt;mailto:alice@org&gt; }</pre>
</div>
</div>

<p>プロパティー<code>foaf:mbox</code>は、FOAF語彙では、逆関数型プロパティーであると定義されています。そういうものとして処理すると、このクエリは、高々1人の人物に関する情報を返すでしょう。しかし、クエリ・パターンに複数のソリューションがある場合は、それぞれに対するRDFデータは、すべてのRDFグラフ記述の和集合です。</p>

<div class="exampleGroup">
<div class="queryGroup">

<pre class="query">PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
DESCRIBE ?x
WHERE    { ?x foaf:name "Alice" }</pre>
</div>
</div>

<p>次のように、1つ以上のIRIまたは変数を作成できます。</p>

<div class="exampleGroup">
<div class="queryGroup">

<pre class="query">PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;
DESCRIBE ?x ?y &lt;http://example.org/&gt;
WHERE    {?x foaf:knows ?y}</pre>
</div>
</div>
</div>
<div class="div3">

<h4>
<a name="descriptionsOfResources" id="descriptionsOfResources"></a>16.4.3 資源の記述</h4>

<p>返されるRDFは、情報の発行者が決定します。これは、サービスが、記述されている資源に関するものと見なす情報かもしれません。他の資源に関する情報を含むことができます。例えば、本のRDFデータには、著者に関する詳細を含むこともできます。</p>

<p>次のようなシンプルなクエリは、</p>

<div class="exampleGroup">
<div class="queryGroup">

<pre class="query">PREFIX ent:  &lt;http://org.example.com/employees#&gt;
DESCRIBE ?x WHERE { ?x ent:employeeId "1234" }</pre>

<p>下記のような、従業員の記述や、何らかの他の潜在的に役に立つ詳細情報を返すかもしれません。</p>

<div class="result">

<pre class="resultGraph">@prefix foaf:   &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix vcard:  &lt;http://www.w3.org/2001/vcard-rdf/3.0&gt; .
@prefix exOrg:  &lt;http://org.example.com/employees#&gt; .
@prefix <code>rdf:    &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix owl:    &lt;http://www.w3.org/2002/07/owl#&gt;</code>

_:a     exOrg:employeeId    "1234" ;
       
        <code>foaf:mbox_sha1sum   "bee135d3af1e418104bc42904596fe148e90f033" ;</code>
        vcard:N
         [ vcard:Family       "Smith" ;
           vcard:Given        "John"  ] .

<code>foaf:mbox_sha1sum  rdf:type  owl:InverseFunctionalProperty .</code></pre>
</div>
</div>
</div>

<p>これには、<a href="www.w3.org/TR/vcard-rdf" class="inform">vcard</a>語彙vcard:Nに対する空白ノード・クロージャが含まれいます。どのような情報を返すかを決定できる他のメカニズムには、Concise Bounded Descriptions[<a href="#CBD">CBD</a>]などもあります。</p>

<p><code>WHERE</code>FOAFなどの語彙では、通常は、資源は空白ノードであるため、InverseFunctionalPropertyである<code>foaf:mbox_sha1sum</code>などのノードを識別するのに十分な情報や、名前やその他の詳細データといった情報を返すのが適切でしょう。例では、<code>WHERE</code>句に対するマッチが返されましたが、これは必須ではありません。</p>

</div>
</div>
</div>
<div class="div1">

<h2>
<a name="expressions" id="expressions"></a>17 式と値のテスト</h2>

<p>SPARQLの<code>FILTERs</code>は、与えられた<a href="#rConstraint">制約</a>に従ってグラフ・パターン・マッチのソリューションを制限します。具体的には、<code>FILTERs</code>は、式に代入したときに、偽（<code>false</code>）の有効なブール値になったり、エラーを起こしたりするソリューションを排除します。有効なブール値は<a href="#ebv">17.2.2 <em>有効なブール値</em></a>の項で定義されており、エラーはXQuery1.0: XMLクエリ言語[<a href="#XQUERY">XQUERY</a>]の<a class="norm" href="www.w3.org/TR/2007/REC-xquery-20070123/#dt-type-error">2.3.1, <em>エラーの種類</em></a>の項で定義されています。これらのエラーは、<code>FILTER</code>の評価以外には影響を与えません。</p>

<div class="exampleGroup">

<p>RDFリテラルは、<a>データ型IRI</a>を持つことができます。</p>

<pre class="data">@prefix a:          &lt;http://www.w3.org/2000/10/annotation-ns#&gt; .
@prefix dc:         &lt;http://purl.org/dc/elements/1.1/&gt; .

_:a   a:annotates   &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
_:a   dc:date       "2004-12-31T19:00:00-05:00" .

_:b   a:annotates   &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
_:b   dc:date       "2004-12-31T19:01:00-05:00"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .</pre>

<p>最初の<code>dc:date</code>トリプルの目的語には、型情報が全くありません。2番目のものには、<code>xsd:dateTime</code>というデータ型があります。</p>

<p>SPARQLの式は文法に従って構築され、関数（IRIによって名前が付けられる）と演算子関数へのアクセスを提供します（SPARQL文法のキーワードとシンボルで呼び出される）。SPARQLの演算子は、型付リテラルの値を比較するために使用できます。</p>

<div class="queryGroup">

<pre class="query">PREFIX a:      &lt;http://www.w3.org/2000/10/annotation-ns#&gt;
PREFIX dc:     &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX xsd:    &lt;http://www.w3.org/2001/XMLSchema#&gt;

SELECT ?annot
WHERE { ?annot  a:annotates  &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
        ?annot  dc:date      ?date .
        FILTER ( ?date &gt; "2005-01-01T00:00:00Z"^^xsd:dateTime ) }</pre>
</div>
</div>

<p>SPARQLの演算子は、<a href="#OperatorMapping">17.3項</a>に記載されており、文法上の生成規則に関連付けられています。</p>

<p>さらに、SPARQLは、<a href="#FunctionMapping">17.5項</a>に記載している、XPathキャスト関数のサブセットを含む、任意の関数を呼び出す能力を提供します。これらの関数は、名前（IRI）によってSPARQLクエリの中に呼び出されます。例えば次のとおりです。</p>

<pre class="query untested">... FILTER ( xsd:dateTime(?date) &lt; xsd:dateTime("2005-01-01T00:00:00Z") ) ...</pre>

<p>この項の表記上の規定: XPath演算子は接頭辞<code>op:</code>でラベル付けされています。XPath演算子には名前空間がなく、<code>op:</code>はラベル付け上の慣習です。</p>

<div class="div2">

<h3>
<a name="operandDataTypes" id="operandDataTypes"></a>17.1 オペランド・データ型</h3>

<p>SPARQLの関数と演算子は、RDF用語とSPARQL変数を演算します。これらの関数および演算子のサブセットは、<a class="norm" href="www.w3.org/TR/xpath-functions/">XQuery 1.0とXPath 2.0関数および演算子</a>[<a href="#FUNCOP">FUNCOP</a>]から持って来たもので、XMLスキーマ<a href="www.w3.org/TR/xpath20/#dt-typed-value">型付き値</a>の引数を持っており、型を返します。これらの関数と演算子に引数として渡されたRDF型付きリテラル（<code>typed literals</code>）は、字句形式（<code>lexical form</code>）の<a href="www.w3.org/TR/xpath20/#dt-string-value">文字列の値</a>を持つXMLスキーマの型付き値と、<span class="type datatypeIRI">データ型IRI</span>に対応する<a href="www.w3.org/TR/xmlschema-2/#dt-atomic">アトミックなデータ型</a>にマッピングされます。返された型付き値は、同様にRDFの型付きリテラル（<code>typed literals</code>）にマッピングし返されます。</p>

<p>SPARQLには、RDF用語の特定のサブセットに基づいて演算する付加的な演算子があります。型について述べるときには、次の用語は、<a class="norm" href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/">XMLスキーマ</a>[<a class="norm" href="#XSDT">XSDT</a>]の<span class="type datatypeIRI">データ型IRI</span>に対応する型付きリテラル（<code>typed literal</code>）を表します。</p>

<ul>
  <li><code><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-integer">xsd:integer</a></code></li>
  <li><code><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-decimal">xsd:decimal</a></code></li>
  <li><code><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-float">xsd:float</a></code></li>
  <li><code><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-double">xsd:double</a></code></li>
  <li><code><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-string">xsd:string</a></code></li>
  <li><code><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-boolean">xsd:boolean</a></code></li>
  <li><code><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-dateTime">xsd:dateTime</a></code></li>
</ul>

<p>次の用語は、SPARQL値テストに用いられる付加的な型を識別します。</p>

<ul>
<li>
<span class="type numeric">数値</span>は、データ型<code>xsd:integer</code>、<code>xsd:decimal</code>、<code>xsd:float</code>、および、<code>xsd:double</code>を持つ型付きリテラル（<code>typed literals</code>）を表します。</li>
  <li>
<span class="type simpleLiteral">シンプルなリテラル</span>は、言語タグ（<code>language tag</code>）を持たないプレーン・リテラル（<code>plain literal</code>）を表します。
</li>
  <li>
<span class="type RDFterm">RDF用語</span>は、<code>IRI</code>、リテラル（<code>literal</code>）、および、空白ノード（<code>blank node</code>）の型を表します。</li>
  <li>
<span class="type variable">変数</span>は、SPARQL変数を表します。</li>
</ul>

<p>次の型は、<span class="type numeric">数値</span>の型から得られ、<span class="type numeric">数値</span>引数を取る関数と演算子に対する有効な引数です。</p>

<ul>
<li><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-nonPositiveInteger"><code>xsd:nonPositiveInteger</code></a></li>
  <li><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-negativeInteger"><code>xsd:negativeInteger</code></a></li>
  <li><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-long"><code>xsd:long</code></a></li>
  <li><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-int"><code>xsd:int</code></a></li>
  <li><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-short"><code>xsd:short</code></a></li>
  <li><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-byte"><code>xsd:byte</code></a></li>
  <li><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-nonNegativeInteger"><code>xsd:nonNegativeInteger</code></a></li>
  <li><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-unsignedLong"><code>xsd:unsignedLong</code></a></li>
  <li><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-unsignedInt"><code>xsd:unsignedInt</code></a></li>
  <li><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-unsignedShort"><code>xsd:unsignedShort</code></a></li>
  <li><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-unsignedByte"><code>xsd:unsignedByte</code></a></li>
  <li><a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/#dt-positiveInteger"><code>xsd:positiveInteger</code></a></li>
</ul>

<p>SPARQLの言語拡張は、付加的な型をXMLスキーマ・データ型から得られるものとして扱うことができます。</p>

</div>
<div class="div2">

<h3>
<a name="evaluation" id="evaluation"></a>17.2 フィルタ評価</h3>

<p>SPARQLは、XQuery<a href="www.w3.org/TR/xquery/#mapping" class="norm">演算子マッピング</a>で定義された関数と演算子のサブセットを提供します。XQuery 1.0の<a href="www.w3.org/TR/xquery/#id-expression-processing" class="norm">2.2.3 式の処理</a>の項では、XPath関数の呼び出しについて説明しています。次の規則は、XQueryとSPARQLのデータと実行モデルの違いを調整します。</p>

<ul>
  <li>XPath/XQueryとは異なり、SPARQL関数はノード・シーケンスを処理しません。XPath関数のセマンティクスを解釈するときには、それぞれの引数が1つのノードのシーケンスであると想定します。</li>
  <li>間違った型の引数で呼び出された関数は<a href="www.w3.org/TR/xquery/#dt-type-error" class="norm">型エラー</a>を起こすでしょう。有効なブール値引数（下記の演算子マッピング・テーブルで「xsd:boolean (EBV)」とラベル付けされている）は、17.2.2項の<a href="#ebv">EBV規則</a>を用いて<code>xsd:boolean</code>に強制変換されます。</li>
  <li>
<a href="#func-bound">BOUND</a>、<a href="#func-coalesce">COALESCE</a>、<a href="#func-filter-exists">NOT EXISTS</a>、<a href="#func-filter-exists">EXISTS</a>は別として、任意の引数がバインドされていなければ、すべての関数と演算子はRDF用語に基づいて演算し、型エラーを起こすでしょう。</li>
  <li>エラーに遭遇した<a href="#func-logical-or">論理OR</a>（<code>||</code>）または<a href="#func-logical-and">論理AND</a>（<code>&amp;&amp;</code>）を除く任意の式は、エラーを起こすでしょう。</li>
  <li>1つの辺のみでエラーに遭遇した<a href="#func-logical-or">論理OR</a>は、もう一方の辺がTRUEであるならTRUEを、FALSEであるならエラーを返します。</li>
  <li>1つの辺のみでエラーに遭遇した<a href="#func-logical-and">論理AND</a>は、もう一方の辺がTRUEであるならエラーを、FALSEであるならFALSEを返します。</li>
  <li>両方の辺でエラーに遭遇した<a href="#func-logical-or">論理OR</a>または<a href="#func-logical-and">論理AND</a>は、<em>どちらか</em>のエラーを起こします。</li>
</ul>

<p>真（<span class="truth">T</span>）、偽（<span class="truth">F</span>）、エラー（<span class="truth error">E</span>）に対する論理ANDと論理ORの真理値表は次の通りです。</p>

<a name="truthTable" id="truthTable"></a>

<table class="truthTable">
<thead>
  <tr>
    <th>A</th>
    <th>B</th>
    <th>A || B</th>
    <th>A &amp;&amp; B</th>
  </tr>
</thead>
<tbody>
  <tr>
    <th>T</th>
    <th>T</th>
    <td>T</td>
    <td>T</td>
  </tr>
  <tr>
    <th>T</th>
    <th>F</th>
    <td>T</td>
    <td>F</td>
  </tr>
  <tr>
    <th>F</th>
    <th>T</th>
    <td>T</td>
    <td>F</td>
  </tr>
  <tr>
    <th>F</th>
    <th>F</th>
    <td>F</td>
    <td>F</td>
  </tr>
</tbody>
<tbody>
  <tr>
    <th>T</th>
    <th><span class="error">E</span></th>
    <td>T</td>
    <td><span class="error">E</span></td>
  </tr>
  <tr>
    <th><span class="error">E</span></th>
    <th>T</th>
    <td>T</td>
    <td><span class="error">E</span></td>
  </tr>
  <tr>
    <th>F</th>
    <th><span class="error">E</span></th>
    <td><span class="error">E</span></td>
    <td>F</td>
  </tr>
  <tr>
    <th><span class="error">E</span></th>
    <th>F</th>
    <td><span class="error">E</span></td>
    <td>F</td>
  </tr>
  <tr>
    <th><span class="error">E</span></th>
    <th><span class="error">E</span></th>
    <td><span class="error">E</span></td>
    <td><span class="error">E</span></td>
  </tr>
</tbody>
</table>

<div class="div3">

<h4>
<a name="invocation" id="invocation"></a>17.2.1 呼び出し</h4>

<p>SPARQLは、引数のリストに関数を呼び出すための構文を定義しています。特に断りのない限り、これらは、次の通りに呼び出されます。</p>

<ul>
  <li>引数式は評価され、引数値を作成します。引数評価の順序は定義されません。</li>
  <li>数値引数は、その関数または演算子の予期される型に合うように必要に応じて入力が促されます。</li>
  <li>関数または演算子は、引数値で呼び出されます。</li>
</ul>

<p>これらのステップのどれかが失敗すれば、呼び出しはエラーを起こします。エラーの影響は、<a href="#evaluation">フィルタ評価</a>で定義されています。</p>

<p>「<a href="#func-forms">関数形式</a>」というものもあり、これは、個々の形式で指定されているとおりに、関数に対して異なる評価規則を持ちます。</p>

</div>
<div class="div3">

<h4>
<a name="ebv" id="ebv"></a>17.2.2 有効なブール値（EBV）</h4>

<p>有効なブール値は、<a href="#func-logical-and">論理AND</a>、<a href="#func-logical-or">論理OR</a>、および<a class="norm" href="www.w3.org/TR/xpath-functions/#func-not">fn:not</a>の論理関数に対する引数を計算するために用いられ、また、<code>FILTER</code>式の結果の評価も行います。</p>

<p>XQueryの<a href="www.w3.org/TR/xquery/#id-ebv">有効なブール値</a>の規則は、XPathの<a href="www.w3.org/TR/xpath-functions/#func-boolean">fn:boolean</a>の定義に依存しています。以下の規則は、SPARQLのクエリに存在している引数の型に適用された<code>fn:boolean</code>の規則を反映しています。</p>

<ul>
  <li>型が<code>xsd:boolean</code>または数値（<span class="type ">numeric</span>）である任意のリテラルのEBVは、字句形式がそのデータ型（例えば、"abc"^^xsd:integer）に対して偽である場合は、偽です。</li>
  <li>引数が<code>xsd:boolean</code>の<span class="type datatype">データ型</span>を持つ<span class="type typedLiteral">型付きリテラル</span>であり、有効な字句形式を持っている場合、EBVはその引数の値です。</li>
  <li>引数が<span class="type plainLiteral">プレーン・リテラル</span>または、<code>xsd:string</code>の<span class="type datatype">データ型</span>を持つ<span class="type typedLiteral">型付きリテラル</span>である場合、オペランド値に0の長さがあるならEBVは偽で、そうれなければEBVは真です。</li>
  <li>引数が、<span class="type numeric">数値</span>型、または<span class="type numeric">数値型</span>から得られたデータ型を持つ<span class="type typedLiteral">型付きリテラル</span>であり、有効な字句形式を持っている場合、オペランド値がNaNであるか数値上0と等しいならEBVは偽で、そうでなければ、EBVは真です。</li>
  <li>バインドされていない引数を含む他のすべての引数は、型エラーを起こします。</li>
</ul>

<p>真（<code>true</code>）のEBVは、<code>xsd:boolean</code>のデータ型および「真」の字句値を持つ<span class="type typedLiteral">型付きリテラル</span>として表され、 偽（false）のEBVは、<code>xsd:boolean</code>のデータ型および「偽」の字句値を持つ<span class="type typedLiteral">型付きリテラル</span>として表されます。</p>

</div>
</div>
<div class="div2">

<h3>
<a name="OperatorMapping" id="OperatorMapping"></a>17.3 演算子マッピング</h3>

<p>SPARQLの文法は、一連の演算子を識別し（例えば、<span class="token">&amp;&amp;</span>、<span class="token">*</span>、<span class="token">isIRI</span>）、制約を構築するために用いられます。以下のテーブルは、これらのそれぞれの文法上の生成規則と、<a class="norm" href="www.w3.org/TR/xpath-functions/">XQuery 1.0とXPath 2.0関数および演算子</a>[<a href="#FUNCOP">FUNCOP</a>]、または<a href="#SparqlOps">17.4項</a>のSPARQL演算子のいずれかによって定義されている適切なオペランドおよび演算子関数とを関連付けます。一連のパラメータに対する演算子定義を選択する際には、最も明確なパラメータを持つ定義が適用されます。例えば、<code>xsd:integer = xsd:signedInt</code>を評価する際には、2つの<span class="type RDFterm">RDF用語</span>を持つ<code>=</code>に対する定義ではなく、2つの数値（<code>numeric</code>）パラメータを持つ<code>=</code>に対する定義が適用されます。表は、最も実行可能性のある候補が最も明確になるように配列されています。適切なオペランドなしに呼び出された演算子は、型エラーになります。</p>

<p>SPARQLは、XPathの数値型昇格（numeric type promotion）に対するスキームと、数値演算子への引数に対する部分型置換（subtype substitution）に従います。<span class="type numeric">数値</span>オペランド（<code>xsd:integer</code>、<code>xsd:decimal</code>、<code>xsd:float</code>、<code>xsd:double</code>、および<span class="type numeric">数値</span>型から得られた型）の<a href="www.w3.org/TR/xpath20/#mapping">XPath演算子マッピング</a>規則は、SPARQL演算子にも適用されます（<a class="norm" href="www.w3.org/TR/xpath20/#promotion">数値型昇格</a>および<a class="norm" href="www.w3.org/TR/xpath20/#dt-subtype-substitution">部分型置換</a>の定義に関しては、<a class="norm" href="www.w3.org/TR/xpath20/">XMLパス言語（XPath）2.0</a>[<a href="#XPATH20">XPATH20</a>]を参照してください)。演算子の一部は、入れ子にされた関数式、例えば<code>fn:not(op:numeric-equal(A, B))</code>に関連しています。XPathの定義によって、<code>fn:not</code>および<code>op:numeric-equal</code>は、引数がエラーである場合にはエラーを起こします。</p>

<p><code>fn:compare</code>の照合順序は、<a href="www.w3.org/TR/xpath-functions/#collations">XPathで定義され</a>、<code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>で識別されます。この照合順序は、コードポイント値に基づく文字列の比較を可能にします。コードポイント文字列の同等性は、<span class="type RDFterm">RDF用語</span>の同等性でテストできます。</p>

<table summary="SPARQL Unary Operators" class="FAndOTable">
<caption>SPARQL単項演算子</caption>
<tbody>
  <tr>
    <th class="major" scope="col">演算子</th>
    <th class="major" scope="col">型（A）</th>
    <th class="major" scope="col">関数</th>
    <th class="major" scope="col">結果の型</th>
  </tr>
  <tr>
    <th colspan="4" class="subHeading" scope="col">XQuery単項演算子</th>
  </tr>
  <tr>
    <th scope="row"><a href="#rUnaryExpression" title="UnaryExpression"><span class="FAOTtoken">!</span> A</a></th>
    <td>xsd:boolean <a href="#ebv-arg">(EBV)</a>
</td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(A)</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th scope="row"><a href="#rUnaryExpression" title="UnaryExpression"><span class="FAOTtoken">+</span> A</a></th>
    <td><span class="type numeric">数値</span></td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-unary-plus">op:numeric-unary-plus</a>(A)</td>
    <td><span class="type numeric">数値</span></td>
  </tr>
  <tr>
    <th scope="row"><a href="#rUnaryExpression" title="UnaryExpression"><span class="FAOTtoken">-</span> A</a></th>
    <td><span class="type numeric">数値</span></td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-unary-minus">op:numeric-unary-minus</a>(A)</td>
    <td><span class="type numeric">数値</span></td>
  </tr>
</tbody>
</table>

<table summary="SPARQL Binary Operators" class="FAndOTable">
<caption>SPARQL二項演算子</caption>
<tbody>
  <tr>
    <th class="major" scope="col">演算子</th>
    <th class="major" scope="col">型（A）</th>
    <th class="major" scope="col">型（B）</th>
    <th class="major" scope="col">関数</th>
    <th class="major" scope="col">結果の型</th>
  </tr>
  <tr>
    <th colspan="5" class="subHeading" scope="col">論理結合子</th>
  </tr>
  <tr>
    <th><a href="#rConditionalOrExpression" title="ConditionalOrExpression">A <span class="FAOTtoken">||</span> B</a></th>
    <td>xsd:boolean <a href="#ebv-arg">(EBV)</a>
</td>
    <td>xsd:boolean <a href="#ebv-arg">(EBV)</a>
</td>
    <td class="sparqlOp">
<a href="#func-logical-or" class="SPARQLoperator">logical-or</a>(A, B)</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th><a href="#rConditionalAndExpression" title="ConditionalAndExpression">A <span class="FAOTtoken">&amp;&amp;</span> B</a></th>
    <td>xsd:boolean <a href="#ebv-arg">(EBV)</a>
</td>
    <td>xsd:boolean <a href="#ebv-arg">(EBV)</a>
</td>
    <td class="sparqlOp">
<a href="#func-logical-and" class="SPARQLoperator">logical-and</a>(A, B)</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th colspan="5" class="subHeading" scope="col">XPathテスト</th>
  </tr>
  <tr>
    <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a></th>
    <td><span class="type numeric">数値</span></td>
    <td><span class="type numeric">数値</span></td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(A, B)</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a></th>
    <td><span class="type simpleLiteral">シンプルなリテラル</span></td>
    <td><span class="type simpleLiteral">シンプルなリテラル</span></td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(A, B), 0)</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a></th>
    <td>xsd:string</td>
    <td>xsd:string</td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), 0)</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a></th>
    <td>xsd:boolean</td>
    <td>xsd:boolean</td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-boolean-equal">op:boolean-equal</a>(A, B)</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a></th>
    <td>xsd:dateTime</td>
    <td>xsd:dateTime</td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-dateTime-equal">op:dateTime-equal</a>(A, B)</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a></th>
    <td><span class="type numeric">数値</span></td>
    <td><span class="type numeric">数値</span></td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(A, B))</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a></th>
    <td><span class="type simpleLiteral">シンプルなリテラル</span></td>
    <td><span class="type simpleLiteral">シンプルなリテラル</span></td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(A, B), 0))</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a></th>
    <td>xsd:string</td>
    <td>xsd:string</td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), 0))</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a></th>
    <td>xsd:boolean</td>
    <td>xsd:boolean</td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-boolean-equal">op:boolean-equal</a>(A, B))</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a></th>
    <td>xsd:dateTime</td>
    <td>xsd:dateTime</td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-dateTime-equal">op:dateTime-equal</a>(A, B))</td>
    <td>xsd:boolean</td>
  </tr>
  <tr id="op_lt">
    <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;</span> B</a></th>
    <td><span class="type numeric">数値</span></td>
    <td><span class="type numeric">数値</span></td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-less-than">op:numeric-less-than</a>(A, B)</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;</span> B</a></th>
    <td><span class="type simpleLiteral">シンプルなリテラル</span></td>
    <td><span class="type simpleLiteral">シンプルなリテラル</span></td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(A, B), -1)</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;</span> B</a></th>
    <td>xsd:string</td>
    <td>xsd:string</td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), -1)</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;</span> B</a></th>
    <td>xsd:boolean</td>
    <td>xsd:boolean</td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-boolean-less-than">op:boolean-less-than</a>(A, B)</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;</span> B</a></th>
    <td>xsd:dateTime</td>
    <td>xsd:dateTime</td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-dateTime-less-than">op:dateTime-less-than</a>(A, B)</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;</span> B</a></th>
    <td><span class="type numeric">数値</span></td>
    <td><span class="type numeric">数値</span></td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-greater-than">op:numeric-greater-than</a>(A, B)</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;</span> B</a></th>
    <td><span class="type simpleLiteral">シンプルなリテラル</span></td>
    <td><span class="type simpleLiteral">シンプルなリテラル</span></td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(A, B), 1)</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;</span> B</a></th>
    <td>xsd:string</td>
    <td>xsd:string</td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), 1)</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;</span> B</a></th>
    <td>xsd:boolean</td>
    <td>xsd:boolean</td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-boolean-greater-than">op:boolean-greater-than</a>(A, B)</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;</span> B</a></th>
    <td>xsd:dateTime</td>
    <td>xsd:dateTime</td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-dateTime-greater-than">op:dateTime-greater-than</a>(A, B)</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;=</span> B</a></th>
    <td><span class="type numeric">数値</span></td>
    <td><span class="type numeric">数値</span></td>
    <td class="xpathOp">
<a href="#func-logical-or" class="SPARQLoperator">logical-or</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-less-than">op:numeric-less-than</a>(A, B), <a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(A, B))</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;=</span> B</a></th>
    <td><span class="type simpleLiteral">シンプルなリテラル</span></td>
    <td><span class="type simpleLiteral">シンプルなリテラル</span></td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(A, B), 1))</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;=</span> B</a></th>
    <td>xsd:string</td>
    <td>xsd:string</td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), 1))</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;=</span> B</a></th>
    <td>xsd:boolean</td>
    <td>xsd:boolean</td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-boolean-greater-than">op:boolean-greater-than</a>(A, B))</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&lt;=</span> B</a></th>
    <td>xsd:dateTime</td>
    <td>xsd:dateTime</td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-dateTime-greater-than">op:dateTime-greater-than</a>(A, B))</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;=</span> B</a></th>
    <td><span class="type numeric">数値</span></td>
    <td><span class="type numeric">数値</span></td>
    <td class="xpathOp">
<a href="#func-logical-or" class="SPARQLoperator">logical-or</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-greater-than">op:numeric-greater-than</a>(A, B), <a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(A, B))</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;=</span> B</a></th>
    <td><span class="type simpleLiteral">シンプルなリテラル</span></td>
    <td><span class="type simpleLiteral">シンプルなリテラル</span></td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(A, B), -1))</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;=</span> B</a></th>
    <td>xsd:string</td>
    <td>xsd:string</td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-equal">op:numeric-equal</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-compare">fn:compare</a>(<a href="#func-str" class="FAOTtoken">STR</a>(A), <a href="#func-str" class="FAOTtoken">STR</a>(B)), -1))</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;=</span> B</a></th>
    <td>xsd:boolean</td>
    <td>xsd:boolean</td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-boolean-less-than">op:boolean-less-than</a>(A, B))</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th scope="row"><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">&gt;=</span> B</a></th>
    <td>xsd:dateTime</td>
    <td>xsd:dateTime</td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a class="norm" href="www.w3.org/TR/xpath-functions/#func-dateTime-less-than">op:dateTime-less-than</a>(A, B))</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th colspan="5" class="subHeading" scope="col">XPath計算</th>
  </tr>
  <tr>
    <th scope="row"><a href="#rMultiplicativeExpression" title="MultiplicativeExpression">A <span class="FAOTtoken">*</span> B</a></th>
    <td><span class="type numeric">数値</span></td>
    <td><span class="type numeric">数値</span></td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-multiply">op:numeric-multiply</a>(A, B)</td>
    <td><span class="type numeric">数値</span></td>
  </tr>
  <tr>
    <th scope="row"><a href="#rMultiplicativeExpression" title="MultiplicativeExpression">A <span class="FAOTtoken">/</span> B</a></th>
    <td><span class="type numeric">数値</span></td>
    <td><span class="type numeric">数値</span></td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-divide">op:numeric-divide</a>(A, B)</td>
    <td>
<span class="type numeric">数値</span>; but xsd:decimal if both operands are xsd:integer</td>
  </tr>
  <tr>
    <th scope="row"><a href="#rAdditiveExpression" title="AdditiveExpression">A <span class="FAOTtoken">+</span> B</a></th>
    <td><span class="type numeric">数値</span></td>
    <td><span class="type numeric">数値</span></td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-add">op:numeric-add</a>(A, B)</td>
    <td><span class="type numeric">数値</span></td>
  </tr>
  <tr>
    <th scope="row"><a href="#rAdditiveExpression" title="AdditiveExpression">A <span class="FAOTtoken">-</span> B</a></th>
    <td><span class="type numeric">数値</span></td>
    <td><span class="type numeric">数値</span></td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-numeric-subtract">op:numeric-subtract</a>(A, B)</td>
    <td><span class="type numeric">数値</span></td>
  </tr>
  <tr>
    <th colspan="5" class="subHeading" scope="col">SPARQLテスト</th>
  </tr>
  <tr>
    <th><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">=</span> B</a></th>
    <td><span class="type RDFterm">RDF用語</span></td>
    <td><span class="type RDFterm">RDF用語</span></td>
    <td class="xpathOp">
<a href="#func-RDFterm-equal" class="SPARQLoperator">RDFterm-equal</a>(A, B)</td>
    <td>xsd:boolean</td>
  </tr>
  <tr>
    <th><a href="#rRelationalExpression" title="RelationalExpression">A <span class="FAOTtoken">!=</span> B</a></th>
    <td><span class="type RDFterm">RDF用語</span></td>
    <td><span class="type RDFterm">RDF用語</span></td>
    <td class="xpathOp">
<a class="norm" href="www.w3.org/TR/xpath-functions/#func-not">fn:not</a>(<a href="#func-RDFterm-equal" class="SPARQLoperator">RDFterm-equal</a>(A, B))</td>
    <td>xsd:boolean</td>
  </tr>
</tbody>
</table>

<p><a id="ebv-arg" name="ebv-arg"></a>「(EBV)」と共にマーク付けされたxsd:boolean関数の引数は、<a href="#ebv">その引数の有効なブール値</a>の評価によるxsd:booleanに強制されます:。</p>

<div class="div3">

<h4>
<a name="operatorExtensibility" id="operatorExtensibility"></a>17.3.1 演算子の拡張性</h4>

<p>SPARQLの言語拡張は、演算子と演算子関数の間の付加的な関連付けを提供でき、これは、上記の表に列を加えることに等しいです。付加的な演算子は、上記で定義したセマンティクスにおける型エラー以外の結果に代わる結果をもたらさないかもしれません。この規則の結果は、<code>FILTER</code>を未拡張の実装として適用した後に、SPARQLの<code>FILTER</code>が<em>少なくとも</em>同じ中間バインディングを作成するかもしれないというものです。</p>

<p>「<code>ORDER BY</code>句で用いられるときに、オペランドの相対的な順序付けを制御すると予想されます。</p>

</div>
</div>
<div class="div2">

<h3>
<a name="SparqlOps" id="SparqlOps"></a>17.4 関数の定義</h3>

<p>この項では、SPARQLクエリ言語で導入された演算子と関数を定義します。例では、適切な文法構造によって呼び出される際の演算子の動作を示しています。</p>

<div class="div3">

<h4>
<a name="func-forms" id="func-forms"></a>17.4.1 関数の形式</h4>

<div class="div4">

<h5>
<a name="func-bound" id="func-bound"></a>17.4.1.1 バインド</h5>

<pre class="prototype"><span class="return">xsd:boolean</span>  <span class="operator">BOUND</span> (<span class="type">variable</span> <span class="name">var</span>)</pre>

<p><code>var</code>が値にバインドされている場合は、真（<code>true</code>）を返します。そうでない場合は、偽（false）を返します。NaNまたはINFの値を持つ変数は、バインドされているとみなされます。</p>

<div class="exampleGroup">

<p>データ:</p>

<pre class="data">@prefix foaf:        &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix dc:          &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix xsd:          &lt;http://www.w3.org/2001/XMLSchema#&gt; .

_:a  foaf:givenName  "Alice".

_:b  foaf:givenName  "Bob" .
_:b  dc:date         "2005-04-04T04:04:04Z"^^xsd:dateTime .</pre>
<div class="queryGroup">

<pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX xsd:   &lt;http://www.w3.org/2001/XMLSchema#&gt;
SELECT ?givenName
 WHERE { ?x foaf:givenName  ?givenName .
         OPTIONAL { ?x dc:date ?date } .
         FILTER ( bound(?date) ) }</pre>

データ:

<div class="result">

<table class="resultTable">
<tbody>
  <tr>
    <th>givenName</th>
  </tr>
  <tr>
    <td>"Bob"</td>
  </tr>
</tbody>
</table>

</div>
</div>

<p>変数を導入する<a><span class="term">OPTIONAL</span></a><a>グラフ・パターン</a>を指定し、変数がバインドされていない（<a><span class="term">not</span></a> <a><span class="term">bound</span></a>）ことを確認するテストを行うことによってグラフ・パターンが表されてい<em>ない</em>ことをテストできます。これは論理プログラミングでは、<em>失敗による否定</em>（Negation as Failure）と呼ばれます。</p>

<div class="queryGroup">

<p>このクエリは、名前（<code>name</code>）を持つが、日付（<code>date</code>）の表現を持た<em>ない</em>人にマッチします。</p>

<pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX dc:   &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT ?name
 WHERE { ?x foaf:givenName  ?name .
         OPTIONAL { ?x dc:date ?date } .
         FILTER (!bound(?date)) }</pre>

<p>クエリ結果:</p>

<div class="result">

<table class="resultTable">
<tbody>
  <tr>
    <th>name</th>
  </tr>
  <tr>
    <td>"Alice"</td>
  </tr>
</tbody>
</table>

</div>
</div>
</div>

<p>Bobの<code>dc:date</code>は既知であったため、<code>"Bob"</code>はクエリのソリューションにはなりませんでした。</p>

</div>
<div class="div4">

<h5>
<a name="func-if" id="func-if"></a>17.4.1.2 IF</h5>

<pre class="prototype"><span class="return">rdfTerm</span>  <span class="operator">IF</span> (<span class="expression">expression1</span>, <span class="expression">expression2</span>, <span class="expression">expression3</span>)</pre>

<p><code>IF</code>関数形式は、最初の引数を評価して、それを<a href="#ebv">有効なブール値</a>として解釈し、EBVが真（true）であれば<code>expression2</code>の値を返し、そうでなければ<code>expression3</code>の値を返します。<code>expression2</code>と<code>expression3</code>のうちの1つのみが評価されます。最初の引数の評価によってエラーが生じる場合、エラーは<code>IF</code>式の評価が原因で生じます。</p>

<p>例: ?x = 2, ?z = 0であり、?yがクエリ・ソリューションにおいてバインドされていないとすると、次のようになります。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>IF(?x = 2, "yes", "no")</code></td>
    <td>「yes」を返す。</td>
  </tr>
  <tr>
    <td><code>IF(bound(?y), "yes", "no")</code></td>
    <td>「no」を返す。</td>
  </tr>
  <tr>
    <td><code>IF(?x=2, "yes", 1/?z)</code></td>
    <td>「yes」を返し、式<code>1/?z</code>は評価されない。</td>
  </tr>
  <tr>
    <td><code>IF(?x=1, "yes", 1/?z)</code></td>
    <td>エラーが生じる。</td>
  </tr>
  <tr>
    <td><code>IF("2" &gt; 1, "yes", "no")</code></td>
    <td>エラーが生じる。</td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-coalesce" id="func-coalesce"></a>17.4.1.3 COALESCE</h5>

<pre class="prototype"><span class="return">rdfTerm</span>  <span class="operator">COALESCE</span>(<span class="expression">expression, ....</span>)</pre>

<p><code>COALESCE</code>関数形式は、エラーなしに評価した最初の式のRDF用語の値を返します。SPARQLでは、バインドされていない変数を評価すると、エラーが生じます。</p>

<p>引数の評価結果がRDF用語にならない場合、エラーが生じます。エラーのない式の評価結果がない場合、エラーが生じます。</p>

<p>例: ?x = 2であり、?yがクエリ・ソリューションにおいてバインドされていないとすると、次のようになります。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>COALESCE(?x, 1/0)</code></td>
    <td>2を返す。<code>x</code>の値</td>
  </tr>
  <tr>
    <td><code>COALESCE(1/0, ?x)</code></td>
    <td>2を返す。</td>
  </tr>
  <tr>
    <td><code>COALESCE(5, ?x)</code></td>
    <td>5を返す。</td>
  </tr>
  <tr>
    <td><code>COALESCE(?y, 3)</code></td>
    <td>3を返す。</td>
  </tr>
  <tr>
    <td><code>COALESCE(?y)</code></td>
    <td>
<code>y</code>がバインドされていないため、エラーが生じる。</td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-filter-exists" id="func-filter-exists"></a>17.4.1.4 NOT EXISTSとEXISTS</h5>

<p>グラフ・パターンを取るフィルタ演算子<code>EXISTS</code>があります。<code>EXISTS</code>は、パターンが、現在のグループ・グラフ・パターン、データセットとクエリ評価のこの時点の<a href="#defn_ActiveGraph">アクティブ・グラフ</a>のバインディングを与えられたデータセットにマッチするかどうかに基づき、真（<code>true</code>）/偽（<code>false</code>）を返します。変数の追加バインディングは発生しません。<code>NOT EXISTS</code>形式は、<code>fn:not(EXISTS{...})</code>に置換します。</p>

<pre class="prototype"> <span class="return">xsd:boolean</span>  <span class="operator">NOT EXISTS</span> { <span class="pattern">pattern</span> }</pre>

<p><code>pattern</code>がマッチすれば、偽（<code>false</code>）を返します。そうでなければ、真（true）を返します</p>

<p><code>NOT EXISTS { pattern }</code>は、<code>fn:not(EXISTS { pattern })</code>と同等ではありません。</p>

<pre class="prototype"> <span class="return">xsd:boolean</span>  <code>EXISTS</code> { <span class="pattern">pattern</span> }</pre>

<p><code>pattern</code>がマッチすれば、真（<code>true</code>）を返します。そうでなければ、偽（false）を返します。</p>

<p>現在のソリューション・マッピングでバインドされている<code>pattern</code>の変数は、それが<a href="www.w3.org/TR/rdf-sparql-query/#defn_sparqlSolutionMapping">ソリューション・マッピング</a>で持っている値を取ります。現在のソリューション・マッピングでバインドされていない<code>pattern</code>の変数は、パターン・マッチングに加わります。</p>

<p>これを容易にするために、SPARQL代数式を評価し、フィルタ・オペレーションでテストされているソリューション・マッピングを与えられたパターンにソリューションがあるかどうかに基づいて、真（true）または偽（false）を返す関数<a href="#defn_exists">Exists</a>を導入しました。</p>

</div>
<div class="div4">

<h5>
<a name="func-logical-or" id="func-logical-or"></a>17.4.1.5 logical-or</h5>

<pre class="prototype"> <span class="return">xsd:boolean</span>  <span class="type">xsd:boolean</span> <span class="name">left</span> <span class="operator">||</span> <span class="type">xsd:boolean</span> <span class="name">right</span></pre>

<p>左（<code>left</code>）と右（<code>right</code>）の論理和（<code>OR</code>）を返します。<span class="SPARQLoperator">logical-or</span>がその引数の<a href="#ebv">有効なブール値</a>に基づいて演算を行うことに注意してください。</p>

<p>注意: <code>||</code>演算子のエラーの処理に関しては、17.2項<a href="#evaluation">フィルタ評価</a>を参照してください。</p>

</div>
<div class="div4">

<h5>
<a name="func-logical-and" id="func-logical-and"></a>17.4.1.6 logical-and</h5>

<pre class="prototype"> <span class="return">xsd:boolean</span>  <span class="type">xsd:boolean</span> <span class="name">left</span> <span class="operator">&amp;&amp;</span> <span class="type">xsd:boolean</span> <span class="name">right</span></pre>

<p>左（<code>left</code>）と右（<code>right</code>）の論理積（<code>AND</code>）を返します。<span class="SPARQLoperator">logical-and</span>がその引数の<a href="#ebv">有効なブール値</a>に基づいて演算することに注意してください。</p>

<p>注意: <code>&amp;&amp;</code>演算子のエラーの処理に関しては、17.2項<a href="#evaluation">フィルタ評価</a>を参照してください。</p>

</div>
<div class="div4">

<h5>
<a name="func-RDFterm-equal" id="func-RDFterm-equal"></a>17.4.1.7 RDFterm-equal</h5>

<pre class="prototype"> <span class="return">xsd:boolean</span>  <span class="type">RDF term</span> <span class="name">term1</span> <span class="operator">=</span> <span class="type">RDF用語</span> <span class="name">term2</span></pre>

<p><a class="norm" href="www.w3.org/TR/rdf-concepts/">RDF（Resource Description Framework）: 概念および抽象構文</a>[<a href="#CONCEPTS">CONCEPTS</a>]で定義されているとおり、<code>term1</code>と<code>term2</code>が同じRDF用語<sup><a href="#func-RDFterm-equal-foot1" class="footnote">*</a></sup>でない場合は、TRUEを返します。両方の引数がリテラルであるけれども同じRDF用語ではない場合は、型エラーを起こし、そうでない場合は、FALSEを返します。次のいずれかが真である場合は、<code>term1</code>と<code>term2</code>は同じです。</p>

<ul>
  <li>
<span class="name">term1</span>と<span class="name">term2</span>は、[<a href="#CONCEPTS">CONCEPTS</a>]の<a href="www.w3.org/TR/rdf-concepts/#section-Graph-URIref">6.4 RDF URI参照</a>で定義されているとおり、同等なIRIです。</li>
  <li>
<span class="name">term1</span>と<span class="name">term2</span>は、[<a href="#CONCEPTS">CONCEPTS</a>]の<a class="norm" href="www.w3.org/TR/rdf-concepts/#section-Literal-Equality">6.5.1 リテラルの同等性</a>で定義されているとおり、同等な<span class="literal type">リテラル</span>です。</li>
  <li>
<span class="name">term1</span>と<span class="name">term2</span>は、[<a href="#CONCEPTS">CONCEPTS</a>]の<a class="norm" href="www.w3.org/TR/rdf-concepts/#section-blank-nodes">6.6 空白ノード</a>で述べられているとおり、同じ<span class="bnode type">空白ノード</span>です。</li>
</ul>
<div class="exampleGroup">

<pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice".
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Ms A.".
_:b  foaf:mbox       &lt;mailto:alice@work.example&gt; .
              </pre>
<div class="queryGroup">

<p>このクエリは、複数の<code>foaf:name</code>トリプルを持つ人を発見します。</p>

<pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name1 ?name2
WHERE { ?x foaf:name  ?name1 ;
        foaf:mbox  ?mbox1 .
        ?y foaf:name  ?name2 ;
        foaf:mbox  ?mbox2 .
        FILTER (?mbox1 = ?mbox2 &amp;&amp; ?name1 != ?name2)
      }</pre>

<p>クエリ結果:</p>

<div class="result">

<table class="resultTable">
<tbody>
  <tr>
    <th>name1</th>
    <th>name2</th>
  </tr>
  <tr>
    <td>"Alice"</td>
    <td>"Ms A."</td>
  </tr>
  <tr>
    <td>"Ms A."</td>
    <td>"Alice"</td>
  </tr>
</tbody>
</table>

</div>
</div>
</div>

<p>特定の日時（2005年の元日（+00:00の時間帯尺度））にアノテーションが付与されたドキュメントに関するこのクエリは、RDF用語は同じではありませんが、同等な値を持っています。</p>

<div class="exampleGroup">

<pre class="data">@prefix a:          &lt;http://www.w3.org/2000/10/annotation-ns#&gt; .
@prefix dc:         &lt;http://purl.org/dc/elements/1.1/&gt; .

_:b   a:annotates   &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
_:b   dc:date       "2004-12-31T19:00:00-05:00"^^&lt;http://www.w3.org/2001/XMLSchema#dateTime&gt; .</pre>
<div class="queryGroup">

<pre class="query">PREFIX a:      &lt;http://www.w3.org/2000/10/annotation-ns#&gt;
PREFIX dc:     &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX xsd:    &lt;http://www.w3.org/2001/XMLSchema#&gt;

SELECT ?annotates
WHERE { ?annot  a:annotates  ?annotates .
        ?annot  dc:date      ?date .
        FILTER ( ?date = xsd:dateTime("2005-01-01T00:00:00Z") ) 
      }</pre>
<div class="result">

<table class="resultTable">
<tbody>
  <tr>
    <th>annotates</th>
  </tr>
  <tr>
    <td>&lt;http://www.w3.org/TR/rdf-sparql-query/&gt;</td>
  </tr>
</tbody>
</table>

</div>
</div>
</div>
<div id="func-RDFterm-equal-foot1" class="footnote">

<p><sup>*</sup> 2つの型付きリテラルにRDFterm-equalを呼び出すことで、同等な値をテストします。拡張された実装には、付加的なデータ型のサポートがあるかもしれません。未サポートのデータ型（および、異なる字句形式とデータ型IRI）の同等性をテストするクエリを処理する実装はエラーを返し、値が同等かどうかを決定できなかったことを示します。例えば、<span class="queryExcerpt untested"><code>"iiii"^^my:romanNumeral = "iv"^^my:romanNumeral</code></span>か<span class="queryExcerpt untested"><code>"iiii"^^my:romanNumeral != "iv"^^my:romanNumeral</code></span>のいずれかのテストを行った場合、未拡張の実装にエラーが生じます。</p>

</div>
</div>
<div class="div4">

<h5>
<a name="func-sameTerm" id="func-sameTerm"></a>17.4.1.8 sameTerm</h5>

<pre class="prototype"> <span class="return">xsd:boolean</span>  <span class="operator">sameTerm</span> (<span class="type"><span class="type RDFterm">RDF用語</span></span> <span class="name">term1</span>, <span class="type"><span class="type RDFterm">RDF term</span></span> <span class="name">term2</span>)</pre>

<p><a class="norm" href="www.w3.org/TR/rdf-concepts/">RDF（Resource Description Framework）: 概念および抽象構文</a>[<a href="#CONCEPTS">CONCEPTS</a>]で定義されているとおり、<code>term1</code>と<code>term2</code>が同じRDF用語である場合は、TRUEを返し、そうでない場合は、FALSEを返します。</p>

<div class="exampleGroup">

<pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice".
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Ms A.".
_:b  foaf:mbox       &lt;mailto:alice@work.example&gt; .</pre>
<div class="queryGroup">

<p>このクエリは、複数の<code>foaf:name</code>トリプルを持つ人を発見します。</p>

<pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name1 ?name2
WHERE { ?x foaf:name  ?name1 ;
        foaf:mbox  ?mbox1 .
         ?y foaf:name  ?name2 ;
         foaf:mbox  ?mbox2 .
         FILTER (sameTerm(?mbox1, ?mbox2) &amp;&amp; !sameTerm(?name1, ?name2))
      } </pre>

<p>クエリ結果:</p>

<div class="result">

<table class="resultTable">
<tbody>
  <tr>
    <th>name1</th>
    <th>name2</th>
  </tr>
  <tr>
    <td>"Alice"</td>
    <td>"Ms A."</td>
  </tr>
  <tr>
    <td>"Ms A."</td>
    <td>"Alice"</td>
  </tr>
</tbody>
</table>

</div>
</div>
</div>

<p><span class="operator">RDFterm-equal</span>とは異なり、<span class="operator">sameTerm</span>は、未サポートのデータ型を持つ非同等な<span class="type typedLiteral">型付きリテラル</span>をテストするために使用できます。</p>

<div class="exampleGroup">

<pre class="data">@prefix :          &lt;http://example.org/WMterms#&gt; .
@prefix t:         &lt;http://example.org/types#&gt; .

_:c1  :label        "Container 1" .
_:c1  :weight       "100"^^t:kilos .
_:c1  :displacement  "100"^^t:liters .

_:c2  :label        "Container 2" .
_:c2  :weight       "100"^^t:kilos .
_:c2  :displacement  "85"^^t:liters .

_:c3  :label        "Container 3" .
_:c3  :weight       "85"^^t:kilos .
_:c3  :displacement  "85"^^t:liters .</pre>
<div class="queryGroup">

<pre class="query">PREFIX  :      &lt;http://example.org/WMterms#&gt;
PREFIX  t:     &lt;http://example.org/types#&gt;

SELECT ?aLabel1 ?bLabel
WHERE { ?a  :label        ?aLabel .
        ?a  :weight       ?aWeight .
        ?a  :displacement ?aDisp .

        ?b  :label        ?bLabel .
        ?b  :weight       ?bWeight .
        ?b  :displacement ?bDisp .

        FILTER ( sameTerm(?aWeight, ?bWeight) &amp;&amp; !sameTerm(?aDisp, ?bDisp)) }</pre>
<div class="result">

<table class="resultTable">
<tbody>
  <tr>
    <th>aLabel</th>
    <th>bLabel</th>
  </tr>
  <tr>
    <td>"Container 1"</td>
    <td>"Container 2"</td>
  </tr>
  <tr>
    <td>"Container 2"</td>
    <td>"Container 1"</td>
  </tr>
</tbody>
</table>

</div>
</div>
</div>

<p><code>"100"^^t:kilos = "85"^^t:kilos</code>のテストが、その生成されうるソリューションを排除して、エラーをもたらすため、同じ重さの箱のテストは「=」演算子（<a href="#func-RDFterm-equal" class="SPARQLoperator">RDFterm-equal</a>）でも行えます。</p>

</div>
<div class="div4">

<h5>
<a name="func-in" id="func-in"></a>17.4.1.9 IN</h5>

<pre class="prototype"><span class="return">boolean</span>  <code>rdfTerm</code> <span class="operator">IN</span> (<span class="expression">expression</span>, <span class="expression">...</span>)</pre>

<p><code>IN</code>演算子は、左側のRDF用語が右側の式のリストの値で見つかるか否かをテストします。このテストは、<a href="#OperatorMapping">演算子マッピング</a>で定められているとおり、「=」演算子で行い、それによって同じ値に対するテストが行われます。</p>

<p>右側の0の用語のリストは、正当です。</p>

<p>テストを行っているRDF用語が用語のリストの他の場所で見つからなければ、比較におけるエラーにより、<code>IN</code>式にエラーが生じます。</p>

<p>この<code>IN</code>演算子は、次のSPARQL式と同等です。</p>

<pre>(lhs = expression1) || (lhs = expression2) || ...</pre>

<p>例:</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>2 IN (1, 2, 3)</code></td>
    <td>真</td>
  </tr>
  <tr>
    <td><code>2 IN ()</code></td>
    <td>偽</td>
  </tr>
  <tr>
    <td><code>2 IN (&lt;http://example/iri&gt;, "str", 2.0)</code></td>
    <td>真</td>
  </tr>
  <tr>
    <td><code>2 IN (1/0, 2)</code></td>
    <td>真</td>
  </tr>
  <tr>
    <td><code>2 IN (2, 1/0)</code></td>
    <td>真</td>
  </tr>
  <tr>
    <td><code>2 IN (3, 1/0)</code></td>
    <td>エラーが生じる。</td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-not-in" id="func-not-in"></a>17.4.1.10 NOT IN</h5>

<pre class="prototype"><span class="return">boolean</span>  <code>rdfTerm</code> <span class="operator">NOT IN</span> (<span class="expression">expression</span>, <span class="expression">...</span>)</pre>

<p><code>NOT IN</code>演算子は、左側のRDF用語が右側の式のリストの値で見つからないか否かのテストを行います。このテストは、<a href="#OperatorMapping">演算子マッピング</a>で定められているとおり、「!=」演算子で行い、それによって同じではない値に対するテストが行われます。</p>

<p>右側の0の用語のリストは正当です。</p>

<p>テストを行っているRDF用語が用語のリストの他の場所のリストで見つからなければ、比較におけるエラーにより、NOT IN式にエラーが生じます。</p>

<p><code>NOT IN</code>演算子は、次のSPARQL式と同等です。</p>

<pre>(lhs != expression1) &amp;&amp; (lhs != expression2) &amp;&amp; ...</pre>

<p><code>NOT IN (...)</code>は、<code>!(IN (...))</code>と同等です。</p>

<p>例:</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>2 NOT IN (1, 2, 3)</code></td>
    <td>偽</td>
  </tr>
  <tr>
    <td><code>2 NOT IN ()</code></td>
    <td>真</td>
  </tr>
  <tr>
    <td><code>2 NOT IN (&lt;http://example/iri&gt;, "str", 2.0)</code></td>
    <td>偽</td>
  </tr>
  <tr>
    <td><code>2 NOT IN (1/0, 2)</code></td>
    <td>偽</td>
  </tr>
  <tr>
    <td><code>2 NOT IN (2, 1/0)</code></td>
    <td>偽</td>
  </tr>
  <tr>
    <td><code>2 NOT IN (3, 1/0)</code></td>
    <td>エラーが生じる。</td>
  </tr>
</tbody>
</table>

</div>
</div>
</div>
<div class="div3">

<h4>
<a name="func-rdfTerms" id="func-rdfTerms"></a>17.4.2 RDF用語の関数</h4>

<div class="div4">

<h5>
<a name="func-isIRI" id="func-isIRI"></a>17.4.2.1 isIRI</h5>

<pre class="prototype"> <span class="return">xsd:boolean</span>  <span class="operator">isIRI</span> (<span class="type">RDF term</span> <span class="name">term</span>)
 <span class="return">xsd:boolean</span>  <span class="operator">isURI</span> (<span class="type">RDF term</span> <span class="name">term</span>)</pre>

<p>用語（<code>term</code>）が<span class="type IRI">IRI</span>である場合は、真（<code>true</code>）を返します。そうでない場合は、偽（<code>false</code>）を返します。<span class="operator">isURI</span>は、<span class="operator">isIRI</span>演算子の別のスペルです。</p>

<div class="exampleGroup">

<pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice".
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       "bob@work.example" .
              </pre>
<div class="queryGroup">

<p>このクエリは、名前（<code>name</code>）と、IRIである<code>mbox</code>を持つ人にマッチします。</p>

<pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
 WHERE { ?x foaf:name  ?name ;
            foaf:mbox  ?mbox .
         FILTER isIRI(?mbox) }</pre>
<p>クエリ結果:</p>

<div class="result">

<table class="resultTable">
<tbody>
  <tr>
    <th>name</th>
    <th>mbox</th>
  </tr>
  <tr>
    <td>"Alice"</td>
    <td>&lt;mailto:alice@work.example&gt;</td>
  </tr>
</tbody>
</table>

</div>
</div>
</div>
</div>
<div class="div4">

<h5>
<a name="func-isBlank" id="func-isBlank"></a>17.4.2.2 isBlank</h5>

<pre class="prototype"> <span class="return">xsd:boolean</span>  <span class="operator">isBlank</span> (<span class="type"><span class="type">RDF term</span></span> <span class="name">term</span>)</pre>

<p>用語（<code>term</code>）が<span class="type bNode">空白ノード</span>である場合は、真（<code>true</code>）を返します。そうでない場合は、偽（<code>false</code>）を返します。</p>

<div class="exampleGroup">

<pre class="data">@prefix a:          &lt;http://www.w3.org/2000/10/annotation-ns#&gt; .
@prefix dc:         &lt;http://purl.org/dc/elements/1.1/&gt; .
@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .
_:a   a:annotates   &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
_:a   dc:creator    "Alice B. Toeclips" .

_:b   a:annotates   &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
_:b   dc:creator    _:c .
_:c   foaf:given    "Bob".
_:c   foaf:family   "Smith".</pre>
<div class="queryGroup">

<p>このクエリは、名前を表すためにFOAF語彙の述語を用いている<code>dc:creator</code>を持つ人にマッチします。</p>

<pre class="query">PREFIX a:      &lt;http://www.w3.org/2000/10/annotation-ns#&gt;
PREFIX dc:     &lt;http://purl.org/dc/elements/1.1/&gt;
PREFIX foaf:   &lt;http://xmlns.com/foaf/0.1/&gt;

SELECT ?given ?family
WHERE { ?annot  a:annotates  &lt;http://www.w3.org/TR/rdf-sparql-query/&gt; .
  ?annot  dc:creator   ?c .
  OPTIONAL { ?c  foaf:given   ?given ; foaf:family  ?family } .
  FILTER isBlank(?c)
}</pre>

<p>クエリ結果:</p>

<div class="result">

<table class="resultTable">
<tbody>
  <tr>
    <th>given</th>
    <th>family</th>
  </tr>
  <tr>
    <td>"Bob"</td>
    <td>"Smith"</td>
  </tr>
</tbody>
</table>

</div>
</div>
</div>

<p>この例では、<code>dc:creator</code>という述語の目的語が2つありましたが、たった1つの（<code>_:c</code>）が空白ノードでした。</p>

</div>
<div class="div4">

<h5>
<a name="func-isLiteral" id="func-isLiteral"></a>17.4.2.3 isLiteral</h5>

<pre class="prototype"> <span class="return">xsd:boolean</span>  <span class="operator">isLiteral</span> (<span class="type"><span class="type">RDF term</span></span> <span class="name">term</span>)</pre>

<p>用語（<code>term</code>）が<span class="type literal">リテラル</span>である場合、真（<code>true</code>）を返します。そうでない場合は、偽（<code>false</code>）を返します。</p>

<div class="exampleGroup">

<pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .
              
_:a  foaf:name       "Alice".
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       "bob@work.example" .</pre>
<div class="queryGroup">

<p>このクエリは、名前（<code>name</code>）と、リテラルである<code>mbox</code>を持つ人にマッチする点を除いて、<a href="#func-isIRI">17.4.2.1</a>のものと類似しています。これは、エラーのあるデータを探すために使用できるでしょう（<code>foaf:mbox</code>は、目的語として1つのIRIのみを持っているはずです）。</p>

<pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
WHERE { ?x foaf:name  ?name ;
        foaf:mbox  ?mbox .
        FILTER isLiteral(?mbox) }</pre>

<p>クエリ結果:</p>

<div class="result">

<table class="resultTable">
<tbody>
  <tr>
    <th>name</th>
    <th>mbox</th>
  </tr>
  <tr>
    <td>"Bob"</td>
    <td>"bob@work.example"</td>
  </tr>
</tbody>
</table>

</div>
</div>
</div>
</div>
<div class="div4">

<h5>
<a name="func-isNumeric" id="func-isNumeric"></a>17.4.2.4 isNumeric</h5>

<pre class="prototype"> <span class="return">xsd:boolean</span>  <span class="operator">isNumeric</span> (<span class="type"><span class="type">RDF term</span></span> <span class="name">term</span>)</pre>

<p>用語（<code>term</code>）が数値であれば、真（<code>true</code>）を返します。そうでなければ偽（<code>false</code>）を返します。用語（<code>term</code>）は、それが適切なデータ・タイプ（<a href="#operandDataTypes">オペランド・データ型</a>の項を参照）を持ち、有効な字句形式を持っていれば数値で、数値の引数を取る関数と演算子の有効な引数になります。</p>

<p>例:</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>isNumeric(12)</code></td>
    <td>真</td>
  </tr>
  <tr>
    <td><code>isNumeric("12")</code></td>
    <td>偽</td>
  </tr>
  <tr>
    <td><code>isNumeric("12"^^xsd:nonNegativeInteger)</code></td>
    <td>真</td>
  </tr>
  <tr>
    <td><code>isNumeric("1200"^^xsd:byte)</code></td>
    <td>偽</td>
  </tr>  <tr>
    <td><code>isNumeric(&lt;http://example/&gt;)</code></td>
    <td>偽</td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-str" id="func-str"></a>17.4.2.5 str</h5>

<pre class="prototype"> <span class="return"><span class="type">simple literal</span></span>  <span class="operator">STR</span> (<span class="type"><span class="type literal">literal</span></span> <span class="name">ltrl</span>)
 <span class="return"><span class="type">simple literal</span></span>  <span class="operator">STR</span> (<span class="type"><span class="type IRI">IRI</span></span> <span class="name">rsrc</span>)</pre>

<p><code>ltrl</code>（<span class="type literal">リテラル</span>）の<span class="type lexicalForm">字句形式</span>を返し、<code>rsrc</code>（<span class="type IRI">IRI</span>）コードポイント表現を返します。これは、IRIの部分、例えば、ホスト名を調べるのに役に立ちます。</p>

<div class="exampleGroup">

<pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice".
_:a  foaf:mbox       &lt;mailto:alice@work.example&gt; .

_:b  foaf:name       "Bob" .
_:b  foaf:mbox       &lt;mailto:bob@home.example&gt; .</pre>
<div class="queryGroup">

<p>このクエリは、次のとおり、自分達のfoafプロフィールで<code>work.example</code>のアドレスを使用する人々の集合を選び出します。</p>

<pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
 WHERE { ?x foaf:name  ?name ;
            foaf:mbox  ?mbox .
         FILTER regex(str(?mbox), "@work\\.example$") }</pre>

<p>クエリ結果:</p>

<div class="result">

<table class="resultTable">
<tbody>
  <tr>
    <th>name</th>
    <th>mbox</th>
  </tr>
  <tr>
    <td>"Alice"</td>
    <td>&lt;mailto:alice@work.example&gt;</td>
  </tr>
</tbody>
</table>

</div>
</div>
</div>
</div>
<div class="div4">

<h5>
<a name="func-lang" id="func-lang"></a>17.4.2.6 lang</h5>

<pre class="prototype"> <span class="return"><span class="type">simple literal</span></span>  <span class="operator">LANG</span> (<span class="type"><span class="type literal">literal</span></span> <span class="name">ltrl</span>)</pre>

<p><code>ltrl</code>の<span class="type langTag">言語タグ</span>（それがある場合）を返します。<code>ltrl</code>に<span class="type langTag">言語タグ</span>がない場合は、<code>""</code>を返します。RDFデータ・モデルが空の<span class="type langTag">言語タグ</span>を持つリテラルを含んでいないことに注意してください。</p>

<div class="exampleGroup">

<pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Robert"@en.
_:a  foaf:name       "Roberto"@es.
_:a  foaf:mbox       &lt;mailto:bob@work.example&gt; .</pre>
<div class="queryGroup">

<p>このクエリは、スペイン語の<code>foaf:name</code>と<code>foaf:mbox</code>を発見します。</p>

<pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name ?mbox
 WHERE { ?x foaf:name  ?name ;
            foaf:mbox  ?mbox .
         FILTER ( lang(?name) = "es" ) }</pre>

<p>クエリ結果:</p>

<div class="result">

<table class="resultTable">
<tbody>
  <tr>
    <th>name</th>
    <th>mbox</th>
  </tr>
  <tr>
    <td>"Roberto"@es</td>
    <td>&lt;mailto:bob@work.example&gt;</td>
  </tr>
</tbody>
</table>

</div>
</div>
</div>
</div>
<div class="div4">

<h5>
<a name="func-datatype" id="func-datatype"></a>17.4.2.7 datatype</h5>

<pre class="prototype"> <span class="return"><span class="type IRI">iri</span></span>  <span class="operator">DATATYPE</span> (<span class="type"><span class="type">literal</span></span> <span class="name">literal</span>)</pre>

<p>リテラル（<code>literal</code>）の<span class="type datatypeIRI">データ型IRI</span>を返します。</p>

<ul>
  <li>リテラルが型付きリテラルであれば、データ型IRIを返します。</li>
  <li>リテラルがシンプルなリテラルであれば、<code>xsd:string</code>を返します。</li>
  <li>リテラルが言語タグ付きリテラルであれば、<code>rdf:langString</code>を返します。</li>
</ul>
<div class="exampleGroup">

<pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix eg:         &lt;http://biometrics.example/ns#&gt; .
@prefix xsd:        &lt;http://www.w3.org/2001/XMLSchema#&gt; .

_:a  foaf:name       "Alice".
_:a  eg:shoeSize     "9.5"^^xsd:float .

_:b  foaf:name       "Bob".
_:b  eg:shoeSize     "42"^^xsd:integer .</pre>
<div class="queryGroup">

<p>このクエリは、整数であるshoeSizeを持つすべての人の<code>foaf:name</code>と<code>foaf:shoeSize</code>を発見します。</p>

<pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX xsd:  &lt;http://www.w3.org/2001/XMLSchema#&gt;
PREFIX eg:   &lt;http://biometrics.example/ns#&gt;
SELECT ?name ?shoeSize
 WHERE { ?x foaf:name  ?name ; eg:shoeSize  ?shoeSize .
         FILTER ( datatype(?shoeSize) = xsd:integer ) }</pre>

<p>クエリ結果:</p>

<div class="result">

<table class="resultTable">
<tbody>
  <tr>
    <th>name</th>
    <th>shoeSize</th>
  </tr>
  <tr>
    <td>"Bob"</td>
    <td>42</td>
  </tr>
</tbody>
</table>

</div>
</div>
</div>
<div class="note">

<p><a href="www.w3.org/TR/rdf-sparql-query/">SPARQL 1.0</a>では、<code>DATATYPE</code>関数は、言語タグ付きリテラルに対しては定義されていませんでした。したがって、<code>DATATYPE</code>が言語タグ付きリテラルで呼び出されると、未拡張の実装ではエラーが生じるでしょう。<a href="#operatorExtensibility">演算子の拡張性</a>では、エラーを発生させるのではなく、実装が結果を返すことが認められています。SPARQL 1.1は、言語タグ付きリテラルに適用された<code>DATATYPE</code>の結果を<code>rdf:langString</code>と定義しています。</p>

</div>
<div class="wgNote">SPARQLワーキンググループは、RDFワーキンググループの最新の草案に基づいて<code>rdf:langString</code>を使用しています。これは、<code>rdf:langString</code>が最新のRDF勧告の一部になるまで/ならない限り、実験中（かつ、非規範的）であると考えるべきです。</div>
</div>
<div class="div4">

<h5>
<a name="func-iri" id="func-iri"></a>17.4.2.8 IRI</h5>

<pre class="prototype"> <span class="return">iri</span>  <span class="operator">IRI</span>(<code>simple literal</code>)
 <span class="return">iri</span>  <span class="operator">IRI</span>(<span class="type">xsd:string</span>)
 <span class="return">iri</span>  <span class="operator">IRI</span>(<span class="type">iri</span>)
 <span class="return">iri</span>  <span class="operator">URI</span>(<code>simple literal</code>)
 <span class="return">iri</span>  <span class="operator">URI</span>(<span class="type">xsd:string</span>)
 <span class="return">iri</span>  <span class="operator">URI</span>(<span class="type">iri</span>)</pre>

<p><code>IRI</code>関数は、文字列の引数の解決により、IRIを生成します（<a href="www.ietf.org/rfc/rfc3986.txt">RFC 3986</a>および<a href="www.ietf.org/rfc/rfc3987.txt">RFC 3987</a>、または、RFC 3986やRFC 3987に取って代わった最新のRFCを参照）。IRIはクエリの基底IRIに対して解決され、絶対IRIにならなければなりません。</p>

<p><code>URI</code> 関数は<a href="#func-iri"><code>IRI</code></a>の同意語です。</p>

<p>関数がIRIを渡せば、IRIがそのまま返されます。</p>

<p>シンプルなリテラル以外のいかなるRDF用語を渡しても、xsd:stringまたはIRIはエラーです。</p>

<p>実装はIRIを正規化できます（<em class="rfc2119" title="RFC 2119のコンテキストにおけるキーワード">MAY</em>）。</p>

<p>例:</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>IRI("http://example/")</code></td>
    <td>&lt;http://example/&gt;</td>
  </tr>
  <tr>
    <td><code>IRI(&lt;http://example/&gt;)</code></td>
    <td>&lt;http://example/&gt;</td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-bnode" id="func-bnode"></a>17.4.2.9 BNODE</h5>

<pre class="prototype"><span class="return">blank node</span>  <span class="operator">BNODE</span>()</pre>

<pre class="prototype"><span class="return">blank node</span>  <span class="operator">BNODE</span>(<span class="type">simple literal</span>)</pre>

<pre class="prototype"><span class="return">blank node</span>  <span class="operator">BNODE</span>(<span class="type">xsd:string</span>)</pre>

<p><code>BNODE</code>関数は、クエリが行われているデータセット内のあらゆる空白ノードとも、このコンストラクタの呼び出しによって他のクエリ・ソリューションのために作成されるあらゆる空白ノードとも異なる空白ノードを生成します。引数形式が用いられていない場合は、呼び出しごとに、別々の空白ノードが作成されます。シンプルなリテラルの形式を用いた場合は、異なるシンプルなリテラルに対しては、呼び出しごとに別々の空白ノードが生成され、1つの<a href="#defn_sparqlSolutionMapping">ソリューション・マッピング</a>の式の中で同じシンプルなリテラルを持つ呼び出しに対しては範囲内の同じ空白ノードが生成されます。</p>

<p>この機能は、<a href="#tempatesWithBNodes">SPARQL CONSTRUCTテンプレートの空白ノードの処理</a>と互換性があります。</p>

</div>
<div class="div4">

<h5>
<a name="func-strdt" id="func-strdt"></a>17.4.2.10 STRDT</h5>

<pre class="prototype"><span class="return">literal</span>  <span class="operator">STRDT</span>(<span class="type">simple literal</span> lexicalForm, <span class="type">IRI</span> datatypeIRI)</pre>

<p><code>STRDT</code>関数は、字句形式および引数で指定された型を持つリテラルを生成します。</p>

<div class="result">
<table>
<tbody>
  <tr>
    <td><code>STRDT("123", xsd:integer)</code></td>
    <td>"123"^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt;</td>
  </tr>
  <tr>
    <td><code>STRDT("iiii", &lt;http://example/romanNumeral&gt;)</code></td>
    <td>"iiii"^^&lt;http://example/romanNumeral&gt;</td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-strlang" id="func-strlang"></a>17.4.2.11 STRLANG</h5>

<pre class="prototype"><span class="return">literal</span>  <span class="operator">STRLANG</span>(<span class="type">simple literal</span> lexicalForm, <span class="type">simple literal</span> langTag)</pre>

<p><code>STRLANG</code>関数は、字句形式および引数で指定された言語タグを持つリテラルを生成します。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>STRLANG("chat", "en")</code></td>
    <td>"chat"@en</td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-uuid" id="func-uuid"></a>17.4.2.12 UUID</h5>

<pre class="prototype"><span class="return">iri</span>  <span class="operator">UUID</span>()</pre>

<p><a href="www.ietf.org/rfc/rfc4122.txt">UUID URNUUID URNスキーム</a>から新たなIRIを返します。<code>UUID()</code>の呼び出しごとに異なるUUIDを返します。「nil」UUID（すべて0）ではあってはなりません。UUIDの変数とバージョンは、実装に依存します。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>UUID()</code></td>
    <td><code>&lt;urn:uuid:b9302fb5-642e-4d3b-af19-29a8f6d894c9&gt;</code></td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-struuid" id="func-struuid"></a>17.4.2.13 STRUUID</h5>

<pre class="prototype"><span class="return">simple literal</span>  <span class="operator">STRUUID</span>()</pre>

<p>UUIDのスキームに特化した部分の文字列を返します。それは、シンプルなリテラルとして、UUIDを生成し、シンプルなリテラルに変換し、元の<code>urn:uuid:</code>を削除した結果です。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>STRUUID()</code></td>
    <td><code>"73cd4307-8a99-4691-a608-b5bda64fb6c1"</code></td>
  </tr>
</tbody>
</table>

</div>
</div>
</div>
<div class="div3">

<h4>
<a name="func-strings" id="func-strings"></a>17.4.3 文字列に関する関数</h4>

<div class="div4">

<h5>
<a name="idp1887976" id="idp1887976"></a>17.4.3.1 SPARQL関数の文字列</h5>

<div class="div5">

<h6>
<a name="func-string" id="func-string"></a>17.4.3.1.1 文字列の引数</h6>

<p>関数（例えば、<a href="#func-regex">REGEX</a>、<a href="#func-strlen">STRLEN</a>、<a href="#func-contains">CONTAINS</a>）には、文字列リテラルを引数として取り、シンプルなリテラル、言語タグ付きプレーン・リテラル、または、データ型xsd:stringを持つリテラルを受け入れるものがあります。それは、後でリテラルの字句形式に影響を与えます。</p>

<p>このために、関数の記述で<code>string literal</code>（文字列リテラル）という用語を用います。他のRDF用語を用いると、エラーが生じる関数が呼び出されるでしょう。</p>

</div>
<div class="div5">

<h6>
<a name="func-arg-compatibility" id="func-arg-compatibility"></a>17.4.3.1.2 引数の互換性の規則</h6>

<p><a href="#func-strstarts">STRSTARTS</a>、<a href="#func-strends">STRENDS</a>、<a href="#func-contains">CONTAINS</a>、<a href="#func-strbefore">STRBEFORE</a>と<a href="#func-strafter">STRAFTER</a>の関数は、2つの引数を取ります。これらの引数には互換性がなくてはならず、そうでない場合には、これらの関数の1つを呼び出すとエラーが生じます。</p>

<p>2つの引数の互換性は、次のとおりに定義されています。</p>

<ul>
  <li>引数は、シンプルなリテラルまたはxsd:stringという型を持つリテラルである。</li>
  <li>引数は、同一の言語タグを持つプレーン・リテラルである。</li>
  <li>最初の引数は、言語タグを持つプレーン・リテラルで、2番目の引数は、シンプルなリテラルまたはxsd:stringという型を持つリテラルである。</li>
</ul>

<div class="result">

<table>
<tbody>
  <tr>
    <th>引数1</th>
    <th>引数2</th>
    <th>互換?</th>
  </tr>
  <tr>
    <td>"abc"</td>
    <td>"b"</td>
    <td>はい</td>
  </tr>
  <tr>
    <td>"abc"</td>
    <td>"b"^^xsd:string</td>
    <td>はい</td>
  </tr>
  <tr>
    <td>"abc"^^xsd:string</td>
    <td>"b"</td>
    <td>はい</td>
  </tr>
  <tr>
    <td>"abc"^^xsd:string</td>
    <td>"b"^^xsd:string</td>
    <td>はい</td>
  </tr>
  <tr>
    <td>"abc"@en</td>
    <td>"b"</td>
    <td>はい</td>
  </tr>
  <tr>
    <td>"abc"@en</td>
    <td>"b"^^xsd:string</td>
    <td>はい</td>
  </tr>
  <tr>
    <td>"abc"@en</td>
    <td>"b"@en</td>
    <td>はい</td>
  </tr>
  <tr>
    <td>"abc"@fr</td>
    <td>"b"@ja</td>
    <td>いいえ</td>
  </tr>
  <tr>
    <td>"abc"</td>
    <td>"b"@ja</td>
    <td>いいえ</td>
  </tr>
  <tr>
    <td>"abc"</td>
    <td>"b"@en</td>
    <td>いいえ</td>
  </tr>
  <tr>
    <td>"abc"^^xsd:string</td>
    <td>"b"@en</td>
    <td>いいえ</td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div5">

<h6>
<a name="idp1915512" id="idp1915512"></a>17.4.3.1.3 文字列リテラルの返答の型</h6>

<p>文字列リテラルを返す関数は、最初の引数（シンプルなリテラル、同じ言語タグを持つプレーン・リテラル、xsd:string）と同じ種類の文字列リテラルで返答を行います。これには、<a href="#func-substr">SUBSTR</a>、<a href="#func-strbefore">STRBEFORE</a>と<a href="#func-strafter">STRAFTER</a>が含まれます。</p>

<p>関数<a href="#func-concat">CONCAT</a>は、そのすべての引数の詳細に基づいて文字列リテラルを返します。</p>

</div>
</div>
<div class="div4">

<h5>
<a name="func-strlen" id="func-strlen"></a>17.4.3.2 STRLEN</h5>

<pre class="prototype"><span class="return">xsd:integer</span>  <span class="operator">STRLEN</span>(<span class="type">string literal</span> str)</pre>

<p><code>strlen</code>関数は、XPathの<a href="www.w3.org/TR/xpath-functions/#func-string-length">fn:string-length</a>関数に相当し、リテラルの字句形式の文字の長さと等しい<code>xsd:integer</code>を返します。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>strlen("chat")</code></td>
    <td>4</td>
  </tr>
  <tr>
    <td><code>strlen("chat"@en)</code></td>
    <td>4</td>
  </tr>
  <tr>
    <td><code>strlen("chat"^^xsd:string)</code></td>
    <td>4</td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-substr" id="func-substr"></a>17.4.3.3 SUBSTR</h5>

<pre class="prototype"><span class="return">string literal</span>  <span class="operator">SUBSTR</span>(<span class="type">string literal</span> source, <span class="type">xsd:integer</span> startingLoc)</pre>

<pre class="prototype"><span class="return">string literal</span>  <span class="operator">SUBSTR</span>(<span class="type">string literal</span> source, <span class="type">xsd:integer</span> startingLoc, <span class="type">xsd:integer</span> length)</pre>

<p><code>substr</code>関数は、XPathの<a href="www.w3.org/TR/xpath-functions/#func-substring">fn:substring</a>関数に相当し、<code>source</code>（情報源）の入力パラメータとして、同じ種類のリテラル（シンプルなリテラル、言語タグを持つリテラル、<code>xsd:string</code>という型を持つリテラル）を返しますが、それは、情報源の字句形式の部分文字列（substring）から生成された字句形式を持っています。</p>

<p>引数<code>startingLoc</code>と<code>length</code>は、xsd:integerの派生型でありえます。</p>

<p>文字列の最初の文字の指数は1です。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>substr("foobar", 4)</code></td>
    <td>"bar"</td>
  </tr>
  <tr>
    <td><code>substr("foobar"@en, 4)</code></td>
    <td>"bar"@en</td>
  </tr>
  <tr>
    <td><code>substr("foobar"^^xsd:string, 4)</code></td>
    <td>"bar"^^xsd:string</td>
  </tr>
  <tr>
    <td><code>substr("foobar", 4, 1)</code></td>
    <td>"b"</td>
  </tr>
  <tr>
    <td><code>substr("foobar"@en, 4, 1)</code></td>
    <td>"b"@en</td>
  </tr>
  <tr>
    <td><code>substr("foobar"^^xsd:string, 4, 1)</code></td>
    <td>"b"^^xsd:string</td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-ucase" id="func-ucase"></a>17.4.3.4 UCASE</h5>

<pre class="prototype"><span class="return">string literal</span>  <span class="operator">UCASE</span>(<span class="type">string literal</span> str)</pre>

<p><code>UCASE</code>関数は、XPathの<a href="www.w3.org/TR/xpath-functions/#func-upper-case">fn:upper-case</a>関数に相当します。これは、字句形式が、大文字の引数の字句形式である文字列リテラルを返します。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>ucase("foo")</code></td>
    <td>"FOO"</td>
  </tr>
  <tr>
    <td><code>ucase("foo"@en)</code></td>
    <td>"FOO"@en</td>
  </tr>
  <tr>
    <td><code>ucase("foo"^^xsd:string)</code></td>
    <td>"FOO"^^xsd:string</td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-lcase" id="func-lcase"></a>17.4.3.5 LCASE</h5>

<pre class="prototype"><span class="return">string literal</span>  <span class="operator">LCASE</span>(<span class="type">string literal</span> str)</pre>

<p><code>LCASE</code>関数は、XPathの<a href="www.w3.org/TR/xpath-functions/#func-lower-case">fn:lower-case</a>関数に相当します。これは、字句形式が、小文字の引数の字句形式である文字列リテラルを返します。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>lcase("BAR")</code></td>
    <td>"bar"</td>
  </tr>
  <tr>
    <td><code>lcase("BAR"@en)</code></td>
    <td>"bar"@en</td>
  </tr>
  <tr>
    <td><code>lcase("BAR"^^xsd:string)</code></td>
    <td>"bar"^^xsd:string</td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-strstarts" id="func-strstarts"></a>17.4.3.6 STRSTARTS</h5>

<pre class="prototype"><span class="return">xsd:boolean</span>  <span class="operator">STRSTARTS</span>(<span class="type">string literal</span> arg1, <span class="type">string literal</span> arg2)</pre>

<p><code>STRSTARTS</code>関数は、XPathの<a href="www.w3.org/TR/xpath-functions/#func-starts-with">fn:starts-with</a>関数に相当します。引数は、<a href="#func-arg-compatibility">互換性のある引数</a>でなければならず、そうでない場合には、エラーが生じます。</p>

<p>このような対が入力されると、関数は、<code>arg1</code> の字句形式が<code>arg2</code>の字句形式で始まる場合に真（true）を返し、そうでない場合に偽（false）を返します。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>strStarts("foobar", "foo")</code></td>
    <td>true</td>
  </tr>
  <tr>
    <td><code>strStarts("foobar"@en, "foo"@en)</code></td>
    <td>true</td>
  </tr>
  <tr>
    <td><code>strStarts("foobar"^^xsd:string, "foo"^^xsd:string)</code></td>
    <td>true</td>
  </tr>
  <tr>
    <td><code>strStarts("foobar"^^xsd:string, "foo")</code></td>
    <td>true</td>
  </tr>
  <tr>
    <td><code>strStarts("foobar", "foo"^^xsd:string)</code></td>
    <td>true</td>
  </tr>
  <tr>
    <td><code>strStarts("foobar"@en, "foo")</code></td>
    <td>true</td>
  </tr>
  <tr>
    <td><code>strStarts("foobar"@en, "foo"^^xsd:string)</code></td>
    <td>true</td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-strends" id="func-strends"></a>17.4.3.7 STRENDS</h5>

<pre class="prototype"><span class="return">xsd:boolean</span>  <span class="operator">STRENDS</span>(<span class="type">string literal</span> arg1, <span class="type">string literal</span> arg2)</pre>

<p><code>STRENDS</code>関数は、XPathの<a href="www.w3.org/TR/xpath-functions/#func-ends-with">fn:ends-with</a>関数に相当します。引数は、<a href="#func-arg-compatibility">互換性のある引数</a>でなければならず、そうでない場合には、エラーが生じます。</p>

<p>このような対が入力されると、関数は、<code>arg1</code>の字句形式が<code>arg2</code>の字句形式で終了する場合に真（true）を返し、そうでない場合に偽（false）を返します。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>strEnds("foobar", "bar")</code></td>
    <td>true</td>
  </tr>
  <tr>
    <td><code>strEnds("foobar"@en, "bar"@en)</code></td>
    <td>true</td>
  </tr>
  <tr>
    <td><code>strEnds("foobar"^^xsd:string, "bar"^^xsd:string)</code></td>
    <td>true</td>
  </tr>
  <tr>
    <td><code>strEnds("foobar"^^xsd:string, "bar")</code></td>
    <td>true</td>
  </tr>
  <tr>
    <td><code>strEnds("foobar", "bar"^^xsd:string)</code></td>
    <td>true</td>  </tr>
  <tr>
    <td><code>strEnds("foobar"@en, "bar")</code></td>
    <td>true</td>
  </tr>
  <tr>
    <td><code>strEnds("foobar"@en, "bar"^^xsd:string)</code></td>
    <td>true</td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-contains" id="func-contains"></a>17.4.3.8 CONTAINS</h5>

<pre class="prototype"><span class="return">xsd:boolean</span>  <span class="operator">CONTAINS</span>(<span class="type">string literal</span> arg1, <span class="type">string literal</span> arg2)</pre>

<p><code>CONTAINS</code>関数は、XPathの<a href="www.w3.org/TR/xpath-functions/#func-contains">fn:contains</a>に相当します。引数は、<a href="#func-arg-compatibility">互換性のある引数</a>でなければならず、そうでない場合には、エラーが生じます。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>contains("foobar", "bar")</code></td>
    <td>true</td>
  </tr>
  <tr>
    <td><code>contains("foobar"@en, "foo"@en)</code></td>
    <td>true</td>
  </tr>
  <tr>
    <td><code>contains("foobar"^^xsd:string, "bar"^^xsd:string)</code></td>
    <td>true</td>
  </tr>
  <tr>
    <td><code>contains("foobar"^^xsd:string, "foo")</code></td>
    <td>true</td>
  </tr>
  <tr>
    <td><code>contains("foobar", "bar"^^xsd:string)</code></td>
    <td>true</td>
  </tr>
  <tr>
    <td><code>contains("foobar"@en, "foo")</code></td>
    <td>true</td>
  </tr>
  <tr>
    <td><code>contains("foobar"@en, "bar"^^xsd:string)</code></td>
    <td>true</td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-strbefore" id="func-strbefore"></a>17.4.3.9 STRBEFORE</h5>

<pre class="prototype"><span class="return">literal</span>  <span class="operator">STRBEFORE</span>(<span class="type">string literal</span> arg1, <span class="type">string literal</span> arg2)</pre>

<p><code>STRBEFORE</code>関数は、XPathの<a href="www.w3.org/TR/xpath-functions/#func-substring-before">fn:substring-before</a>関数に相当します。引数は、<a href="#func-arg-compatibility">互換性のある引数</a>でなければならず、そうでない場合には、エラーが生じます。</p>

<p>互換性を持つ引数では、2番目の引数の字句部分が最初の引数の字句部分の部分文字列（substring）として存在する場合、関数は最初の引数<code>arg1</code>と同じ種類のリテラル（シンプルなリテラル、同じ言語タグを持つプレーン・リテラル、xsd:string）を返します。結果の字句形式は、最初の<code>arg2</code>の字句形式の前に<code>arg1</code>の字句形式の部分文字列（substring）が置かれたものとなります。<code>arg2</code>の字句形式が空の文字列であれば、マッチしたとみなされ、結果の字句形式は空の文字列です。</p>

<p>そのような文字列の発生がなければ、空のシンプルなリテラルが返されます。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td>strbefore("abc","b")</td>
    <td>"a"</td>
  </tr>
  <tr>
    <td>strbefore("abc"@en,"bc")</td>
    <td>"a"@en</td>
  </tr>
  <tr>
    <td>strbefore("abc"@en,"b"@cy)</td>
    <td>error</td>
  </tr>
  <tr>
    <td>strbefore("abc"^^xsd:string,"")</td>
    <td>""^^xsd:string</td>
  </tr>
  <tr>
    <td>strbefore("abc","xyz")</td>
    <td>""</td>
  </tr>
  <tr>
    <td>strbefore("abc"@en, "z"@en)</td>
    <td>""</td>
  </tr>
  <tr>
    <td>strbefore("abc"@en, "z")</td>
    <td>""</td>
  </tr>
  <tr>
    <td>strbefore("abc"@en, ""@en)</td>
    <td>""@en</td>
  </tr>
  <tr>
    <td>strbefore("abc"@en, "")</td>
    <td>""@en</td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-strafter" id="func-strafter"></a>17.4.3.10 STRAFTER</h5>

<pre class="prototype"><span class="return">literal</span>  <span class="operator">STRAFTER</span>(<span class="type">string literal</span> arg1, <span class="type">string literal</span> arg2)</pre>

<p><code>STRAFTER</code>機能は、XPathの<a href="www.w3.org/TR/xpath-functions/#func-substring-after">fn:substring-after</a>関数に相当します。引数は、<a href="#func-arg-compatibility">互換性のある引数</a>でなければならず、そうでない場合には、エラーが生じます。</p>

<p>互換性を持つ引数では、2番目の引数の字句部分が最初の引数の字句部分の部分文字列（substring）として存在した場合、関数は最初の引数arg1と同じ種類のリテラル（シンプルなリテラル、同じ言語タグを持つプレーン・リテラル、xsd:string）を返します。結果の字句形式は、最初に発生した<code>arg2</code>の字句形式の後にarg1の字句形式の部分文字列（substring）が置かれたものとなります。<code>arg2</code>の字句形式が空の文字列であれば、マッチしたとみなされ、結果の字句形式は<code>arg1</code>の字句形式です。</p>

<p>そのような文字列の発生がなければ、空のシンプルなリテラルが返されます。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td>strafter("abc","b")</td>
    <td>"c"</td>
  </tr>
  <tr>
    <td>strafter("abc"@en,"ab")</td>
    <td>"c"@en</td>
  </tr>
  <tr>
    <td>strafter("abc"@en,"b"@cy)</td>
    <td>error</td>
  </tr>
  <tr>
    <td>strafter("abc"^^xsd:string,"")</td>
    <td>"abc"^^xsd:string</td>
  </tr>
  <tr>
    <td>strafter("abc","xyz")</td>
    <td>""</td>
  </tr>
  <tr>
    <td>strafter("abc"@en, "z"@en)</td>
    <td>""</td>
  </tr>
  <tr>
    <td>strafter("abc"@en, "z")</td>
    <td>""</td>
  </tr>
  <tr>
    <td>strafter("abc"@en, ""@en)</td>
    <td>"abc"@en</td>
  </tr>
  <tr>
    <td>strafter("abc"@en, "")</td>
    <td>"abc"@en </td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-encode" id="func-encode"></a>17.4.3.11 ENCODE_FOR_URI</h5>

<pre class="prototype"><span class="return">simple literal</span>  <span class="operator">ENCODE_FOR_URI</span>(<span class="type">string literal</span> ltrl)</pre>

<p><code>ENCODE_FOR_URI</code>関数は、XPathの<a href="www.w3.org/TR/xpath-functions/#func-encode-for-uri">fn:encode-for-uri</a>関数に相当します。これは、<a href="www.w3.org/TR/xpath-functions/#func-encode-for-uri">fn:encode-for-uri</a>関数で予約文字を置換した後に、その入力の字句形式から得られた字句形式を持つシンプルなリテラルを返します。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>encode_for_uri("Los Angeles")</code></td>
    <td><code>"Los%20Angeles"</code></td>
  </tr>
  <tr>
    <td><code>encode_for_uri("Los Angeles"@en)</code></td>
    <td><code>"Los%20Angeles"</code></td>
  </tr>
  <tr>
    <td><code>encode_for_uri("Los Angeles"^^xsd:string)</code></td>
    <td><code>"Los%20Angeles"</code></td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-concat" id="func-concat"></a>17.4.3.12 CONCAT</h5>

<pre class="prototype"><span class="return">string literal</span>  <span class="operator">CONCAT</span>(<span class="type">string literal</span> <span>ltrl<sub>1</sub></span> ... <span class="type">string literal</span> <span>ltrl<sub>n</sub></span>)</pre>

<p><code>CONCAT</code>関数は、XPathの <a href="www.w3.org/TR/xpath-functions/#func-concat">fn:concat</a>関数に相当します。この関数では、引数として文字列リテラルが認められています。</p>

<p>返されたリテラルの字句形式は、その入力の字句形式を連結することで得られます。入力されたリテラルがすべて<code>xsd:string</code>という型の型付きリテラルであれば、返されたリテラルも<code>xsd:string</code>という型で、入力されたリテラルがすべて同一の言語タグを持つプレーン・リテラルであれば、返されたリテラルは、同じ言語タグを持つプレーン・リテラルで、その他の場合はすべて、返されたリテラルはシンプルなリテラルです。</p>

<div class="result">
<table>
<tbody>
  <tr>
    <td><code>concat("foo", "bar")</code></td>
    <td>"foobar"</td>
  </tr>
  <tr>
    <td><code>concat("foo"@en, "bar"@en)</code></td>
    <td>"foobar"@en</td>
  </tr>
  <tr>
    <td><code>concat("foo"^^xsd:string, "bar"^^xsd:string)</code></td>
    <td>"foobar"^^xsd:string</td>
  </tr>
  <tr>
    <td><code>concat("foo", "bar"^^xsd:string)</code></td>
    <td>"foobar"</td>
  </tr>
  <tr>
    <td><code>concat("foo"@en, "bar")</code></td>
    <td>"foobar"</td>
  </tr>
  <tr>
    <td><code>concat("foo"@en, "bar"^^xsd:string)</code></td>
    <td>"foobar"</td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-langMatches" id="func-langMatches"></a>17.4.3.13 langMatches</h5>

<pre class="prototype"> <span class="return">xsd:boolean</span>  <span class="operator">langMatches</span> (<span class="type"><span class="type">simple literal</span></span> <span class="name">language-tag</span>, <span class="type"><span class="type">simple literal</span></span> <span class="name">language-range</span>)</pre>

<p><code>language-tag</code>（最初の引数）が、[<a href="#rfc4647">RFC4647</a>]の3.3.1項で定義されている基本的なフィルタリング・スキームで<code>language-range</code>（2番目の引数）にマッチする場合は、真（<code>true</code>）を返します。<code>language-range</code>は、[<a href="#rfc4647">RFC4647</a>]の2.1.項の<a class="norm" href="www.ietf.org/rfc/rfc4647.txt">言語タグのマッチング</a>にあるとおりの基本言語の範囲です。「*」の<code>language-range</code>は、任意の空でない<code>language-tag</code>文字列にマッチします。</p>

<div class="exampleGroup">

<pre class="data">@prefix dc:       &lt;http://purl.org/dc/elements/1.1/&gt; .

_:a  dc:title         "That Seventies Show"@en .
_:a  dc:title         "Cette Serie des Annees Soixante-dix"@fr .
_:a  dc:title         "Cette Serie des Annees Septante"@fr-BE .
_:b  dc:title         "Il Buono, il Bruto, il Cattivo" .</pre>
<div class="queryGroup">

<p>このクエリでは、英語で「That Seventies Show」として知られているショーに対するフランス語のタイトルを発見するために、<a href="#func-langMatches"><code>langMatches</code></a>と<a href="#func-lang"><code>lang</code></a>を使用しています。</p>

<pre class="query">PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT ?title
 WHERE { ?x dc:title  "That Seventies Show"@en ;
            dc:title  ?title .
         FILTER langMatches( lang(?title), "FR" ) }</pre>

<p>クエリ結果:</p>

<div class="result">

<table class="resultTable">
<tbody>
  <tr>
    <th>title</th>
  </tr>
  <tr>
    <td>"Cette Serie des Annees Soixante-dix"@fr</td>
  </tr>
  <tr>
    <td>"Cette Serie des Annees Septante"@fr-BE</td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="queryGroup">

<p>成句的表現<code>langMatches( lang( ?v ), "*" )</code>は、<code>lang( ?v )</code>が空の文字列を返すため、言語タグなしではリテラルにマッチしないでしょう。そのため、</p>

<pre class="query add">PREFIX dc: &lt;http://purl.org/dc/elements/1.1/&gt;
SELECT ?title
 WHERE { ?x dc:title  ?title .
         FILTER langMatches( lang(?title), "*" ) }</pre>

<p>は、言語タグを持つタイトルのすべてを報告するでしょう。</p>

<div class="result add">

<table class="resultTable">
<tbody>
  <tr>
    <th>title</th>
  </tr>
  <tr>
    <td>"That Seventies Show"@en</td>
  </tr>
  <tr>
    <td>"Cette Serie des Annees Soixante-dix"@fr</td>
  </tr>
  <tr>
    <td>"Cette Serie des Annees Septante"@fr-BE</td>
  </tr>
</tbody>
</table>

</div>
</div>
</div>
</div>
<div class="div4">

<h5>
<a name="func-regex" id="func-regex"></a>17.4.3.14 REGEX</h5>

<pre class="prototype"> <span class="return">xsd:boolean</span>  <span class="operator">REGEX</span> (<span class="type"><span class="type">string literal</span></span> <span class="name">text</span>, <span class="type"><span class="type">simple literal</span></span> <span class="name">pattern</span>)
 <span class="return">xsd:boolean</span>  <span class="operator">REGEX</span> (<span class="type"><span class="type">string literal</span></span> <span class="name">text</span>, <span class="type"><span class="type">simple literal</span></span> <span class="name">pattern</span>, <span class="type"><span class="type">simple literal</span></span> <span class="name">flags</span>)</pre>

<p>正規表現パターン（<code>pattern</code>）に対してテキスト（<code>text</code>）をマッチさせるために<a class="norm" href="www.w3.org/TR/xpath-functions/#func-matches">fn:matches</a>関数を呼び出します。正規表現言語は、XQuery 1.0とXPath 2.0関数および演算子の<a class="norm" href="www.w3.org/TR/xpath-functions/#regex-syntax">7.6.1 正規表現構文</a>[<a href="#FUNCOP">FUNCOP</a>]の項で定義されています。</p>

<div class="exampleGroup">

<pre class="data">@prefix foaf:       &lt;http://xmlns.com/foaf/0.1/&gt; .

_:a  foaf:name       "Alice".
_:b  foaf:name       "Bob" .</pre>
<div class="queryGroup">

<pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
SELECT ?name
 WHERE { ?x foaf:name  ?name
         FILTER regex(?name, "^ali", "i") }</pre>

<p>クエリ結果:</p>

<div class="result">

<table class="resultTable">
<tbody>
  <tr>
    <th>name</th>
  </tr>
  <tr>
    <td>"Alice"</td>
  </tr>
</tbody>
</table>

</div>
</div>
</div>
</div>
<div class="div4">

<h5>
<a name="func-replace" id="func-replace"></a>17.4.3.15 REPLACE</h5>

<pre class="prototype"> <span class="return"><span class="type">string literal</span></span>  <span class="operator">REPLACE</span> (<span class="type"><span class="type">string literal</span></span> arg, <span class="type"><span class="type">simple literal</span></span> pattern, <span class="type"><span class="type">simple literal</span></span> replacement )
 <span class="return"><span class="type">string literal</span></span>  <span class="operator">REPLACE</span> (<span class="type"><span class="type">string literal</span></span> arg, <span class="type"><span class="type">simple literal</span></span> pattern, <span class="type"><span class="type">simple literal</span></span> replacement,  <span class="type"><span class="type">simple literal</span></span> flags)</pre>

<p><code>REPLACE</code>関数は、XPathの<a href="www.w3.org/TR/xpath-functions/#func-replace">fn:replace</a>関数に相当します。これは、個々の重複のない正規表現<tt>pattern</tt>を、置換文字列に置き換えます。正規表現マッチングには、修飾語フラグが含まれているかもしれません。<a href="#func-regex">REGEX</a>を参照してください。</p>

<div class="result">

<table class="resultTable">
<tbody>
  <tr>
    <td>replace("abcd", "b", "Z")</td>
    <td>"aZcd"</td>
  </tr>
  <tr>
    <td>replace("abab", "B", "Z","i")</td>
    <td>"aZaZ"</td>
  </tr>
  <tr>
    <td>replace("abab", "B.", "Z","i")</td>
    <td>"aZb"</td>
  </tr>
</tbody>
</table>

</div>
</div>
</div>
<div class="div3">

<h4>
<a name="func-numerics" id="func-numerics"></a>17.4.4 数値の関数</h4>

<div class="div4">

<h5>
<a name="func-abs" id="func-abs"></a>17.4.4.1 abs</h5>

<pre class="prototype"> <span class="return">numeric</span>  <span class="operator">ABS</span> (<span class="type"><span class="type numeric">numeric</span></span> <span class="name">term</span>)</pre>

<p><code>arg</code>の絶対値を返します。<code>arg</code>が数値でなければ、エラーが生じます。</p>

<p>この関数は、<a href="www.w3.org/TR/xpath-datamodel/">XDM</a>のデータ型を持つ用語の<a href="www.w3.org/TR/xpath-functions/#func-abs">fn:numeric-abs</a>と同じです。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>abs(1)</code></td>
    <td><code>1</code></td>
  </tr>
  <tr>
    <td><code>abs(-1.5)</code></td>
    <td><code>1.5</code></td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-round" id="func-round"></a>17.4.4.2 round</h5>

<pre class="prototype"> <span class="return">numeric</span>  <span class="operator">ROUND</span> (<span class="type"><span class="type numeric">numeric</span></span> <span class="name">term</span>)</pre>

<p>引数に最も近い端数のない数を返します。そのような数が2つある場合には、正の無限大に最も近い数が返されます。<code>arg</code>が数値でなければ、エラーが生じます。</p>

<p>この関数は、<a href="www.w3.org/TR/xpath-datamodel/">XDM</a>のデータ型を持つ用語の<a href="www.w3.org/TR/xpath-functions/#func-round">fn:numeric-round</a>と同じです。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>round(2.4999)</code></td>
    <td><code>2.0</code></td>
  </tr>
  <tr>
    <td><code>round(2.5)</code></td>
    <td><code>3.0</code></td>
  </tr>
  <tr>
    <td><code>round(-2.5)</code></td>
    <td><code>-2.0</code></td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">
<h5>
<a name="func-ceil" id="func-ceil"></a>17.4.4.3 ceil</h5>

<pre class="prototype"> <span class="return">numeric</span>  <span class="operator">CEIL</span> (<span class="type"><span class="type numeric">numeric</span></span> <span class="name">term</span>)</pre>

<p><code>arg</code>の値以上の端数のない最小の（負の無限大に最も近い）数を返します。<code>arg</code>が数値でなければ、エラーが生じます。</p>

<p>この関数は、<a href="www.w3.org/TR/xpath-datamodel/">XDM</a>のデータ型を持つ用語の<a href="www.w3.org/TR/xpath-functions/#func-ceiling">fn:numeric-ceil</a>と同じです。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>ceil(10.5)</code></td>
    <td><code>11.0</code></td>
  </tr>
  <tr>
    <td><code>ceil(-10.5)</code></td>
    <td><code>-10.0</code></td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-floor" id="func-floor"></a>17.4.4.4 floor</h5>

<pre class="prototype"> <span class="return">numeric</span>  <span class="operator">FLOOR</span> (<span class="type"><span class="type numeric">numeric</span></span> <span class="name">term</span>)</pre>

<p><code>arg</code>の値以下の端数のない最大の（正の無限大に最も近い）数を返します。<code>arg</code>が数値でない場合、エラーが生じます。</p>

<p>この関数は、<a href="www.w3.org/TR/xpath-datamodel/">XDM</a>のデータ型を持つ用語の<a href="www.w3.org/TR/xpath-functions/#func-floor">fn:numeric-floor</a>と同じです。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>floor(10.5)</code></td>
    <td><code>10.0</code></td>
  </tr>
  <tr>
    <td><code>floor(-10.5)</code></td>
    <td><code>-11.0</code></td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="idp2130040" id="idp2130040"></a>17.4.4.5 RAND</h5>

<pre class="prototype"> <span class="return">xsd:double</span>  <span class="operator">RAND</span> ( )</pre>

<p>0（両立的）と1.0e0（排他的）の間の疑似乱数を返します。この関数が呼び出されるたびに、異なる数が生成される可能性があります。ほぼ等しい確率を持つ数が生成されるはずです。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>rand()</code></td>
    <td><code>"0.31221030831984886"^^xsd:double</code></td>
  </tr>
</tbody>
</table>

</div>
</div>
</div>
<div class="div3">

<h4>
<a name="func-date-time" id="func-date-time"></a>17.4.5 日時の関数</h4>

<div class="div4">

<h5>
<a name="func-now" id="func-now"></a>17.4.5.1 now</h5>

<pre class="prototype"> <span class="return">xsd:dateTime</span>  <span class="operator">NOW</span> ()</pre>

<p>現在実行しているクエリに対するXSD dateTimeの値を返します。1つのクエリの実行の中では、この関数の呼び出しで返される値はすべて同じでなければなりません。返された正確な瞬間の日時は明示されません。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>now()</code></td>
    <td><code>"2011-01-10T14:45:13.815-05:00"^^xsd:dateTime</code></td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-year" id="func-year"></a>17.4.5.2 year</h5>

<pre class="prototype"> <span class="return">xsd:integer</span>  <span class="operator">YEAR</span> (<span class="type"><span class="type">xsd:dateTime</span></span> <span class="parm">arg</span>)</pre>

<p><code>arg</code>の年の部分を整数で返します。</p>

<p>この関数は、<a href="www.w3.org/TR/xpath-functions/#func-year-from-dateTime">fn:year-from-dateTime</a>に相当します。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>year("2011-01-10T14:45:13.815-05:00"^^xsd:dateTime)</code></td>
    <td><code>2011</code></td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-month" id="func-month"></a>17.4.5.3 month</h5>

<pre class="prototype"> <span class="return">xsd:integer</span>  <span class="operator">MONTH</span> (<span class="type"><span class="type">xsd:dateTime</span></span> <span class="parm">arg</span>)</pre>

<p><code>arg</code>の月の部分を整数で返します。</p>

<p>この関数は、<a href="www.w3.org/TR/xpath-functions/#func-month-from-dateTime">fn:month-from-dateTime</a>に相当します。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>month("2011-01-10T14:45:13.815-05:00"^^xsd:dateTime)</code></td>
    <td><code>1</code></td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-day" id="func-day"></a>17.4.5.4 day</h5>

<pre class="prototype"> <span class="return">xsd:integer</span>  <span class="operator">DAY</span> (<span class="type"><span class="type">xsd:dateTime</span></span> <span class="parm">arg</span>)</pre>

<p><code>arg</code>の日の部分を整数で返します。</p>

<p>この関数は、<a href="www.w3.org/TR/xpath-functions/#func-day-from-dateTime">fn:day-from-dateTime</a>に相当します。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>day("2011-01-10T14:45:13.815-05:00"^^xsd:dateTime)</code></td>
    <td><code>10</code></td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-hours" id="func-hours"></a>17.4.5.5 hours</h5>

<pre class="prototype"> <span class="return">xsd:integer</span>  <span class="operator">HOURS</span> (<span class="type"><span class="type">xsd:dateTime</span></span> <span class="parm">arg</span>)</pre>

<p><code>arg</code>の時間の部分を整数で返します。値は、XSD dateTimeの字句形式で示されている通りです。</p>

<p>この関数は、<a href="www.w3.org/TR/xpath-functions/#func-hours-from-dateTime">fn:hours-from-dateTime</a>に相当します。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>hours("2011-01-10T14:45:13.815-05:00"^^xsd:dateTime)</code></td>
    <td><code>14</code></td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-minutes" id="func-minutes"></a>17.4.5.6 minutes</h5>

<pre class="prototype"> <span class="return">xsd:integer</span>  <span class="operator">MINUTES</span> (<span class="type"><span class="type">xsd:dateTime</span></span> <span class="parm">arg</span>)</pre>

<p><code>arg</code>の字句形式の分の部分を返します。値は、XSD dateTimeの字句形式で示されている通りです。</p>

<p>この関数は、<a href="www.w3.org/TR/xpath-functions/#func-minutes-from-dateTime">fn:minutes-from-dateTime</a>に相当します。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>minutes("2011-01-10T14:45:13.815-05:00"^^xsd:dateTime)</code></td>
    <td><code>45</code></td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-seconds" id="func-seconds"></a>17.4.5.7 seconds</h5>

<pre class="prototype"> <span class="return">xsd:decimal</span>  <span class="operator">SECONDS</span> (<span class="type"><span class="type">xsd:dateTime</span></span> <span class="parm">arg</span>)</pre>

<p><code>arg</code>の字句形式の秒の部分を返します。</p>

<p>この関数は、<a href="www.w3.org/TR/xpath-functions/#func-seconds-from-dateTime">fn:seconds-from-dateTime</a>に相当します。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>seconds("2011-01-10T14:45:13.815-05:00"^^xsd:dateTime)</code></td>
    <td><code>13.815</code></td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-timezone" id="func-timezone"></a>17.4.5.8 timezone</h5>

<pre class="prototype"> <span class="return">xsd:dayTimeDuration</span>  <span class="operator">TIMEZONE</span> (<span class="type"><span class="type">xsd:dateTime</span></span> <span class="parm">arg</span>)</pre>

<p><code>arg</code>の時間帯の部分をxsd:dayTimeDurationとして返します。時間帯がない場合、エラーが生じます。</p>

<p>この関数は、時間帯のないリテラルの処理を除き、<a href="www.w3.org/TR/xpath-functions/#func-timezone-from-dateTime">fn:timezone-from-dateTime</a>に相当します。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>timezone("2011-01-10T14:45:13.815-05:00"^^xsd:dateTime)</code></td>
    <td><code>"-PT5H"^^xsd:dayTimeDuration</code></td>
  </tr>
  <tr>
    <td><code>timezone("2011-01-10T14:45:13.815Z"^^xsd:dateTime)</code></td>
    <td><code>"PT0S"^^xsd:dayTimeDuration</code></td>
  </tr>
  <tr>
    <td><code>timezone("2011-01-10T14:45:13.815"^^xsd:dateTime)</code></td>
    <td>error</td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-tz" id="func-tz"></a>17.4.5.9 tz</h5>

<pre class="prototype"> <span class="return">simple literal</span>  <span class="operator">TZ</span> (<span class="type"><span class="type">xsd:dateTime</span></span> <span class="parm">arg</span>)</pre>

<p><code>arg</code>の時間帯の部分をシンプルなリテラルで返します。時間帯がない場合、空の文字列を返します。</p>

<div class="result">
<table>
<tbody>
  <tr>
    <td><code>tz("2011-01-10T14:45:13.815-05:00"^^xsd:dateTime)</code></td>
    <td><code>"-05:00"</code></td>
  </tr>
  <tr>
    <td><code>tz("2011-01-10T14:45:13.815Z"^^xsd:dateTime)</code></td>
    <td><code>"Z"</code></td>
  </tr>
  <tr>
    <td><code>tz("2011-01-10T14:45:13.815"^^xsd:dateTime)</code></td>
    <td><code>""</code></td>
  </tr>
</tbody>
</table>

</div>
</div>
</div>
<div class="div3">

<h4>
<a name="func-hash" id="func-hash"></a>17.4.6 ハッシュ関数</h4>

<div class="div4">

<h5>
<a name="func-md5" id="func-md5"></a>17.4.6.1 MD5</h5>

<pre class="prototype"> <span class="return">simple literal</span>  <span class="operator">MD5</span> (<span class="type"><span class="type simple literal">simple literal</span></span> <span class="name">arg</span>)</pre>

<pre class="prototype"> <span class="return">simple literal</span>  <span class="operator">MD5</span> (<span class="type"><span class="type simple literal">xsd:string</span></span> <span class="name">arg</span>)</pre>

<p><code>xsd:string</code>をシンプルなリテラルか字句形式のUTF-8で処理したMD5チェックサムを16進数の文字列で返します。16進数は、小文字であるべきです（<em class="rfc2119" title="RFC 2119のコンテキストにおけるキーワード">SHOULD</em>）。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>MD5("abc")</code></td>
    <td><code>"900150983cd24fb0d6963f7d28e17f72"</code></td>
  </tr>
  <tr>
    <td><code>MD5("abc"^^xsd:string)</code></td>
    <td><code>"900150983cd24fb0d6963f7d28e17f72"</code></td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-sha1" id="func-sha1"></a>17.4.6.2 SHA1</h5>

<pre class="prototype"> <span class="return">simple literal</span>  <span class="operator">SHA1</span> (<span class="type"><span class="type simple literal">simple literal</span></span> <span class="name">arg</span>)</pre>

<pre class="prototype"> <span class="return">simple literal</span>  <span class="operator">SHA1</span> (<span class="type"><span class="type simple literal">xsd:string</span></span> <span class="name">arg</span>)</pre>

<p><code>xsd:string</code>をシンプルなリテラルか字句形式のUTF-8で処理したSHA1チェックサムを16進数の文字列で返します。16進数は、小文字であるべきです（<em class="rfc2119" title="RFC 2119のコンテキストにおけるキーワード">SHOULD</em>）。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>SHA1("abc")</code></td>
    <td><code>"a9993e364706816aba3e25717850c26c9cd0d89d"</code></td>
  </tr>
  <tr>
    <td><code>SHA1("abc"^^xsd:string)</code></td>
    <td><code>"a9993e364706816aba3e25717850c26c9cd0d89d"</code></td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-sha256" id="func-sha256"></a>17.4.6.3 SHA256</h5>

<pre class="prototype"> <span class="return">simple literal</span>  <span class="operator">SHA256</span> (<span class="type"><span class="type simple literal">simple literal</span></span> <span class="name">arg</span>)</pre>

<pre class="prototype"> <span class="return">simple literal</span>  <span class="operator">SHA256</span> (<span class="type"><span class="type simple literal">xsd:string</span></span> <span class="name">arg</span>)</pre>

<p><code>xsd:string</code>をシンプルなリテラルか字句形式のUTF-8で処理したSHA256チェックサムを16進数の文字列で返します。16進数は、小文字であるべきです（<em class="rfc2119" title="RFC 2119のコンテキストにおけるキーワード">SHOULD</em>）。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>SHA256("abc")</code></td>
    <td><code>"ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad"</code></td>
  </tr>
  <tr>
    <td><code>SHA256("abc"^^xsd:string)</code></td>
    <td><code>"ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad"</code></td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-sha384" id="func-sha384"></a>17.4.6.4 SHA384</h5>

<pre class="prototype"> <span class="return">simple literal</span>  <span class="operator">SHA384</span> (<span class="type"><span class="type simple literal">simple literal</span></span> <span class="name">arg</span>)</pre>

<pre class="prototype"> <span class="return">simple literal</span>  <span class="operator">SHA384</span> (<span class="type"><span class="type simple literal">xsd:string</span></span> <span class="name">arg</span>)</pre>

<p><code>xsd:string</code>をシンプルなリテラルか字句形式のUTF-8で処理したSHA384チェックサムを16進数の文字列で返します。16進数は、小文字であるべきです（<em class="rfc2119" title="RFC 2119のコンテキストにおけるキーワード">SHOULD</em>）。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>SHA384("abc")</code></td>
    <td><code>"cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed8086072ba1e7cc2358baeca134c825a7"</code></td>
  </tr>
  <tr>
    <td><code>SHA384("abc"^^xsd:string)</code></td>
    <td><code>"cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed8086072ba1e7cc2358baeca134c825a7"</code></td>
  </tr>
</tbody>
</table>

</div>
</div>
<div class="div4">

<h5>
<a name="func-sha512" id="func-sha512"></a>17.4.6.5 SHA512</h5>

<pre class="prototype"> <span class="return">simple literal</span>  <span class="operator">SHA512</span> (<span class="type"><span class="type simple literal">simple literal</span></span> <span class="name">arg</span>)</pre>

<pre class="prototype"> <span class="return">simple literal</span>  <span class="operator">SHA512</span> (<span class="type"><span class="type simple literal">xsd:string</span></span> <span class="name">arg</span>)</pre>

<p><code>xsd:string</code>をシンプルなリテラルか字句形式のUTF-8で処理したSHA512チェックサムを16進数の文字列で返します。16進数は、小文字であるべきです（<em class="rfc2119" title="RFC 2119のコンテキストにおけるキーワード">SHOULD</em>）。</p>

<div class="result">

<table>
<tbody>
  <tr>
    <td><code>SHA512("abc")</code></td>
    <td><code>"ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f"</code></td>
  </tr>
  <tr>
    <td><code>SHA512("abc"^^xsd:string)</code></td>
    <td><code>"ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f"</code></td>
  </tr>
</tbody>
</table>

</div>
</div>
</div>
</div>
<div class="div2">

<h3>
<a name="FunctionMapping" id="FunctionMapping"></a>17.5 XPathコンストラクタ関数</h3>

<p>SPARQLは、<a class="norm" href="www.w3.org/TR/xpath-functions/">XQuery 1.0とXPath 2.0関数および演算子</a>[<a href="#FUNCOP">FUNCOP</a>]の<a class="norm" href="www.w3.org/TR/xpath-functions/#casting-from-primitive-to-primitive">17.1 プリミティブ型からプリミティブ型へのキャスティング</a>で定義されているXPathコンストラクタ関数のサブセットをインポートします。SPARQLコンストラクタは、RDFデータ・モデルが規定している<a href="#operandDataTypes">SPARQLオペランド・データ型</a>と<a href="#operandDataTypes">付加的なデータ型</a>のXPathコンストラクタのすべてを含んでいます。SPARQLのキャスティングは、情報源の型のオペランドにターゲット型に対するコンストラクタ関数を呼び出すことによって実行されます。</p>

<p>XPathは、1つのXMLスキーマ・データ型から別のデータ型へのキャストのみを定義しています。残りのキャストは、次の通り定義されています。</p>

<ul>
  <li>
<span class="IRI type">IRI</span>を<code>xsd:string</code>にキャストすると、そのIRIを構成するコードポイントの字句値を持つ<span class="IRI typedLiteral">型付きリテラル</span>、および<code>xsd:string</code>のデータ型が作成されます。</li>
  <li>
<span class="simpleLiteral type">シンプルなリテラル</span>のXMLスキーマ・データ型へのキャスティングは、ターゲットのデータ型にリテラルの字句値と等しい<a href="www.w3.org/TR/xpath20/#dt-string-value">文字列値</a>を持つ<code>xsd:string</code>をキャストしたときの生成物であると定義されます。</li>
</ul>

<p>次の表では、キャスティング操作が常に許されるもの（<span class="castY">Y</span>）、決して許されないもの（<span class="castN">N</span>）、字句値次第のもの（<span class="castM">M</span>）にまとめています。例えば、<code>xsd:string</code>（最初の行）から<code>xsd:float</code>（2番目の列）へのキャスティング操作は、字句値（<span class="castM">M</span>）次第です。</p>

<blockquote>
<p>bool = <a class="norm" href="www.w3.org/TR/xmlschema-2/#boolean">xsd:boolean</a><br>
dbl = <a class="norm" href="www.w3.org/TR/xmlschema-2/#double">xsd:double</a><br>
flt = <a class="norm" href="www.w3.org/TR/xmlschema-2/#float">xsd:float</a><br>
dec = <a class="norm" href="www.w3.org/TR/xmlschema-2/#decimal">xsd:decimal</a><br>
int = <a class="norm" href="www.w3.org/TR/xmlschema-2/#integer">xsd:integer</a><br>
dT = <a class="norm" href="www.w3.org/TR/xmlschema-2/#dateTime">xsd:dateTime</a><br>
str = <a class="norm" href="www.w3.org/TR/xmlschema-2/#string">xsd:string</a><br>
<span class="rdfDM">IRI</span> = <span class="type IRI">IRI</span><br>
<span class="rdfDM">ltrl</span> = <code>simple literal</code></p>
</blockquote>

<table class="casting" summary="Casting table" border="1" cellpadding="1">
<col width="13%" span="1">
<col width="11%" span="1">
<col width="11%" span="1">
<col width="11%" span="1">
<col width="11%" span="1">
<col width="11%" span="1">
<col width="11%" span="1">
<col width="11%" span="1">
<thead>
  <tr>
    <th><span class="cancast" title="From\To">From \ To</span></th>
    <th><span class="cancast" title="string">str</span></th>
    <th><span class="cancast" title="float">flt</span></th>
    <th><span class="cancast" title="double">dbl</span></th>
    <th><span class="cancast" title="decimal">dec</span></th>
    <th><span class="cancast" title="integer">int</span></th>
    <th><span class="cancast" title="dateTime">dT</span></th>
    <th><span class="cancast" title="boolean">bool</span></th>
  </tr>
</thead>
<tbody>
  <tr>
    <th><span class="cancast" title="string">str</span></th>
    <td class="castY" align="center" valign="middle"><span class="cancast" title="Cast string to string? Yes">Y</span></td>
    <td class="castM" align="center" valign="middle"><span class="cancast" title="Cast string to float? Maybe">M</span></td>
    <td class="castM" align="center" valign="middle"><span class="cancast" title="Cast string to double? Maybe">M</span></td>
    <td class="castM" align="center" valign="middle"><span class="cancast" title="Cast string to decimal? Maybe">M</span></td>
    <td class="castM" align="center" valign="middle"><span class="cancast" title="Cast string to integer? Maybe">M</span></td>
    <td class="castM" align="center" valign="middle"><span class="cancast" title="Cast string to dateTime? Maybe">M</span></td>
    <td class="castM" align="center" valign="middle"><span class="cancast" title="Cast string to boolean? Maybe">M</span></td>
  </tr>
  <tr>
    <th><span class="cancast" title="float">flt</span></th>
    <td class="castY" align="center" valign="middle"><span class="cancast" title="Cast float to string? Yes">Y</span></td>
    <td class="castY" align="center" valign="middle"><span class="cancast" title="Cast float to float? Yes">Y</span></td>
    <td class="castY" align="center" valign="middle"><span class="cancast" title="Cast float to double? Yes">Y</span></td>
    <td class="castM" align="center" valign="middle"><span class="cancast" title="Cast float to decimal? Maybe">M</span></td>
    <td class="castM" align="center" valign="middle"><span class="cancast" title="Cast float to integer? Maybe">M</span></td>
    <td class="castN" align="center" valign="middle"><span class="cancast" title="Cast float to dateTime? No">N</span></td>
    <td class="castY" align="center" valign="middle"><span class="cancast" title="Cast float to boolean? Yes">Y</span></td>
  </tr>
  <tr>
    <th><span class="cancast" title="double">dbl</span></th>
    <td class="castY" align="center" valign="middle"><span class="cancast" title="Cast double to string? Yes">Y</span></td>
    <td class="castY" align="center" valign="middle"><span class="cancast" title="Cast double to float? Yes">Y</span></td>
    <td class="castY" align="center" valign="middle"><span class="cancast" title="Cast double to double? Yes">Y</span></td>
    <td class="castM" align="center" valign="middle"><span class="cancast" title="Cast double to decimal? Maybe">M</span></td>
    <td class="castM" align="center" valign="middle"><span class="cancast" title="Cast double to integer? Maybe">M</span></td>
    <td class="castN" align="center" valign="middle"><span class="cancast" title="Cast double to dateTime? No">N</span></td>
    <td class="castY" align="center" valign="middle"><span class="cancast" title="Cast double to boolean? Yes">Y</span></td>
  </tr>
  <tr>
    <th><span class="cancast" title="decimal">dec</span></th>
    <td class="castY" align="center" valign="middle"><span class="cancast" title="Cast decimal to string? Yes">Y</span></td>
    <td class="castY" align="center" valign="middle"><span class="cancast" title="Cast decimal to float? Yes">Y</span></td>
    <td class="castY" align="center" valign="middle"><span class="cancast" title="Cast decimal to double? Yes">Y</span></td>
    <td class="castY" align="center" valign="middle"><span class="cancast" title="Cast decimal to decimal? Yes">Y</span></td>
    <td class="castY" align="center" valign="middle"><span class="cancast" title="Cast decimal to integer? Yes">Y</span></td>
    <td class="castN" align="center" valign="middle"><span class="cancast" title="Cast decimal to dateTime? No">N</span></td>
    <td class="castY" align="center" valign="middle"><span class="cancast" title="Cast decimal to boolean? Yes">Y</span></td>
  </tr>
  <tr>
    <th><span class="cancast" title="integer">int</span></th>
    <td class="castY" align="center" valign="middle"><span class="cancast" title="Cast integer to string? Yes">Y</span></td>
    <td class="castY" align="center" valign="middle"><span class="cancast" title="Cast integer to float? Yes">Y</span></td>
    <td class="castY" align="center" valign="middle"><span class="cancast" title="Cast integer to double? Yes">Y</span></td>
    <td class="castY" align="center" valign="middle"><span class="cancast" title="Cast integer to decimal? Yes">Y</span></td>
    <td class="castY" align="center" valign="middle"><span class="cancast" title="Cast integer to integer? Yes">Y</span></td>
    <td class="castN" align="center" valign="middle"><span class="cancast" title="Cast integer to dateTime? No">N</span></td>
    <td class="castY" align="center" valign="middle"><span class="cancast" title="Cast integer to boolean? Yes">Y</span></td>
  </tr>
  <tr>
    <th><span class="cancast" title="dateTime">dT</span></th>
    <td class="castY" align="center" valign="middle"><span class="cancast" title="Cast dateTime to string? Yes">Y</span></td>
    <td class="castN" align="center" valign="middle"><span class="cancast" title="Cast dateTime to float? No">N</span></td>
    <td class="castN" align="center" valign="middle"><span class="cancast" title="Cast dateTime to double? No">N</span></td>
    <td class="castN" align="center" valign="middle"><span class="cancast" title="Cast dateTime to decimal? No">N</span></td>
    <td class="castN" align="center" valign="middle"><span class="cancast" title="Cast dateTime to integer? No">N</span></td>
    <td class="castY" align="center" valign="middle"><span class="cancast" title="Cast dateTime to dateTime? Yes">Y</span></td>
    <td class="castN" align="center" valign="middle"><span class="cancast" title="Cast dateTime to boolean? No">N</span></td>
  </tr>
  <tr>
    <th><span class="cancast" title="boolean">bool</span></th>
    <td class="castY" align="center" valign="middle"><span class="cancast" title="Cast boolean to string? Yes">Y</span></td>
    <td class="castY" align="center" valign="middle"><span class="cancast" title="Cast boolean to float? Yes">Y</span></td>
    <td class="castY" align="center" valign="middle"><span class="cancast" title="Cast boolean to double? Yes">Y</span></td>
    <td class="castY" align="center" valign="middle"><span class="cancast" title="Cast boolean to decimal? Yes">Y</span></td>
    <td class="castY" align="center" valign="middle"><span class="cancast" title="Cast boolean to integer? Yes">Y</span></td>
    <td class="castN" align="center" valign="middle"><span class="cancast" title="Cast boolean to dateTime? No">N</span></td>
    <td class="castY" align="center" valign="middle"><span class="cancast" title="Cast boolean to boolean? Yes">Y</span></td>
  </tr>
  <tr>
    <th><span class="cancast rdfDM" title="IRI">IRI</span></th>
    <td class="castY" align="center" valign="middle"><span class="cancast rdfDM" title="Cast IRI to string? Yes">Y</span></td>
    <td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast IRI to float? No">N</span></td>
    <td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast IRI to double? No">N</span></td>
    <td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast IRI to decimal? No">N</span></td>
    <td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast IRI to integer? No">N</span></td>
    <td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast IRI to dateTime? No">N</span></td>
    <td class="castN" align="center" valign="middle"><span class="cancast rdfDM" title="Cast IRI to boolean? No">N</span></td>
  </tr>
  <tr>
    <th><span class="cancast rdfDM" title="Literal">ltrl</span></th>
    <td class="castY" align="center" valign="middle"><span class="cancast rdfDM" title="Cast Literal to string? Yes">Y</span></td>
    <td class="castM" align="center" valign="middle"><span class="cancast rdfDM" title="Cast Literal to float? No">M</span></td>
    <td class="castM" align="center" valign="middle"><span class="cancast rdfDM" title="Cast Literal to double? No">M</span></td>
    <td class="castM" align="center" valign="middle"><span class="cancast rdfDM" title="Cast Literal to decimal? No">M</span></td>
    <td class="castM" align="center" valign="middle"><span class="cancast rdfDM" title="Cast Literal to integer? No">M</span></td>
    <td class="castM" align="center" valign="middle"><span class="cancast rdfDM" title="Cast Literal to dateTime? No">M</span></td>
    <td class="castM" align="center" valign="middle"><span class="cancast rdfDM" title="Cast Literal to boolean? No">M</span></td>
  </tr>
</tbody>
</table>

</div>
<div class="div2">

<h3>
<a name="extensionFunctions" id="extensionFunctions"></a>17.6 拡張可能な値テスト</h3>

<p>ある条件でエラーを返すように定められている関数や演算子も、有効な拡張ポイントであることに注意すべきです。つまり、実装では、これらのエラーが発生した場合には非エラー値が返され、この勧告との適合性も保たれます。</p>

<p><a href="#rPrimaryExpression">PrimaryExpression</a>の文法規則は、IRIで指定された拡張関数への呼び出しでありえます。拡張関数は、RDF用語のいくつかを引数と見なして、RDF用語を返します。これらの関数のセマンティクスは、関数を識別するIRIによって識別されます。</p>

<p>拡張関数を用いるSPARQLクエリは、相互運用性を制限する可能性があります。</p>

<p>例として、<code>func:even</code>と呼ばれる関数を取り上げます。</p>

<pre class="prototype"> <code>xsd:boolean</code>   <code>func:even</code> (<code><span class="type numeric">numeric</span></code> <code>value</code>)</pre>
<div class="exampleGroup">
<div class="queryGroup">

<p>この関数は、次のとおり、そういうものとしてFILTERに呼び出されるでしょう。</p>

<pre class="query">PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
PREFIX func: &lt;http://example.org/functions#&gt;
SELECT ?name ?id
WHERE { ?x foaf:name  ?name ;
           func:empId   ?id .
        FILTER (func:even(?id)) }</pre>
</div>
</div>

<p>2番目の例では、2つの地点の間の距離を計算する関数<code>aGeo:distance</code>について考えてみます。ここでは、これをグルノーブル（Grenoble）付近の場所を発見するために用います。</p>

<pre class="prototype"> <code>xsd:double</code>???<code>aGeo:distance</code> (<code><span class="type numeric">numeric</span></code> <code>x1</code>, <code><span class="type numeric">numeric</span></code> <code>y1</code>, <code><span class="type numeric">numeric</span></code> <code>x2</code>, <code><span class="type numeric">numeric</span></code> <code>y2</code>)</pre>
<div class="exampleGroup">
<div class="queryGroup">

<pre class="query">PREFIX aGeo: &lt;http://example.org/geo#&gt;

SELECT ?neighbor
WHERE { ?a aGeo:placeName "Grenoble" .
        ?a aGeo:locationX ?axLoc .
        ?a aGeo:locationY ?ayLoc .

        ?b aGeo:placeName ?neighbor .
        ?b aGeo:locationX ?bxLoc .
        ?b aGeo:locationY ?byLoc .

        FILTER ( aGeo:distance(?axLoc, ?ayLoc, ?bxLoc, ?byLoc) &lt; 10 ) .
      }</pre>
</div>
</div>

<p>拡張関数は、コアSPARQL仕様でサポートされていないアプリケーション・データ型をテストするために用いられるかもしれず、例えばこれは、別の日付フォーマットからXSD dateTime RDF用語へのデータ型フォーマット間の変換であるかもしれません。</p>

</div>
</div>
<div class="div1">

<h2>
<a name="sparqlDefinition" id="sparqlDefinition"></a>18 SPARQLの定義</h2>

<p>この項では、クエリ文字列とRDFデータセットを前提に、グラフ・パターンとソリューション修飾子の評価のに対する正しい行動を定義します。これは、SPARQL実装がここで定義されたプロセスを使用しなければならないということを意味しません。</p>

<p>SPARQLクエリを実行した結果は、SPARQLクエリを文字列として開始し、その文字列を抽象構文形式に変え、次に、その抽象構文をSPARQLの代数の演算子で構成されるSPARQL抽象クエリに変える、という一連のステップで定義されます。その後、この抽象クエリは、RDFデータセットで評価されます。</p>

<div class="div2">

<h3>
<a name="initDefinitions" id="initDefinitions"></a>18.1 初期定義</h3>
<div class="div3">

<h4>
<a name="sparqlBasicTerms" id="sparqlBasicTerms"></a>18.1.1 RDF用語</h4>

<p>SPARQLは、IRI[<a href="#rfc3987">RFC3987</a>]の用語で定義されています。IRIは、スペースの使用を省略するRDF URI参照のサブセットです。</p>

<div class="defn">
<b>定義: <a id="defn_RDFTerm" name="defn_RDFTerm">RDF用語</a></b>

<p>IをすべてのIRIの集合とする。<br>
RDF-Lをすべての<a class="norm" href="www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-literal">RDFリテラル</a>の集合とする。<br>
RDF-BをすべてのRDFグラフにおける<a class="norm" href="www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-blank-node">空白ノード</a>の集合とする。</p>

<p><span class="definedTerm">RDF用語</span>の集合、RDF-Tは、I ∪ RDF-L ∪ RDF-Bです。</p>

</div>

<p><span class="definedTerm">RDF用語</span>のこの定義は、 <a class="norm" href="www.w3.org/TR/2004/REC-rdf-concepts-20040210/#section-data-model">RDFデータ・モデル</a>のいくつかの基本的な概念をまとめていますが、RDF URI参照ではなくIRIを参照言するように<a href="www.w3.org/TR/rdf-concepts/#section-Graph-URIref">更新</a>されています。</p>

</div>
<div class="div3">

<h4>
<a name="simple_literal" id="simple_literal"></a>18.1.2 Simple Literal</h4>

<div class="defn">

<p><b>定義: <a id="defn_SimpleLiteral" name="defn_SimpleLiteral">Simple Literal</a></b></p>

<p>The set of <b>Simple Literals</b> is the set of all <a class="norm" href="www.w3.org/TR/2004/REC-rdf-concepts-20040210/#dfn-literal">RDF Literals</a> with no language tag or datatype IRI.</p>

</div>
</div>
<div class="div3">

<h4>
<a name="sparqlDataset" id="sparqlDataset"></a>18.1.3 RDFデータセット</h4>

<div class="defn">
<b>定義: <a id="defn_RDFDataset" name="defn_RDFDataset">RDFデータセット</a></b>

<p>RDFデータセットは以下の集合です。<br>
            { G, (&lt;u<sub>1</sub>&gt;, G<sub>1</sub>), (&lt;u<sub>2</sub>&gt;, G<sub>2</sub>), . . .
            (&lt;u<sub>n</sub>&gt;, G<sub>n</sub>) }<br>
ここでは、Gと各G<sub>i</sub>はグラフであり、各&lt;u<sub>i</sub>&gt;はIRIです。各&lt;u<sub>i</sub>&gt;はdistinctです。</p>

<p>Gはデフォルト・グラフと呼ばれます。（&lt;u<sub>i</sub>&gt;, G<sub>i</sub>）は名前付きグラフと呼ばれます。</p>

</div>
<div class="defn">
<b>定義: <a id="defn_ActiveGraph" name="defn_ActiveGraph">アクティブ・グラフ</a></b>

<p><b>アクティブ・グラフ</b>は、基本グラフパターン・マッチングに用いられるデータセットのグ ラフです。</p>

</div>
<div class="defn">

<p><b><a id="defn_RDFDatasetMerge" name="defn_RDFDatasetMerge">Definition: RDF Dataset Merge</a></b></p>

<p>Let DS1 = 
	     { G1, (&lt;u1<sub>1</sub>&gt;, G1<sub>1</sub>), (&lt;u1<sub>2</sub>&gt;, G1<sub>2</sub>), . . .
	     (&lt;u1<sub>n</sub>&gt;, G1<sub>n</sub>) },<br>
	     and DS2 = 
	     { G2, (&lt;u2<sub>1</sub>&gt;, G2<sub>1</sub>), (&lt;u2<sub>2</sub>&gt;, G2<sub>2</sub>), . . .
	     (&lt;u2<sub>m</sub>&gt;, G2<sub>m</sub>) }</p>

<p>
	     then we define the RDF Dataset Merge of DS1 and DS2 to be:<br>
	     DS={ G, (&lt;u<sub>1</sub>&gt;, G<sub>1</sub>), (&lt;u<sub>2</sub>&gt;, G<sub>2</sub>), . . .
	     (&lt;u<sub>k</sub>&gt;, G<sub>k</sub>) }<br>
	     where:</p>

<p>Write N1 for { &lt;u1<sub>j</sub>&gt; j = 1 to n }<br>
	     Write N2 for { &lt;u2<sub>j</sub>&gt; j = 1 to m }<br>
	     </p>

<ul>
<li>G is the <a href="www.w3.org/TR/rdf-mt/#defmerge">merge</a> of G1 and G2</li>
  <li>(&lt;u<sub>i</sub>&gt;, G<sub>i</sub>) where &lt;u<sub>i</sub>&gt; is in N1 but not in N2</li>
  <li>(&lt;u<sub>i</sub>&gt;, G<sub>i</sub>) where &lt;u<sub>i</sub>&gt; is in N2 but not in N1 </li>
  <li>(&lt;u<sub>i</sub>&gt;, G<sub>i</sub>) where &lt;u<sub>i</sub>&gt; is equal to &lt;u<sub>j</sub>&gt; in N1 and equal to &lt;u<sub>k</sub>&gt; in N2 and G<sub>i</sub> is the <a href="www.w3.org/TR/rdf-mt/#defmerge">merge</a> of G1<sub>j</sub> and G2<sub>k</sub>
</li>
</ul>
</div>
</div>
<div class="div3">

<h4>
<a name="sparqlQueryVariables" id="sparqlQueryVariables"></a>18.1.4 クエリ変数</h4>

<div class="defn">
<b>定義: <a id="defn_QueryVariable" name="defn_QueryVariable">クエリ変数</a></b>

<p><span class="definedTerm">クエリ変数</span>は、Vが無限であり、RDF-Tと互いに素な集合Vのメンバーです。</p>

</div>
</div>
<div class="div3">

<h4>
<a name="sparqlTriplePatterns" id="sparqlTriplePatterns"></a>18.1.5 トリプル・パターン</h4>

<div class="defn">
<b>定義: <a id="defn_TriplePattern" name="defn_TriplePattern">トリプル・パターン</a></b>

<p><span class="definedTerm">トリプル・パターン</span>は、次の集合のメンバーです。<br>
            (RDF-T ∪ V) x (I ∪ V) x (RDF-T ∪ V)</p>

</div>

<p>トリプル・パターンのこの定義には、リテラルの主語が含まれています。<a href="www.w3.org/2000/03/rdf-tracking/#rdfms-literalsubjects">これは、RDF-コアで注記されています。</a></p>

<pre>「[RDFコア・ワーキンググループは]リテラルが主語であってはならない理由がないことを
承知していると述べました。そして、より制限のない憲章を持つ将来のWGは、ステートメン
トの主語としてのリテラルを許容するように構文を拡張するかもしれません。」</pre>

<p>RDFグラフはリテラルの主語を含まないかもしれないため、リテラルを主語として持つ任意のSPARQLトリプル・パターンは、どんなRDFグラフにもマッチしないでしょう。</p>

</div>
<div class="div3">

<h4>
<a name="sparqlBasicGraphPatterns" id="sparqlBasicGraphPatterns"></a>18.1.6 基本グラフ・パターン</h4>

<div class="defn">
<b>定義: <a id="defn_BasicGraphPattern" name="defn_BasicGraphPattern">基本グラフ・パターン</a></b>

<p><span class="definedTerm">基本グラフ・パターンは</span>、<a href="#defn_TriplePattern">トリプル・パターン</a>の集合です。</p>

</div>

<p>空のグラフ・パターンは、空集合である基本グラフ・パターンです。</p>
</div>
<div class="div3">

<h4>
<a name="sparqlPropertyPaths" id="sparqlPropertyPaths"></a>18.1.7 プロパティー・パス・パターン</h4>

<div class="defn">
<b>定義: <a id="defn_PropertyPath" name="defn_PropertyPath">プロパティー・パス</a></b>

<p>プロパティー・パスは、n = length(ST)-1の場合に、i=0 to nについて、t<sub>i</sub>の目的語がt<sub>i+1</sub>の主語と同じ用語であるような、シーケンスSTのt<sub>i</sub>のトリプルのシーケンスです。</p>

<p>t<sub>0</sub>の主語をパスの始点と呼びます。</p>

<p>t<sub>n</sub>の目的語をパスの終点と呼びます。</p>

<p>個々のt<sub>i</sub>がGのトリプルである場合、プロパティー・パスはグラフGのパスです。</p>

</div>

<p>プロパティー・パスの範囲は、データセット内の複数のグラフには及びません。</p>

<div class="defn">
<b>定義: <a id="defn_PropertyPathExpr" name="defn_PropertyPathExpr">プロパティー・パス式</a></b>

<p>プロパティー・パス式は、<a>上記</a>のプロパティー・パス形式を用いた式です。</p>

</div>
<div class="defn">
<b>定義: <a id="defn_PropertyPathPattern" name="defn_PropertyPathPattern">プロパティー・パス・パターン</a></b>

<p>PPをすべてのプロパティー・パス式の集合とします。プロパティー・パス・パターンは、以下の集合のメンバーです。<br>
            (RDF-T ∪ V) x PP x (RDF-T ∪ V)</p>

</div>

<p>プロパティー・パス・パターンは、プロパティー・パス式をプロパティー・ポジションに含めるために、<a href="#defn_TriplePattern">トリプル・パターン</a>を一般化したものです。</p>

</div>
<div class="div3">

<h4>
<a name="sparqlSolutions" id="sparqlSolutions"></a>18.1.8 ソリューション・マッピング</h4>

<p>ソリューション・マッピングは、1組の変数から1組のRDF用語へのマッピングです。我々は、それが明確である場合に「ソリューション」という用語を使用します。</p>

<div class="defn">
<b>定義: <a id="defn_sparqlSolutionMapping" name="defn_sparqlSolutionMapping">ソリューション・マッピング</a></b>

<p><b>ソリューション・マッピング</b>、μは、部分関数μ : V -> RDF-Tです。</p>

<p>μの定義域、dom(μ)は、μが定義されている場合のVのサブセットです。</p>

</div>
<div class="defn">
<b>定義: <a id="defn_sparqlSolutionSequence" name="defn_sparqlSolutionSequence">ソリューション・シーケンス</a></b>

<p><b>ソリューション・シーケンス</b>は、ソリューションのリストで、順不同でありえます。</p>

</div>

<p>μから得られた変数に対する用語を用いて、式exprの値に対するexpr(μ)を記述します。評価は、エラーになるかもしれません。</p>

</div>
<div class="div3">

<h4>
<a name="sparqlSolMod" id="sparqlSolMod"></a>18.1.9 ソリューション・シーケンス修飾子</h4>

<div class="defn">
<b>定義: <a id="defn_SolutionModifier" name="defn_SolutionModifier">ソリューション・シーケンス修飾子</a></b>

<p><span class="definedTerm">ソリューション・シーケンス修飾子</span>は、次のうちの1つです。</p>

<ul>
  <li>
<a href="#defn_algOrdered">Order By</a>修飾子: ソリューションを順序付けします。</li>
  <li>
<a href="#defn_algProjection">Projection</a>修飾子: ある変数を選択します。</li>
  <li>
<a href="#defn_algDistinct">Distinct</a>修飾子: シーケンス中のソリューションを確実にユニークにします。</li>
  <li>
<a href="#defn_algReduced">Reduced</a>修飾子: distinctではないソリューションの排除を許可します。</li>
  <li>
<a href="#defn_algSlice">Offset</a>修飾子: 全体のソリューションのシーケンスの中でどこからソリューションが始まるかを制御します。</li>
  <li>
<a href="#defn_algSlice">Limit</a>修飾子: ソリューションの数を制限します。</li>
</ul>

</div>
</div>
<div class="div3">

<h4>
<a name="idp2427544" id="idp2427544"></a>18.1.10 SPARQLクエリ</h4>

<div class="defn">
<b>定義: <a id="defn_SPARQLQuery" name="defn_SPARQLQuery">SPARQLクエリ</a></b>

<p>以下の場合、<span class="definedTerm">SPARQL抽象クエリ</span>はタプル（E, DS, QF）です。</p>

<ul>
  <li>Eが<a href="#sparqlAlgebra">SPARQL代数式</a>である</li>
  <li>DSが<a href="#defn_RDFDataset">RDFデータセット</a>である</li>
  <li>QFが<a href="#QueryForms">クエリ形式</a>である</li>
</ul>
</div>
<div class="defn">
<b>定義: <a id="defn_QueryUnit" name="defn_QueryUnit">クエリ・レベル</a></b>

<p>クエリ・レベルは、グラフ・パターン、グループと集約の集合、ソリューション修飾子の集合です。</p>

</div>

<p>クエリは「クエリ・レベル」のツリーで、個々の<a href="#subqueries">サブクエリ</a>がツリー内の1つのクエリ・レベルを形成します。</p>

</div>
</div>
<div class="div2">

<h3>
<a name="sparqlQuery" id="sparqlQuery"></a>18.2 SPARQL代数への置換</h3>

<p>この項は、SPARQLクエリ文字列内のグラフ・パターンとソリューション修飾子をSPARQL代数式に変換するプロセスを定義します。

記述したプロセスは、1つのクエリの入れ子のレベルを変換し、入れ子の<tt>SELECT</tt>構文を用いてサブクエリによって生成される際に、サブクエリ上で再帰的に適用されます。個々のレベルは、グラフ・パターン・マッチングとフィルタリングで構成され、その後に、ソリューション修飾子のアプリケーションが続きます。</p>

<p>SPARQLクエリ文字列が分析され、<a href="#sparqlSyntax">4項</a>で示したIRIとトリプル・パターンの省略形が適用されます。現時点では、抽象構文木は、以下で構成されています。</p>

<table class="plain">
<tbody>
  <tr>
    <th>パターン</th>
    <th>修飾子</th>
    <th>クエリ形式</th>
    <th>その他</th>
  </tr>
  <tr>
    <td>RDF terms</td>
    <td>DISTINCT</td>
    <td>SELECT</td>
    <td>VALUES</td>
  </tr>
  <tr>
    <td>Property path expression</td>
    <td>REDUCED</td>
    <td>CONSTRUCT</td>
    <td>SERVICE</td>
  </tr>
  <tr>
    <td>Property path patterns</td>
    <td>Projection</td>
    <td>DESCRIBE</td>
    <td></td>
  </tr>
  <tr>
    <td>Groups</td>
    <td>ORDER BY</td>
    <td>ASK</td>
    <td></td>
  </tr>
  <tr>
    <td>OPTIONAL</td>
    <td>LIMIT</td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>UNION</td>
    <td>OFFSET</td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>GRAPH</td>
    <td>Select expressions</td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>BIND</td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>GROUP BY</td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>HAVING</td>
    <td></td>
    <td></td>    <td></td>
  </tr>
  <tr>
    <td>MINUS</td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>FILTER</td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
</tbody>
</table>


<p>このような抽象構文木を変換した結果は、次の表の符号をSPARQL代数で用いるSPARQLクエリです。</p>

<table class="plain">
<tbody>
  <tr>
    <th>グラフ・パターン</th>
    <th>ソリューション修飾子</th>
    <th>プロパティー・パス</th>
  </tr>
  <tr>
    <td>BGP </td>
    <td>ToList</td>
    <td>PredicatePath</td>
  </tr>
  <tr>
    <td>Join</td>
    <td>OrderBy</td>
    <td>InversePath</td>
  </tr>
  <tr>
    <td>LeftJoin</td>
    <td>Project</td>
    <td>SequencePath</td>
  </tr>
  <tr>
    <td>Filter</td>
    <td>Distinct</td>
    <td>AlernativePath</td>
  </tr>
  <tr>
    <td>Union</td>
    <td>Reduced</td>
    <td>ZeroOrMorePath</td>
  </tr>
  <tr>
    <td>Graph</td>
    <td>Slice</td>
    <td>OneOrMorePath</td>
  </tr>
  <tr>
    <td>Extend</td>
    <td>ToMultiSet</td>
    <td>ZeroOrOnePath</td>
  </tr>
  <tr>
    <td>Minus</td>
    <td></td>
    <td>NegatedPropertySet</td>
  </tr>
  <tr>
    <td>Group</td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>Aggregation</td>
    <td></td>
    <td></td>
  </tr>
  <tr>
    <td>AggregateJoin</td>
    <td></td>
    <td></td>
  </tr>
</tbody>
</table>

<p><i>Slice</i>は、OFFSETとLIMITを組み合わせたものです。</p>

<p><i>ToList</i>はグラフ・パターン・マッチングの結果からシーケンスへの変換が起こる場合に用いられます。</p>

<p>ソリューション・シーケンスから多重集合への変換が生じる場合には、<i>ToMultiSet</i>が用いられます。</p>

<div class="div3">

<h4>
<a name="variableScope" id="variableScope"></a>18.2.1 変数の範囲</h4>

<p>このドキュメントでは、SPARQL代数をクエリに対して実行する際に、変換がその時点でのソリューション・マッピングの定義域内に存在していれば、変数は<i>範囲内</i>であると定義します。下記の定義では、クエリの抽象構文からこれを判断する方法を示しています。</p>

<p>射影を持つサブクエリが変数を見えなくできることに注意してください。<code>FILTER</code>または<code>MINUS</code>の変数を用いても、変数がそれらの形式の外部で範囲内になることはありません。</p>

<p><b>P</b>、<b>P1</b>、<b>P2</b>がグラフ・パターンであり、<b>E</b>、<b>E1</b>、,...<b>En</b>が式であるとします。以下のとき、変数<code>v</code>は範囲内です。</p>

<table style="border-collapse: collapse; border-color: #000000" border="1" cellpadding="5">
<tbody>
  <tr>
    <th>構文形式</th>
    <th>範囲内の変数</th>
  </tr>
  <tr>
    <td>Basic Graph Pattern (BGP)</td>
    <td>
<code>v</code>はBGPで発生する。</td>
  </tr>
  <tr>
    <td>Path </td>
    <td>
<code>v</code>はパスで発生する。</td>
  </tr>
  <tr>
    <td>Group <code>{ P1 P2 ... }</code>
</td>
    <td>
<code>v</code>が、1以上のP1、P2で範囲内にあれば、それは範囲内</td>
  </tr>
  <tr>
    <td><code>GRAPH term { P }</code></td>
    <td>
<code>v</code>は用語（<code>term</code>）、または、<code>v</code>はPにおいて範囲内</td>
  </tr>
  <tr>
    <td><code>{ P1 } UNION { P2 }</code></td>
    <td>
<code>v</code>はP1において範囲内、または、P2において範囲内</td>
  </tr>
  <tr>
    <td><code>OPTIONAL {P}</code></td>
    <td>
<code>v</code>はPにおいて範囲内</td>
  </tr>
  <tr>
    <td><code>SERVICE term {P}</code></td>
    <td>
<code>v</code>は用語（<code>term</code>）、または、<code>v</code>はPにおいて範囲内</td>
  </tr>
  <tr>
    <td><code>BIND (expr AS v)</code></td>
    <td>
<code>v</code>は範囲内</td>
  </tr>
  <tr>
    <td><code>SELECT .. v .. { P }</code></td>
    <td>
<code>v</code>は範囲内</td>
  </tr>
  <tr>
    <td><code>SELECT ... (expr AS v)</code></td>
    <td>
<code>v</code>は範囲内</td>
  </tr>
  <tr>
    <td><code>GROUP BY (expr AS v)</code></td>
    <td>
<code>v</code>は範囲内</td>
  </tr>
  <tr>
    <td><code>SELECT * { P }</code></td>
    <td>
<code>v</code>は<code>P</code>において範囲内</td>
  </tr>
  <tr>
    <td><code>VALUES v { values }</code></td>
    <td>
<code>v</code>は範囲内</td>
  </tr>
  <tr>
    <td><code>VALUES varlist { values }</code></td>
    <td>
<code>v</code>が<code>varlist</code>にあれば、<code>v</code>は範囲内</td>
  </tr>
</tbody>
</table>

<p>変数<tt>v</tt>は、<code>(expr AS v)</code>形式の部分では範囲内でありえません。<code>(expr AS v)</code>の範囲は、<code>SELECT</code>式で即座に適用されます。</p>

<p><code>BINDでは、(expr AS v)</code>は、変数<code>v</code>が、それが用いられているグループ・グラフ・パターン内の先行する要素の範囲内にはない必要があります。</p>

<p><code>SELECT</code>では、変数<code>v</code>はSELECT句のグラフ・パターンにおいて範囲内であってはならず、その句の中で選択した別の式において使用済みであってもなりません。</p>

</div>
<div class="div3">

<h4>
<a name="convertGraphPattern" id="convertGraphPattern"></a>18.2.2 グラフ・パターンの変換</h4>

<p>この項では、SPARQLグラフ・パターンをSPARQL代数式に置換するプロセスについて述べます。このプロセスは、グループ・グラフ・パターン（<code>{...}</code>区切り記号間の単位）に適用され、クエリの<code>WHERE</code>句を生成し、再帰的にグループ・グラフ・パターン内の個々の構文要素に適用されます。置換の結果は、SPARQL代数式です。</p>

<p>要約すると、次のステップで適用されます。</p>

<ul>
  <li>IRI、リテラルおよびトリプル・パターンの<a href="#sparqlExpandForms">構文形式を拡張する</a>。</li>
  <li>
<a href="#sparqlTranslatePathExpressions">プロパティー・パス式を置換する</a>。</li>
  <li>
<a href="#sparqlTranslatePathPatterns">一部のプロパティー・パス・パターンをトリプルに変換する</a>。</li>
  <li>
<a href="#sparqlCollectFilters">グループ内の<code>FILTER</code>をまとめる</a>。</li>
  <li>
<a href="#sparqlTranslateBasicGraphPatterns">基本グラフ・パターンを置換する</a>。</li>
  <li>
<a href="#sparqlTranslateGraphPatterns">グループ内の残りのグラフ・パターンを置換する</a>。</li>
  <li>
<a href="#sparqlAddFilters">フィルタに追加する</a>。</li>
  <li>
<a href="#sparqlSimplification">代数式を単純化する</a>。</li>
</ul>

<p>このドキュメントでは、グラフ・パターンを置換するためにここで記述しているリズムに対し、</p>

<blockquote>
	    translate(graph pattern)
	  </blockquote>

<p>と記述します。</p>

<div class="wgNote">ワーキンググループは、SPARQL 1.0において、単純化のステップが適用される時点で、OPTIONALにおいて、二重に入れ子になったフィルタとパターンを伴ったクエリのあいまいな変換が生じるということを指摘します。 

	    <pre><code>OPTIONAL { { ... FILTER ( ... ?x ... ) } }.</code>.</pre>

<p>次の2つの規範的でないテストケースでこれを例証します。</p>

<ul>
  <li>
<a href="www.w3.org/2001/sw/DataAccess/tests/data-r2/optional-filter/manifest#dawg-optional-filter-005-not-simplified">単純化は、すべての変換の後に適用される</a>か、または全く適用しない単純化</li>
  <li>
<a href="www.w3.org/2001/sw/DataAccess/tests/data-r2/optional-filter/manifest#dawg-optional-filter-005-simplified">単純化は、変換の間に適用される</a>。</li>
</ul>
</div>

<p>グラフ・パターンのすべての置換の後に単純化のステップを適用するのが望ましいです。</p>

<div class="div4">

<h5>
<a name="sparqlExpandForms" id="sparqlExpandForms"></a>18.2.2.1 構文形式の展開</h5>

<p><a href="#sparqlSyntax">4項</a>で示したIRIとトリプル・パターンの省略形を展開します。</p>

</div>
<div class="div4">

<h5>
<a name="sparqlCollectFilters" id="sparqlCollectFilters"></a>18.2.2.2 <code>FILTER</code>要素の集約</h5>

<p><code>FILTER</code>式は、それが出現するグループ・グラフ・パターンの全体に適用されます。フィルタリングを行なう代数演算子は、個々のグループ要素の置換の後にグループに加えられます。ここでフィルタをまとめ、それをグループから除外し、その後で、<a href="#sparqlAddFilters">置換されたグループ・グラフ・パターンの全体にそれを適用</a>します。</p>

<p>このステップで、<a href="#func-filter-exists"><code>EXISTS</code>と<code>NOT EXISTS</code></a>というFILTER式のグラフ・パターンも置換します。</p>

<pre class="codeBlock">Let FS := empty set

For each form FILTER(expr) in the group graph pattern:
    In expr, replace NOT EXISTS{P} with fn:not(<a href="#defn_evalExists">exists(translate(P)))</a> 
    In expr, replace EXISTS{P} with <a href="#defn_evalExists">exists(translate(P))</a>
    FS := FS ∪ {expr}
    End</pre>

<p>フィルタ式の集合<code>FS</code>は、<a href="#sparqlAddFilters">後で使用</a>します。</p>

</div>
<div class="div4">

<h5>
<a name="sparqlTranslatePathExpressions" id="sparqlTranslatePathExpressions"></a>18.2.2.3 プロパティー・パス式の置換</h5>

<p>下記の表は、SPARQL構文からSPARQL代数の用語へのプロパティー・パス式の置換を示しています。これは、プロパティー・パス式のすべての要素に再帰的に適用されます。</p>

<p><a href="#sparqlTranslatePathPatterns">この後の、次のステップ</a>は、ある形式をトリプル・パターンに置換し、それは後で、隣接（グループ・パターン区切り記号である<tt>{</tt>と<tt>}</tt>が間に入らない）または他の構文形式により、基本グラフ・パターンに変換されます。全体として、単なる1つのIRIのSPARQL構文プロパティー・パスは、フック数のトリプル・パターンになり、それらは基本グラフ・パターンに集約されます。</p>

<p>注意:</p>

<ul>
  <li>否定のプロパティー集合のIRIと^IRIの形式の順序は関係ありません。</li>
</ul>

<p>次の符号を導入しています。</p>

<ul>
  <li>link</li>
  <li>inv</li>
  <li>alt</li>
  <li>seq</li>
  <li>ZeroOrMorePath</li>
  <li>OneOrMorePath</li>
  <li>ZeroOrOnePath</li>
  <li>NPS（NegatedPropertySetに対し）</li>
</ul>

<table style="border-collapse: collapse; border-color: #000000" border="1" cellpadding="5">
<tbody>
  <tr>
    <th>構文形式（パス）</th>
    <th>代数（パス）</th>
  </tr>
  <tr>
    <td><code>iri</code></td>
    <td><code>link(iri)</code></td>
  </tr>
  <tr>
    <td><code>^path</code></td>
    <td><code>inv(path)</code></td>
  </tr>
  <tr>
    <td><code>!(:iri<sub>1</sub>|...|:iri<sub>n</sub>)</code></td>
    <td><code>NPS({:iri<sub>1</sub> ... :iri<sub>n</sub>})</code></td>
  </tr>
  <tr>
    <td><code>!(^:iri<sub>1</sub>|...|^:iri<sub>n</sub>)</code></td>
    <td><code>inv(NPS({:iri<sub>1</sub> ... :iri<sub>n</sub>}))</code></td>
  </tr>
  <tr>
    <td>
<code>!(:iri<sub>1</sub>|...|:iri<sub>i</sub>|^:iri<sub>i+1</sub>|...|^:iri<sub>m</sub>)</code>?</td>
    <td>
<code>alt(NPS({:iri<sub>1</sub> ...:iri<sub>i</sub>}),<br>
		            ????inv(NPS({:iri<sub>i+1</sub>, ..., :iri<sub>m</sub>})) )</code>
		  </td>
  </tr>
  <tr>
    <td><code>path1 / path2</code></td>
    <td><code>seq(path1, path2)</code></td>
  </tr>
  <tr>
    <td><code>path1 | path2</code></td>
    <td>
<code>alt(path1, path2)</code> </td>
  </tr>
  <tr>
    <td><code>path*</code></td>
    <td><code>ZeroOrMorePath(path)</code></td>
  </tr>
  <tr>
    <td><code>path+</code></td>
    <td><code>OneOrMorePath(path)</code></td>
  </tr>
  <tr>
    <td><code>path?</code></td>
    <td><code>ZeroOrOnePath(path)</code></td>
  </tr>
</tbody>
</table>

</div>
<div class="div4">

<h5>
<a name="sparqlTranslatePathPatterns" id="sparqlTranslatePathPatterns"></a>18.2.2.4 プロパティー・パス・パターンの置換</h5>

<p>前のステップでは、<a href="#defn_PropertyPathExpr">プロパティー・パス式</a>を置換しました。このステップでは、<a href="#defn_PropertyPathPattern">プロパティー・パス・パターン</a>（主語エンドポイント、プロパティー・パス式、目的語エンドポイント）をトリプル・パターンに置換するか、パス評価のための一般的な代数の操作にラップします。</p>

<p>注意:</p>

<ul>
  <li>XとYはRDF用語か変数です。</li>
  <li>?Vは新しい変数です。</li>
  <li>PとQはパス式です。</li>
  <li>これらは、プロパティー・パス式内ではなく、プロパティー・パス・パターンにのみ適用されます。</li>
  <li>表の最初の置換の方が、最後の置換より優先的に適用されます。</li>
  <li>最後の置換は、<code>Path(...)</code>という一般的な形式を用いるために、任意の残りのプロパティー・パス式をシンプルにラップします。</li>
</ul>

<table style="border-collapse: collapse; border-color: #000000" border="1" cellpadding="5">
<tbody>
  <tr>
    <th>代数（パス）</th>
    <th>置換</th>
  </tr>
  <tr>
    <td><code>X link(iri) Y</code></td>
    <td><code>X iri Y</code></td>
  </tr>
  <tr>
    <td><code>X inv(iri) Y</code></td>
    <td><code>Y iri X</code></td>
  </tr>
  <tr>
    <td><code>X seq(P, Q) Y</code></td>
    <td><code>X P ?V . ?V Q P</code></td>
  </tr>
  <tr>
    <td><code>X P Y</code></td>
    <td><code>Path(X, P, Y)</code></td>
  </tr>
</tbody>
</table>


<p>全体的なパス置換プロセスの例（<code>?_V</code>は、新しい変数）:</p>

<div class="algExample">
<div class="algExample1">
		?s :p/:q ?o
	      </div>
<div class="algExample2">
		 ?s :p ?_V . <br>
                 ?_V :q ?o
	      </div>
</div>
<div class="algExample">
<div class="algExample1">
		?s :p* ?o
	      </div>
<div class="algExample2">
		Path(?s, ZeroOrMorePath(link(:p)), ?o)
	      </div>
</div>
<div class="algExample">
<div class="algExample1">
		:list rdf:rest*/rdf:first ?member
	      </div>
<div class="algExample2">
		Path(:list, ZeroOrMorePath(link(rdf:rest)), ?_V) .<br>
		?_V rdf:first ?member
	      </div>
</div>
</div>
<div class="div4">

<h5>
<a name="sparqlTranslateBasicGraphPatterns" id="sparqlTranslateBasicGraphPatterns"></a>18.2.2.5 基本グラフ・パターンの置換</h5>

<p>プロパティー・パスの置換後に、基本グラフ・パターン<code>BGP(triples)</code>を形成するために、隣接するトリプル・パターンを集めます。</p>

</div>
<div class="div4">

<h5>
<a name="sparqlTranslateGraphPatterns" id="sparqlTranslateGraphPatterns"></a>18.2.2.6 グラフ・パターンの置換</h5>

<p>次に、置換プロセスを再帰的に適用し、個々の残りのグラフ・パターン形式を置き換えます。</p>

<blockquote>
    <p>形式が<code><a href="#rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</a></code>の場合</p>
</blockquote>

<pre class="codeBlock">A := 未定義とします。
          
For each element G in the GroupOrUnionGraphPattern
    If A is undefined
        A := Translate(G)
    Else
        A := Union(A, Translate(G))
    End

結果はA</pre>

<blockquote>
    <p>形式が<code><a href="#rGraphGraphPattern">GraphGraphPattern</a></code>の場合</p>
</blockquote>

<pre class="codeBlock">形式がGRAPH IRI GroupGraphPatternであれば、
    結果はGraph(IRI, Translate(GroupGraphPattern))</pre>

<pre class="codeBlock">形式がGRAPH Var GroupGraphPatternであれば、
    結果はGraph(Var, Translate(GroupGraphPattern))</pre>

<blockquote>
    <p>形式が<code><a href="#rGroupGraphPattern">GroupGraphPattern</a></code>の場合</p>
</blockquote>

<pre class="codeBlock">S := 空の集合とします。
G := 空のパターン、空の集合である基本グラフ・パターンとします。

For each element E in the GroupGraphPattern

    If E is of the form OPTIONAL{P}
        A := Translate(P)とし、
        If A is of the form Filter(F, A2)
            G := LeftJoin(G, A2, F)
        Else 
            G := LeftJoin(G, A, true)
            End
        End

    If E is of the form MINUS{P}
        G := Minus(G, Translate(P))
        End

    If E is of the form BIND(expr AS var)
        G := Extend(G, var, expr)
        End

    If E is any other form 
        Let A := Translate(E)
        G := Join(G, A)
        End

   End
   
結果はGです。</pre>

<blockquote>
    <p>形式が<a href="#rInlineData">InlineData</a>の場合</p>
</blockquote>

<pre class="codeBlock">結果はソリューション・マッピング「データ」の多重集合です。</pre>

<div id="data-block">
<blockquote>
<i>データ</i>は、複数の変数（または、1つの変数）のリストにおいて対応する位置にある変数からソリューション・マッピングを作成することで作成され、<code>BindingValue</code>が単語<code>UNDEF</code>であれば、バインディングを削除します。</blockquote>
</div>

<blockquote>
    <p>形式が<a href="#rSubSelect">SubSelect</a>の場合</p>
</blockquote>

<pre class="codeBlock">結果はToMultiset(Translate(SubSelect))</pre>
</div>
<div class="div4">

<h5>
<a name="sparqlAddFilters" id="sparqlAddFilters"></a>18.2.2.7 グループのフィルタ</h5>

<p>グループの置換後に、フィルタ式を追加して、グループの残りのすべてに適用されるようにします。</p>

<pre class="codeBlock">If FS is not empty
    Let G := output of preceding step
    Let X := Conjunction of expressions in FS
    G := Filter(X, G)
    End</pre>
</div>
<div class="div4">

<h5>
<a name="sparqlSimplification" id="sparqlSimplification"></a>18.2.2.8 単純化のステップ</h5>

<p>Zが空の基本グラフ・パターン（空集合）である場合、1つのグラフ・パターンの一部のグループは<code>join(Z, A)</code>になります。これらは、Aで置き換えることができます。空のグラフ・パターンZは、joinと同値です。</p>

<pre class="codeBlock">Replace join(Z, A) by A
Replace join(A, Z) by A</pre>
</div>
</div>
<div class="div3">



<h4>
<a name="sparqlAlgebraExamples" id="sparqlAlgebraExamples"></a>18.2.3 マッピングされたグラフ・パターンの例</h4>

<p>書き換えの例の2番目の形式は、1番目のものに単純化のステップで削除した空のグループのjoinを付けたものです。</p>

<p>例: 1つのトリプル・パターンから成る1つの基本グラフ・パターンを持つグループ</p>

<div class="algExample">
<div class="algExample1">{ ?s ?p ?o }</div>
<div class="algExample2">Join(Z, BGP(?s ?p ?o) )</div>
<div class="algExample2">BGP(?s ?p ?o)</div>
</div>

<p>例: 2つのトリプル・パターンから成る1つの基本グラフ・パターンを持つグループ</p>

<div class="algExample">
<div class="algExample1">{ ?s :p1 ?v1 ; :p2 ?v2 }</div>
<div class="algExample2">BGP( ?s :p1 ?v1 . ?s :p2 ?v2 )</div>
</div>

<p>例: 2つの基本グラフ・パターンの和集合から成るグループ</p>

<div class="algExample">
<div class="algExample1">{ { ?s :p1 ?v1 } UNION {?s :p2 ?v2 } }</div>
<div class="algExample2">Union(Join(Z, BGP(?s :p1 ?v1)),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p2 ?v2)) )</div>
<div class="algExample2">Union( BGP(?s :p1 ?v1) , BGP(?s :p2 ?v2) )</div>
</div>

<p>例: 1つの和集合と1つの基本グラフ・パターンの和集合から成るグループ</p>

<div class="algExample">
<div class="algExample1">{ { ?s :p1 ?v1 } UNION {?s :p2 ?v2 } UNION {?s :p3 ?v3 } }</div>
<div class="algExample2">Union(<br>
&nbsp;&nbsp;&nbsp; Union( Join(Z, BGP(?s :p1 ?v1)),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p2 ?v2))) ,<br>
&nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p3 ?v3)) )</div>
<div class="algExample2">Union( <br>
&nbsp;&nbsp;&nbsp; Union( BGP(?s :p1 ?v1) ,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BGP(?s :p2 ?v2),<br>
&nbsp;&nbsp;&nbsp; BGP(?s :p3 ?v3))</div>
</div>

<p>例: 1つの基本グラフ・パターンと1つのオプションのグラフ・パターンから成るグループ</p>

<div class="algExample">
<div class="algExample1">{ ?s :p1 ?v1 OPTIONAL {?s :p2 ?v2 } }</div>
<div class="algExample2">LeftJoin(<br>
&nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p1 ?v1)),<br>
&nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p2 ?v2)),<br>
&nbsp;&nbsp;&nbsp; true)</div>
<div class="algExample2">LeftJoin(BGP(?s :p1 ?v1), BGP(?s :p2 ?v2), true)</div>
</div>

<p>例: 1つの基本グラフ・パターンと2つのオプションのグラフ・パターンから成るグループ</p>

<div class="algExample">
<div class="algExample1">{ ?s :p1 ?v1 OPTIONAL {?s :p2 ?v2 } OPTIONAL { ?s :p3 ?v3 } }</div>
<div class="algExample2">LeftJoin(<br>
&nbsp;&nbsp;&nbsp; LeftJoin(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BGP(?s :p1 ?v1),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BGP(?s :p2 ?v2),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true) ,<br>
&nbsp;&nbsp;&nbsp; BGP(?s :p3 ?v3),<br>
&nbsp;&nbsp;&nbsp; true)</div>
</div>

<p>例: 1つの基本グラフ・パターンとフィルタを持つ1つのオプションのグラフ・パターンから成るグループ</p>

<div class="algExample">
<div class="algExample1">{ ?s :p1 ?v1 OPTIONAL {?s :p2 ?v2 FILTER(?v1&lt;3) } }</div>
<div class="algExample2">LeftJoin(<br>
&nbsp;&nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p1 ?v1)),<br>
&nbsp;&nbsp;&nbsp;&nbsp; Join(Z, BGP(?s :p2 ?v2)),<br>
&nbsp;&nbsp;&nbsp;&nbsp; (?v1&lt;3) )</div>
<div class="algExample2">LeftJoin(<br>
&nbsp;&nbsp;&nbsp; BGP(?s :p1 ?v1) ,<br>
&nbsp;&nbsp;&nbsp; BGP(?s :p2 ?v2) ,<br>
&nbsp;&nbsp; (?v1&lt;3) )</div>
</div>

<p>例: 1つの和集合のグラフ・パターンと1つのオプションのグラフ・パターンから成るグループ</p>

<div class="algExample">
<div class="algExample1">{ {?s :p1 ?v1} UNION {?s :p2 ?v2} OPTIONAL {?s :p3 ?v3} }</div>
<div class="algExample2">LeftJoin(<br>
&nbsp;Union(BGP(?s :p1 ?v1),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BGP(?s :p2 ?v2)) ,<br>
&nbsp;BGP(?s :p3 ?v3) ,<br>
&nbsp;true )</div>
</div>

<p>例: 1つの基本グラフ・パターン、1つのフィルタ、および1つのオプションのグラフ・パターンから成るグループ</p>

<div class="algExample">
<div class="algExample1">{ ?s :p1 ?v1 FILTER (?v1 &lt; 3 ) OPTIONAL {?s :p2 ?v2} }</div>
<div class="algExample2">Filter( ?v1 &lt; 3 ,<br>
&nbsp;LeftJoin( BGP(?s :p1 ?v1), BGP(?s :p2 ?v2), true) ,<br>
&nbsp;)</div>
</div>

<p>例: BINDを含むパターン</p>

<div class="algExample">
<div class="algExample1">{ ?s :p ?v . BIND (2*?v AS ?v2) ?s :p1 ?v2 }</div>
<div class="algExample2">Join(<br>
&nbsp;&nbsp; Extend( BGP(?s :p ?v), ?v2, 2*?v) , <br>
&nbsp;&nbsp; BGP(?s :p1 ?v2))</div>
</div>

<p>例: BINDを含むパターン</p>

<div class="algExample">
<div class="algExample1">{ ?s :p ?v . {} BIND (2*?v AS ?v2) }</div>
<div class="algExample2">Join(<br>
&nbsp;&nbsp; BGP(?s :p ?v), ?v2, 2*?v) , <br>
&nbsp;&nbsp; Extend({}, ?v2, 2*?v) <br>
)</div>
</div>

<p>例: MINUSを含むパターン</p>

<div class="algExample">
<div class="algExample1">{ ?s :p ?v . MINUS {?s :p1 ?v2 } }</div>
<div class="algExample2">Minus(<br>
&nbsp;&nbsp; BGP(?s :p ?v)<br>
&nbsp;&nbsp; BGP(?s :p1 ?v2))</div>
</div>

<p>例: サブクエリを含むパターン</p>

<div class="algExample">
<div class="algExample1">{ ?s :p ?o . {SELECT DISTINCT ?o {?o ?p ?z} } }</div>
<div class="algExample2">Join(<br>
&nbsp;&nbsp; BGP(?s :p ?o) ,<br>
&nbsp;&nbsp; ToMultiSet(<br>
&nbsp;&nbsp;&nbsp;&nbsp; Distinct(Project(BGP(?o ?p ?z), {?o})) )<br>
&nbsp;&nbsp;)</div>
</div>
</div>
<div class="div3">

<h4>
<a name="convertGroupAggSelectExpressions" id="convertGroupAggSelectExpressions"></a>18.2.4 グループ、集約、HAVING、最後のVALUES句、SELECT式の変換</h4>

<p>このステップでは、次の順にクエリ・レベルの句を処理します。</p>

<ul>
  <li>グルーピング</li>
  <li>集約</li>
  <li>HAVING</li>
  <li>VALUES</li>
  <li>Select式</li>
</ul>
<div class="div4">

<h5>
<a name="sparqlGroupAggregate" id="sparqlGroupAggregate"></a>18.2.4.1 グルーピングと集約</h5>

<p>ステップ: GROUP BY</p>

<p><code>GROUP BY</code>キーワードを用いている場合や、射影で集約を用いることにより暗黙的なグルーピングが存在する場合には、<a href="#defn_algGroup">グループ</a>関数によってグルーピングが行なわれます。これにより、ソリューションの集合は、全体的に同じカーディナリティーを持つ、1つ以上のソリューションのグループに分割されます。暗黙的なグルーピングの場合では、固定定数(1)を用いて、すべてのソリューションを一つのグループにグループ化します。</p>

<p>ステップ: 集約</p>

<p>集約のステップは、クエリ・レベルで変換として適用され、クエリ・レベルの集約式をAggregation()代数式に置換します。</p>

<p>集約を用いたクエリ・レベルの変換は、次のようになります。</p>

<pre class="codeBlock">Let A := the empty sequence
Let Q := the query level being evaluated
Let P := the algebra translation of the GroupGraphPattern of the query level
Let E := [], a list of pairs of the form (variable, expression)

If Q contains GROUP BY exprlist
   Let G := Group(exprlist, P)
Else If Q contains an aggregate in SELECT, HAVING, ORDER BY
   Let G := Group((1), P)
Else
   skip the rest of the aggregate step
   End

Global i := 1   # Initially 1 for each query processed

For each (X AS Var) in SELECT, each HAVING(X), and each ORDER BY X in Q
  For each unaggregated variable V in X
      Replace V with Sample(V)
      End
  For each aggregate R(args ; scalarvals) now in X
      # note scalarvals may be omitted, then it's equivalent to the empty set
      A<span><sub>i</sub></span> := Aggregation(args, R, scalarvals, G)
      Replace R(...) with agg<span><sub>i</sub></span> in Q
      i := i + 1
      End
  End

For each variable V appearing outside of an aggregate
   A<span><sub>i</sub></span> := Aggregation(V, Sample, {}, G)
   E := E append (V, agg<span><sub>i</sub></span>)
   i := i + 1
   End

A := A<span><sub>i</sub></span>, ..., A<span><sub>i-1</sub></span>
P := AggregateJoin(A)</pre>

<p>注: agg<sub>i</sub>は一時変数です。Eは、その後、18.2.4.4のselect式の処理に用いられます。</p>

<p>例:</p>

<pre class="query">PREFIX rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;
SELECT (SUM(?val) AS ?sum) (COUNT(?a) AS ?count)
WHERE {
  ?a rdf:value ?val .
} GROUP BY ?a</pre>

<p>SUM式はagg<sub>1</sub>になり、COUNT式はagg<sub>2</sub>になります。</p>

<pre class="code">Let G := Group((?a), BGP(?a rdf:value ?val))
<span>A<sub>1</sub></span> = Aggregation((?val), Sum, {}, G)
<span>A<sub>2</sub></span> = Aggregation((?a), Count, {}, G)
A := (<span>A<sub>1</sub>, A<sub>2</sub></span>)
Let P := AggregateJoin(A)</pre>
</div>
<div class="div4">

<h5>
<a name="sparqlHavingClause" id="sparqlHavingClause"></a>18.2.4.2 HAVING</h5>

<p>HAVING式は、FILTER()と同じ規則を用いて評価されます。HAVING句が評価されるロジック・ポジションのため、SELECT句によって射影された式がHAVING句では表示されないことに注意してください。</p>

<pre class="codeBlock">Let Q := the query level being evaluated
Let P := the algebra translation of the query level so far

For each HAVING(E) in Q
    P := Filter(E, P)
    End</pre>
</div>
<div class="div4">

<h5>
<a name="sparqlAlgebraFinalValues" id="sparqlAlgebraFinalValues"></a>18.2.4.3 VALUES</h5>

<p>クエリに、後続するVALUES句がある場合:</p>

<pre class="codeBlock">Let P := the algebra translation of the query level so farP := Join(P, ToMultiSet(data))
  where <i>data</i> is a solution sequence formed from the VALUES clause</pre>

<p>データの置換は、<a href="#data-block">インライン・データ</a>のものと同じです。</p>

</div>
<div class="div4">

<h5>
<a name="sparqlSelectExpressions" id="sparqlSelectExpressions"></a>18.2.4.4 SELECT式</h5>

<p>ステップ: Select式</p>

<p>考慮すべき抽象構文の形式が2つあります。</p>

<pre class="codeBlock">SELECT selItem ... { pattern }
SELECT * { pattern }</pre>

<pre class="codeBlock">Let X := algebra from earlier steps
Let VS := list of all variables visible in the pattern,
           so restricted by sub-SELECT projected variables and GROUP BY variables.
           Not visible: only in filter, exists/not exists, masked by a subselect, 
                        non-projected GROUP variables, only in the right hand side of MINUS

Let PV := {}, a set of variable names
Note, E is a list of pairs of the form (variable, expression), defined in <a href="#convertGroupAggSelectExpressions">section 18.2.4</a>
  
If "SELECT *"
    PV := VS

If  "SELECT <code>selItem ...</code>:"  
    For each selItem:
        If selItem is a variable
            PV := PV ∪ { variable }
        End
        If selItem is (expr AS variable)
            variable must not appear in VS nor in PV; if it does then generate a syntax error and stop
            PV := PV ∪ { variable }
            E := E append (variable, expr) 
        End
    End

For each pair (var, expr) in E
    X := Extend(X, var, expr)
    End
  
Result is X  
The set PV is used later for projection.</pre>

<p>変数がSELECTのWHERE句の中で用いられていたり、このSELECT式の中でASのターゲットとして既に用いられている場合には、AS（例えば... AS? x）の名前付きターゲットとして変数を用いると構文エラーが発生します。</p>

</div>
</div>
<div class="div3">

<h4>
<a name="convertSolMod" id="convertSolMod"></a>18.2.5 ソリューション修飾子の変換</h4>

<p>ソリューション修飾子は、パターン・マッチングの後でSPARQLクエリの処理に適用します。ソリューション修飾子は、次の順序でクエリに適用されます。</p>

<ul>
  <li>Order by</li>
  <li>Projection</li>
  <li>Distinct</li>
  <li>Reduced</li>
  <li>Offset</li>
  <li>Limit</li>
</ul>

<p>ステップ: ToList</p>

<p>ToListは、多重集合を、同じ要素とカーディナリティーを持つシーケンスに変えます。シーケンスに対する暗黙的な順序付けはありません。同じものが隣接している必要はありません。</p>

<blockquote>
            <p>Let M := ToList(Pattern)</p>
          </blockquote>
<div class="div4">

<h5>
<a name="sparqlOrderBy" id="sparqlOrderBy"></a>18.2.5.1 ORDER BY</h5>

<p>クエリ文字列にORDER BY句がある場合、</p>

<blockquote>
            <p>M := OrderBy(M, list of order comparators)</p>
          </blockquote>
</div>
<div class="div4">

<h5>
<a name="sparqlProjection" id="sparqlProjection"></a>18.2.5.2 射影</h5>

<p>射影変数の集合である<code>PV</code>は、<a href="#sparqlSelectExpressions">SELECT式の処理</a>において算出されました。</p>

<blockquote>
              <p>M := Project(M, PV)</p>
            </blockquote>

<p>ここでは、varsは、SELECT句で記述された変数の集合であるか、SELECT *が用いられた場合には、クエリ中で<a href="#variableScope">範囲内</a>にあるすべての名前付き変数です。</p>

</div>
<div class="div4">

<h5>
<a name="sparqlDistinct" id="sparqlDistinct"></a>18.2.5.3 DISTINCT</h5>

<p>クエリがDISTINCTを含んでいる場合、</p>

<blockquote>
              <p>M := Distinct(M)</p>
            </blockquote>
</div>
<div class="div4">

<h5>
<a name="sparqlReduced" id="sparqlReduced"></a>18.2.5.4 REDUCED</h5>

<p>クエリがREDUCEDを含んでいる場合、</p>

<blockquote>
              <p>M := Reduced(M)</p>
            </blockquote>
</div>
<div class="div4">

<h5>
<a name="sparqlOffsetLimit" id="sparqlOffsetLimit"></a>18.2.5.5 OFFSETとLIMIT</h5>

<p>クエリが「OFFSET開始」または「LIMITの長さ」を含んでいる場合、</p>

<blockquote>
              <p>M := Slice(M, start, length)</p>
              <blockquote>
                <p>start defaults to 0</p>
                <p>length defaults to (size(M)-start).</p>
              </blockquote>
            </blockquote>
</div>
<div class="div4">

<h5>
<a name="sparqlAlgebraOutcome" id="sparqlAlgebraOutcome"></a>18.2.5.6 最後の代数式</h5>

<blockquote>全般的な抽象クエリはMです。</blockquote>

</div>
</div>
</div>
<div class="div2">

<h3>
<a name="BasicGraphPattern" id="BasicGraphPattern"></a>18.3 基本グラフ・パターン</h3>

<p>グラフ・パターンをマッチさせるときには、可能なソリューションは、<i>バッグ</i>（bag）としても知られている<i><a href="en.wikipedia.org/w/index.php?title=Multiset&amp;oldid=163605900">多重集合</a></i>[<a href="#multiset">multiset</a>]を形成します。多重集合は、各要素が1回以上出現しうる要素の順不同のコレクションです。これは、多重集合内の集合の各要素の出現回数を示す、1組の要素とカーディナリティー関数で記述されます。</p>

<p>ソリューション・マッピングを、μと記述する。</p>

<p>dom(μ<sub>0</sub>)が空の集合であるようなマッピングを、μ<sub>0</sub>と記述します。</p>

<p>カーディナリティー1を持つ、空のマッピングμ<sub>0,</sub>からきっかり成る多重集合を、Ω<sub>0</sub>と記述します。これは、joinと同値です。</p>

<p>RDF用語t : { (x, t) }に対するソリューション・マッピング変数xを、μ(x)と記述します。</p>

<p>きっかりμ(?x->t)から成る多重集合、つまり、カーディナリティー1を持つ{ { (x, t) } }を、Ω(x)と記述します。</p>

<div class="defn">
<b>定義: <a id="defn_algCompatibleMapping" name="defn_algCompatibleMapping">互換マッチング</a></b>

<p>2つのソリューション・マッピングμ<sub>1</sub>とμ<sub>2</sub>は、dom(μ<sub>1</sub>)およびdom(μ<sub>2</sub>)のすべての変数vに対し、μ<sub>1</sub>(v) = μ<sub>2</sub>(v)である場合、互換性があります。</p>

</div>

<p>Here, μ<sub>1</sub>(v) = μ<sub>2</sub>(v) means that μ<sub>1</sub>(v) and μ<sub>2</sub>(v) are the same RDF term.</p>

<p>μ<sub>1</sub>とμ<sub>2</sub>に互換性がある場合、μ<sub>1</sub> ∪ μ<sub>2</sub>もマッピングです。μ<sub>1</sub> ∪ μ<sub>2</sub>を、merge(μ<sub>1</sub>, μ<sub>2</sub>)と記述します。</p>

<p>マッピングΩの多重集合におけるソリューション・マッピングμのカーディナリティーを、card[Ω](μ)と記述します。</p>

<div class="div3">

<h4>
<a name="BGPsparql" id="BGPsparql"></a>18.3.1 SPARQLの基本グラフ・パターン・マッチング</h4>

<p>基本グラフ・パターンは、クエリの当該部分に対するアクティブ・グラフにマッチングします。変数と空白ノードの両方を用語に置き換えることによって、インスタンスの2つの概念を示し、基本グラフ・パターンをインスタンス化できます。空白ノードは、<a href="www.w3.org/TR/rdf-mt#definst">RDFインスタンス・マッピング</a>σを用いて空白ノードからRDF用語に置き換えられ、変数は、ソリューション・マッピングによってクエリ変数からRDF用語に置き換えられます。</p>

<div class="defn">
<b>定義: <a id="defn_PatternInstanceMapping" name="defn_PatternInstanceMapping">パターン・インスタンス・マッピング</a></b>

<p><b>パターン・インスタンス・マッピング</b>Pは、RDFインスタンス・マッピングσとソリューション・マッピングμの組み合わせです。 P(x) = μ(σ(x))</p>

</div>

<p>BGP「x」の場合、P(x)は、σが定義されているxの空白ノードbとσ(b)とを入れ替え、μが定義されているxのすべての変数vとμ(v)とを入れ替えた結果を示します。</p>

<p>任意のパターン・インスタンス・マッピングは、それぞれクエリ変数と空白ノードに制限することによって得られた、ユニークなソリューション・マッピングおよびユニークなRDFインスタンス・マッピングを定義します。</p>

<div class="defn">
<b>定義: 基本グラフ・パターン・マッチング</b>

<p>BGPを基本グラフ・パターンとし、GをRDFグラフとします。</p>

<p>P(BGP)がGのサブグラフであり、μがBGPのクエリ変数に対するPの制限であるような、パターン・インスタンス・マッピングPがあるとき、μは、GからのBGPの<b>ソリューション</b>です。</p>

<p>card[Ω](μ) = card[Ω]（P = μ(σ) であるような異なるRDFインスタンス・マッピングの数、σはパターン・インスタンス・マッピングであり、P(BGP)はGのサブグラフです）。</p>

</div>

<p>基本グラフ・パターンが空の集合である場合、ソリューションはΩ<sub>0</sub>です。</p>

</div>
<div class="div3">

<h4>
<a name="BGPsparqlBNodes" id="BGPsparqlBNodes"></a>18.3.2 空白ノードの処理</h4>

<p>この定義によって、ソリューション・マッピングは、基本グラフ・パターンであるBGPの変数をGの空白ノードにバインドできます。SPARQLは、結果フォーマットのドキュメント（<a href="www.w3.org/TR/rdf-sparql-XMLres/">SPARQLクエリ結果XMLフォーマット</a>、<a href="www.w3.org/TR/sparql11-results-json/">SPARQL 1.1クエリ結果JSONフォーマット</a>、<a href="www.w3.org/TR/sparql11-results-csv-tsv/">SPARQL 1.1クエリ結果CSVおよびTSVフォーマット</a>）の空白ノード識別子をそのドキュメントに対して有効であるものとして扱うため、データセットのアクティブ・グラフにおけるノードを識別しているとは解釈されませんしたがって、DSがクエリのデータセットである場合、パターンのソリューションはDS自身のアクティブ・グラフからのものではなくRDFグラフからのものであると解釈され、これは<i>スコーピング・グラフ</i>と呼ばれ、DSのアクティブ・グラフに対しグラフ同等（graph-equivalent）であるけれどもDSまたはBGPと空白ノードを共有しません。スコーピング・グラフは、1つのクエリに対するすべてのソリューションに用いられます。スコーピング・グラフは、純粋に理論的構成概念（theoretical construct）で、実際には、単なる空白ノード識別子に対するドキュメント範囲の慣習によって効果が得られます。</p>

<p>RDFの空白ノードが多くのパターンに対する多くの重複するソリューションを無限に許すため、多くのパターンのソリューション（空白ノードを別の空白ノードに置き換えることによって得られる）が無限に存在しえます。したがって、何らかの形で基本グラフ・パターンのソリューションを区切る必要があります。SPARQLは、基本グラフ・パターンのソリューションを決定するために、サブグラフ・マッチの基準を用います。基本グラフ・パターンからアクティブ・グラフのサブセットにマッピングする異なるパターンのインスタンスに対し、それぞれ1つのソリューションが存在します。</p>

<p>これは、重複の排除よりむしろ計算の容易さのために最適化されます。これによって、データセットのアクティブ・グラフが<a href="www.w3.org/TR/rdf-mt/#deflean">貧弱</a>であるときでも、クエリ結果に重複を含むことができ、論理的に同等なデータセットが異なるクエリ結果を出すことが可能になります。</p>

</div>
</div>
<div class="div2">

<h3>
<a name="PropertyPathPatterns" id="PropertyPathPatterns"></a>18.4 プロパティー・パス・パターン</h3>

<p>この項では、<a href="#defn_PropertyPathPattern">プロパティー・パス・パターン</a>の評価について定義します。プロパティー・パス・パターンは、主語エンドポイント（RDF用語または変数）、プロパティー・パス式および目的語エンドポイントです。<a href="#sparqlTranslatePathExpressions">プロパティー・パス式の置換</a>は、長さ1のプロパティー・パスをトリプル・パターンに変換するなど、ある形式を他のSPARQL式に変換し、これは次に基本グラフ・パターンにまとめられます。これによって、ZeroOrOnePath、ZeroOrMorePath、OneOrMorePath、NegatedPropertySetsというプロパティー・パス・オペレーターと、さらに、これらのオペレーター内に含まれているパス式が残ります。</p>

<p>すべの残りのプロパティー・パス式は、エンドポイントのXとYに対し、<code>Path(X, path, Y)</code>という形式で代数内にあります。例えば、<code>(:p/:q)*</code>という構文は、ZeroOrMorePath式で、シーケンス・プロパティー・パスを伴い、<code>ZeroOrMorePath(seq(link(:p), link(:q)))</code>という代数式になります。</p>

<div class="defn">

<p><b><a name="pp-eval-notation" id="pp-eval-notation">表記法</a></b></p>

<p>プロパティー・パス・パターンの評価の場合、</p>

<pre>eval(Path(X, PP, Y))</pre>

<p>と記述します。これによって、ソリューション・マッピングμの多重集合が作成され、個々のソリューション・マッピングは、使用されている変数のバインディングを持っています（XとYはそれぞれ、変数になりえる）。一部の演算子は、1つのソリューション・マッピングの集合を作成するだけです。</p>

<p><code>x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>n</sub></code>の変数の場合、</p>

<div class="pre">Var(x<sub>1</sub>, x<sub>2</sub>, ..., x<sub>n</sub>) = { x<sub>i</sub> | i in 1...n and x<sub>i</sub> is a variable }</div>

<p>と記述します。</p>

<p>次のように記述します。</p>

<table style="border-collapse: collapse; border-color: #000000" border="1" cellpadding="10">
<tbody>
  <tr>
    <td><code>x:term</code></td>
    <td>
<code>x</code>がRDF用語の場合</td>
  </tr>
  <tr>
    <td><code>x:var</code></td>
    <td>
<code>x</code>が変数の場合</td>
  </tr>
  <tr>
    <td><code>x:path</code></td>
    <td>
<code>x</code>がパス式の場合</td>
  </tr>
</tbody>
</table>

</div>

<p>すべての評価は、全体のクエリ評価において、その時点の<a href="#defn_ActiveGraph">アクティブ・グラフ</a>とのマッチングにより行なわれます。明確にするために、個々の定義へのアクティブ・グラフの組み込みを明示的に省略しています。</p>

<div class="defn">

<p><b>定義: <a name="defn_evalPP_predicate" id="defn_evalPP_predicate">述語プロパティー・パスの評価</a></b></p>

<p>IRI iriを用いた、パス(X, link(iri), Y)を述語逆プロパティー・パス・パターンとします。</p>

<blockquote>
	  <div class="pre">eval(Path(X, link(iri), Y)) = <a href="#BasicGraphPattern">基本グラフ・パターンの評価</a> {X iri Y}</div>
	</blockquote>
</div>

<p>XとYの両方が変数ならば、これは次と同じです。</p>

<div class="pre">eval(Path(X:var, link(iri), Y:var)) = 
    { (X, xn) (Y, yn) | xn and yn are RDF terms and triple (xn iri yn) is in the active graph }</div>

<p>Xが変数で、YがRDF用語である場合、</p>

<div class="pre">eval(Path(X:var, link(iri), Y:term)) = 
    { (X, xn) | xn is an RDF term and triple (xn iri Y) is in the active graph }</div>

<p>XがRDF用語で、Yが変数である場合、</p>

<div class="pre">eval(Path(X:term, link(iri), Y:var)) =
    { (Y, yn) | yn is an RDF term and triple (X iri yn) is in the active graph }</div>

<p>XとYの両方がRDF用語である場合、</p>

<div class="pre">eval(Path(X:term, link(iri), Y:term)) = 
    { μ<sub>0</sub> } if triple (X iri Y) is in the active graph
    = { { } }
    = Ω<sub>0</sub>

eval(Path(X:term, link(iri), Y:term)) = 
    { } if triple (X iri Y) is not in the active graph</div>

<p>非形式的には、述語プロパティ・パスの評価は、クエリ評価において、その時点のサブクエリ<code>SELECT * { <i>X P Y</i> }</code>を実行するのと同じことです。</p>

<div class="defn">

<p><b>定義: <a name="defn_evalPP_inverse" id="defn_evalPP_inverse">逆プロパティー・パスの評価</a></b></p>

<p>Pをプロパティー・パス式とすると、</p>

<blockquote>
	  <pre>eval(Path(X, inv(P), Y)) = eval(Path(Y, P, X))</pre>
	</blockquote>
</div>
<div class="defn">

<p><b>定義: <a name="defn_evalPP_sequence" id="defn_evalPP_sequence">シーケンス・プロパティー・パスの評価</a></b></p>

<p>PとQをプロパティー・パス式とします。Vを新たな変数とします。</p>

<blockquote>
	  <pre>A = Join( eval(Path(X, P, V)), eval(Path(V, Q, Y)) )</pre>
	  <pre>eval(Path(X, seq(P,Q), Y)) = Project(A, Var(X,Y))</pre>
	</blockquote>
</div>

<p>非形式的には、これは次と同じです。</p>

<pre>SELECT * { X P _:a . _:a Q Y }</pre>

<p>これは、空白ノード<code>_:a</code>は、それが<code>SELECT *</code>の結果に出現しない場合を除いて、変数のように機能する（シンプルな含意において）という事実を用いています。</p>

<div class="defn">

<p><b>定義: <a name="defn_evalPP_alternative" id="defn_evalPP_alternative">代替プロパティー・パスの評価</a></b></p>

<p>PとQをプロパティー・パス式とします。</p>

<blockquote>
	  <pre>eval(Path(X, alt(P,Q), Y)) = Union(eval(Path(X, P, Y)), eval(Path(X, Q, Y)))</pre>
	</blockquote>
</div>

<p>非形式的には、これは次と同じです。</p>

<pre>SELECT * { { X P Y } UNION { X Q Y } }</pre>
<div class="defn">

<p><b>定義: <a id="defn_nodeSet" name="defn_nodeSet">グラフのノード集合</a></b></p>

<p>グラフGのノード集合、nodes(G)は、次の通りです。</p>

<p>nodes(G) = { n | n is an RDF term that is used as a subject or object of a triple of G}</p>

</div>
<div class="defn">

<p><b>定義: <a id="defn_evalPP_ZeroOrOnePath">ZeroOrOnePathの評価</a></b></p>

<pre>eval(Path(X:term, ZeroOrOnePath(P), Y:var)) = { (Y, yn) | yn = X or {(Y, yn)} in eval(Path(X,P,Y)) }</pre>

<pre>eval(Path(X:var, ZeroOrOnePath(P), Y:term)) = { (X, xn) | xn = Y or {(X, xn)} in eval(Path(X,P,Y)) }</pre>

<pre>eval(Path(X:term, ZeroOrOnePath(P), Y:term)) = 
    { {} } if X = Y or eval(Path(X,P,Y)) is not empty
    { } othewise</pre>

<pre>eval(Path(X:var, ZeroOrOnePath(P), Y:var)) = 
    { (X, xn) (Y, yn) | either (yn in nodes(G) and xn = yn) or {(X,xn), (Y,yn)} in eval(Path(X,P,Y)) }</pre>
</div>

<p>このドキュメントでは、ZeroOrMorePathとOneOrMorePathの定義で用いられる補助関数（ALP）を定義しています。ここで示しているアルゴリズムが機能を指定する役割を果たすをことに注意してください。実装では、全体としてクエリに対して同じ結果を生むあらゆる方法による評価を自由に実行することができます。ZeroOrMorePathとOneOrMorePathの形式は、パスによって結合されている別々のノードに基づいて、マッチを返します。</p>

<p>マッチング・アルゴリズムは、すべてのパスをたどることを基礎としており、パス上でグラフ・ノード（主語または目的語）が訪問済みである場合に検知します。</p>

<p>非形式的には、このアルゴリズムは、<tt>パス</tt>の1つのアプリケーションによって、ステップごとに結果の多重集合を拡張しようと試み、この特定のパスのどのノードを既に訪問したかを指摘します。検討中のパスをノードが既に訪問していれば、それは、別のステップの候補になりません。</p>

<div class="defn">

<p><b>定義: <a name="defn_evalALP_1" id="defn_evalALP_1">関数ALP</a></b></p>

<pre>Let eval(x:term, path) be the evaluation of 'path', starting at RDF term x, 
                       and returning a multiset of RDF terms reached 
                       by repeated matches of path.

ALP(x:term, path) = 
    Let V = empty multiset
    ALP(x:term, path, V)
    return is V

# V is the set of nodes visited

ALP(x:term, path, V:set of RDF terms) =
    if ( x in V ) return 
    add x to V
    X = eval(x,path) 
    For n:term in X
        ALP(n, path, V)
        End</pre>
</div>
<div class="defn">

<p><b>定義: <a name="defn_evalZeroOrMorePath" id="defn_evalZeroOrMorePath">ZeroOrMorePath</a>の評価</b></p>

<pre>eval(Path(X:term, ZeroOrMorePath(path), vy:var)) =
    { { (vy, n) } | n in ALP(X, path) }

eval(Path(vx:var, ZeroOrMorePath(path), vy:var)) =
    { { (vx, t), (vy, n) } |  t in nodes(G), (vy, n) in eval(Path(t, ZeroOrMorePath(path), vy)) }

eval(Path(vx:var, ZeroOrMorePath(path), y:term)) = 
    eval(Path(y:term, ZeroOrMorePath(inv(path)), vx:var))

eval(Path(x:term, ZeroOrMorePath(path), y:term)) = 
    { { } } if { (vy:var,y) } in eval(Path(x, ZeroOrMorePath(path) vy)
    { } otherwise</pre>
</div>
<div class="defn">

<p><b>定義: <a name="defn_evalOneOrMorePath" id="defn_evalOneOrMorePath">OneOrMorePath</a>の評価</b></p>

<p>eval(Path(X, OneOrMorePath(path), Y))</p>

<pre># For OneOrMorePath, we take one step of the path then start
# recording nodes for results.

eval(Path(x:term, OneOrMorePath(path), vy:var)) =
    Let X = eval(x, path)
    Let V = the empty multiset
    For n in X
        ALP(n, path, V)
        End
    result is V

eval(Path(vx:var, OneOrMorePath(path), vy:var)) =
   { { (vx, t), (vy, n) } |  t in nodes(G), (vy, n) in eval(Path(t, OneOrMorePath(path), vy)) }

eval(Path(vx:var, OneOrMorePath(path), y:term)) =
   eval(Path(y:term, OneOrMorePath(inv(path)), vx))

eval(Path(x:term, OneOrMorePath(path), y:term)) =
    { { } } if { (vy:var, y) } in eval(Path(x, OneOrMorePath(path), vy))
    { } otherwise</pre>
</div>
<div class="defn">

<p><b>定義: <a id="eval_negatedPropertySet" name="eval_negatedPropertySet">NegatedPropertySetの評価</a></b></p>

<pre class="code">Write μ' as the extension of a solution mapping:
μ'(μ,x) = μ(x)   if x is a variable
μ'(μ,t) = t   if t is a RDF term</pre>

<pre class="code">Let x and y be variables or RDF terms, and S a set of IRIs:

eval(Path(x, NPS(S), y)) = { μ | ∃ triple(μ'(μ,x), p, μ'(μ,y)) in G, such that the IRI of p ? S }</pre>
</div>
</div>
<div class="div2">

<h3>
<a name="sparqlAlgebra" id="sparqlAlgebra"></a>18.5 SPARQL代数</h3>

<p>SPARQLの抽象クエリに内の残りの各シンボルに対し、評価のための演算子を定義しています。同じ名前のSPARQL代数演算子は、「<a href="#sparqlAlgebraEval">評価セマンティクス</a>」の項で記述されているように、SPARQLの抽象クエリ・ノードを評価するために用いられます。基本グラフ・パターントプロパティー・パス・パターンの評価は、上で記述しました。</p>

<div class="defn">

<p><b>定義: <a id="defn_algFilter" name="defn_algFilter">Filter</a></b></p>

<p>Ωをソリューション・マッピングの多重集合とし、exprを式とします。次のとおり定義します。</p>

<p>Filter(expr, Ω, D(G)) = { μ | μ in Ω and expr(μ) is an expression that has an 
          effective boolean value of true }</p>

<p>card[Filter(expr, Ω, D(G))](μ) = card[Ω](μ)</p>

<blockquote>
	    Note that evaluating an <code>exists(pattern)</code> expression uses the dataset and active graph, D(G).
	    See the <a href="#defn_evalFilter">evaluation of filter</a>.
	  </blockquote>
</div>
<div class="defn">

<p><b>定義: <a id="defn_algJoin" name="defn_algJoin">Join</a></b></p>

<p>Ω<sub>1</sub>とΩ<sub>2</sub>をソリューション・マッピングの多重集合とします。次のとおり定義します。</p>

<p>Join(Ω<sub>1</sub>, Ω<sub>2</sub>) = { merge(μ<sub>1</sub>, μ<sub>2</sub>) | μ<sub>1</sub>
          in Ω<sub>1</sub>and μ<sub>2</sub> in Ω<sub>2</sub>, and μ<sub>1</sub> and μ<sub>2</sub> are
          compatible }</p>

<p>card[Join(Ω<sub>1</sub>, Ω<sub>2</sub>)](μ) = <br>
          &nbsp;&nbsp;&nbsp; for each merge(μ<sub>1</sub>, μ<sub>2</sub>), μ<sub>1</sub>
          in Ω<sub>1</sub>and μ<sub>2</sub> in Ω<sub>2</sub> such that μ = merge(μ<sub>1</sub>, μ<sub>2</sub>),<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sum over (μ<sub>1</sub>, μ<sub>2</sub>), card[Ω<sub>1</sub>](μ<sub>1</sub>)*card[Ω<sub>2</sub>](μ<sub>2</sub>)</p>

</div>

<p>Joinにおけるソリューション・マッピングμは、異なるソリューション・マッピング、結合された多重集合におけるμ<sub>1</sub>とμ<sub>2</sub>において出現することは可能です。μのカーディナリティーは、すべての可能性のカーディナリティーの合計です。</p>

<div class="defn">

<p><b>定義: <a id="defn_algDiff" name="defn_algDiff">Diff</a></b></p>

<p>Ω<sub>1</sub>とΩ<sub>2</sub>をソリューション・マッピングの多重集合とし、exprを式とします。次のとおり定義します。</p>

<p>Diff(Ω<sub>1</sub>, Ω<sub>2</sub>, expr) =
          { μ | μ in Ω<sub>1</sub> such that ∀ μ′ in Ω<sub>2</sub>, 
          either μ and μ′ are not compatible or μ and μ'
          are compatible and expr(merge(μ, μ')) has an effective boolean value 
          of false }</p>

<p>card[Diff(Ω<sub>1</sub>, Ω<sub>2</sub>, expr)](μ) = card[Ω<sub>1</sub>](μ)</p>

</div>

<p>Diffは、LeftJoinの定義のために内部的に使用されます。</p>

<div class="defn">

<p><b>定義: <a id="defn_algLeftJoin" name="defn_algLeftJoin">LeftJoin</a></b></p>

<p>Ω<sub>1</sub>とΩ<sub>2</sub>をソリューション・マッピングの多重集合とし、exprを式とします。次のとおり定義します。</p>

<p>LeftJoin(Ω<sub>1</sub>, Ω<sub>2</sub>, expr) = Filter(expr, Join(Ω<sub>1</sub>, Ω<sub>2</sub>)) ∪ Diff(Ω<sub>1</sub>, Ω<sub>2</sub>, expr)</p>

<p>card[LeftJoin(Ω<sub>1</sub>, Ω<sub>2</sub>, expr)](μ) = card[Filter(expr, Join(Ω<sub>1</sub>, Ω<sub>2</sub>))](μ) + card[Diff(Ω<sub>1</sub>, Ω<sub>2</sub>, expr)](μ)</p>

</div>

<p>これは、完全形で記述すれば、次の通りです。</p>

<p>LeftJoin(Ω<sub>1</sub>, Ω<sub>2</sub>, expr) =<br>
&nbsp;&nbsp;&nbsp; { merge(μ<sub>1,</sub> μ<sub>2</sub>) | μ<sub>1</sub> in Ω<sub>1</sub> and μ<sub>2</sub> in Ω<sub>2</sub>, μ<sub>1</sub> and μ<sub>2</sub> are compatible and expr(merge(μ<sub>1</sub>, μ<sub>2</sub>)) is true }<br>
∪<br>
&nbsp;&nbsp;&nbsp; { μ<sub>1</sub> | μ<sub>1</sub> in Ω<sub>1</sub>, ∀ μ<sub>2</sub> in Ω<sub>2</sub>, μ<sub>1</sub> and μ<sub>2</sub> are not compatible, or Ω<sub>2</sub> is empty }<br>
∪<br>
&nbsp;&nbsp;&nbsp; { μ<sub>1</sub> | μ<sub>1</sub> in Ω<sub>1</sub>, ∃ μ<sub>2</sub> in Ω<sub>2</sub>, μ<sub>1</sub> and μ<sub>2</sub> are compatible and expr(merge(μ<sub>1</sub>, μ<sub>2</sub>)) is false. }</p>

<p>これらが異なっているため、LeftJoinのカーディナリティーは、定義のこれらの個々の構成要素のカーディナリティーです。</p>

<div class="defn">

<p><b>定義: <a id="defn_algUnion" name="defn_algUnion">Union</a></b></p>

<p>Ω<sub>1</sub>とΩ<sub>2</sub>をソリューション・マッピングの多重集合とします。次のとおり定義します。</p>

<p>Union(Ω<sub>1</sub>, Ω<sub>2</sub>) = { μ | μ in Ω<sub>1</sub> or μ in Ω<sub>2</sub> }</p>

<p>card[Union(Ω<sub>1</sub>, Ω<sub>2</sub>)](μ) = card[Ω<sub>1</sub>](μ) + card[Ω<sub>2</sub>](μ)</p>

</div>
<div class="defn">

<p><b>定義: <a id="defn_algMinus" name="defn_algMinus">Minus</a></b></p>

<p>Ω<sub>1</sub>とΩ<sub>2</sub>をソリューション・マッピングの多重集合とします。次のとおり定義します。</p>

<p>Minus(Ω<sub>1</sub>, Ω<sub>2</sub>) = { μ | μ in Ω<sub>1</sub> . ∀ μ' in Ω<sub>2</sub>, either μ and μ' are not compatible or dom(μ) and dom(μ') are disjoint }</p>

<p>card[Minus(Ω<sub>1</sub>, Ω<sub>2</sub>)](μ) = card[Ω<sub>1</sub>](μ)</p>

</div>

<p>dom(μ)とdom(μ')には制限が追加されています。なぜならば、そうでない場合、Ω<sub>1</sub>のソリューション・マッピングと同様に変数を持っていないΩ<sub>2</sub>にソリューション・マッピングがあれば、Minus(Ω<sub>1</sub>, Ω<sub>2</sub>)は、残りのΩ<sub>2</sub>にかかわらず、空になるだろうからです。空のソリューション・マッピングは、他のすべてのソリューション・マッピングと互換性があります。したがって、そうでない場合、<code>P MINUS {}</code>は任意のパターン<code>P</code>に対し空でしょう。</p>

<div class="defn">
<b>定義: <a name="defn_extend" id="defn_extend">Extend</a></b>

<p>μをソリューション・マッピングとし、Ωをソリューション・マッピングの多重集合とし、<i>var</i>を変数とし、<i>expr</i>を<a href="#expressions">式</a>とします。次のとおり定義します。</p>

<p>Extend(μ, var, expr) = μ ∪ { (var,value) | var not in dom(μ) and value 
	  = expr(μ) }</p>

<p>Extend(μ, var, expr) = μ if var not in dom(μ) and expr(μ) is an 
	  error</p>

<p>Extend is undefined when var in dom(μ).</p>

<p>Extend(Ω, var, expr) = { Extend(μ, var, expr) | μ in Ω }</p>

</div>

<p>Cがxの条件である場合、要素のシーケンスに対し[ x | C ]と書きます。</p>

<p>Lでのxというカーディナリティーになるように、card[L](x)と書きます。</p>

<div class="defn">
<b>定義: <a id="defn_algToList" name="defn_algToList">ToList</a></b>

<p>Ωをソリューション・マッピングの多重集合とします。次のとおり定義します。</p>

<p>ToList(Ω) = a sequence of mappings μ in Ω in any order, with card[Ω](μ) occurrences of
          μ</p>

<p>card[ToList(Ω)](μ) = card[Ω](μ)</p>

</div>
<div class="defn">
<b>定義: <a id="defn_algOrdered" name="defn_algOrdered">OrderBy</a></b>

<p>Ψをソリューション・マッピングのシーケンスとします。次のとおり定義します。</p>

<p><a id="defn_algOrderBy" name="defn_algOrderBy">OrderBy</a>(Ψ, condition) = [ μ | μ in Ψ and the
          sequence satisfies the ordering condition]</p>

<p>card[OrderBy(Ψ, condition)](μ) =
          card[Ψ](μ)</p>

</div>
<div class="defn">
<b>定義: <a id="defn_algProjection" name="defn_algProjection">Project</a></b>

<p>Ψをソリューション・マッピングのシーケンスとし、PVを変数の集合とします。</p>

<p>マッピングμに対し、PVの変数に対するμの制限になるようにProj(μ, PV)を記述します。</p>

<p>Project(Ψ, PV)  = [ Proj(Ψ[μ], PV) | μ in Ψ ]</p>

<p>card[Project(Ψ, PV)](μ) = card[Ψ](μ)</p>

<p>Project(Ψ, PV)の順序は、OrderByによって与えられた順序付けを保持しなければなりません。</p>

</div>
<div class="defn">
<b>定義: <a id="defn_algDistinct" name="defn_algDistinct">Distinct</a></b>

<p>Ψをソリューション・マッピングのシーケンスとします。次のとおり定義します。</p>

<p>Distinct(Ψ) = [ μ | μ in Ψ ]</p>

<p>card[Distinct(Ψ)](μ) = 1</p>

<p>Distinct(Ψ)の順序は、OrderByによって与えられた順序付けを保持しなければなりません。</p>

</div>
<div class="defn">
<b>定義: <a id="defn_algReduced" name="defn_algReduced">Reduced</a></b>

<p>Ψをソリューション・マッピングのシーケンスとします。次のとおり定義します。</p>

<p>Reduced(Ψ) = [ μ | μ in Ψ ]</p>

<p>card[Reduced(Ψ)](μ) is between 1 and card[Ψ](μ)</p>

<p>Reduced(Ψ)の順序は、OrderByによって与えられた順序付けを保持しなければなりません。</p>

</div>

<p>Reducedソリューション・シーケンス修飾子は、定義済みのカーディナリティーを保証しません。</p>

<div class="defn">
<b>定義: <a id="defn_algSlice" name="defn_algSlice">Slice</a></b>

<p>Ψをソリューション・マッピングのシーケンスとします。次のとおり定義します。</p>

<p><a name="defn_algOrderBy2" id="defn_algOrderBy2">Slice</a>(Ψ, start, length)[i] = Ψ[start+i] for i = 0
          to (length-1)</p>

</div>
<div class="defn">
<b>定義: <a id="defn_algToMultiSet" name="defn_algToMultiSet">ToMultiSet</a></b>

<p>Ψをソリューション・シーケンスとします。次のとおり定義します。</p>

<p>ToMultiSet(Ψ) = { μ | μ in Ψ }</p>

<p>card[ToMultiSet(Ψ)](μ) = card[Ψ](μ)</p>

</div>

<p>ListEvalは、ソリューションに対する式のリストを評価し、結果の値のリストを返すために用いられる関数です。</p>

<div class="defn">

<p><b><a name="defn_algToMultiset" id="defn_algToMultiset">定義: ToMultiset</a></b></p>

<p>ToMultisetは、シーケンスを、シーケンスと同じ要素とカーディナリティーを持つ多重集合に変えます。シーケンスの順序は結果として生成される多重集合には影響がなく、重複は保持されます。</p>

</div>
<div class="defn">

<p><b>定義: <a name="defn_exists" id="defn_exists">Exists</a></b></p>

<p>exists(pattern)は、評価時に現在のソリューション・マッピングとアクティブ・グラフを与えられた場合に、パターンの<a href="#defn_evalExists">評価結果</a>が空でないソリューション・シーケンスになる場合に真（true）を返し、そうでなければ偽（false）を返す関数です。</p>

</div>
<div class="div3">

<h4>
<a name="aggregateAlgebra" id="aggregateAlgebra"></a>18.5.1 集約代数</h4>

<p>グループは、ソリューションの属性に基づいて、1つのソリューション・シーケンスを複数のソリューションにグループ化する関数です。</p>

<div class="defn">

<p><b><a name="defn_algGroup" id="defn_algGroup">定義: Group</a></b></p>

<p>グループは、式のリストをソリューション・シーケンスに対して評価し、ソリューション・シーケンスに対してキーから部分関数の集合を生成します。</p>

<p>Group(exprlist, Ω) = { ListEval(exprlist, μ) → { μ' | μ' in Ω, ListEval(exprlist, μ) = ListEval(exprlist, μ') } | μ in Ω }</p>

</div>
<div class="defn">

<p><b>定義: ListEval</b></p>

<p>ListEval((expr<sub>1</sub>, ..., expr<sub>n</sub>), μ) returns a list (e<sub>1</sub>, ..., e<sub>n</sub>), where e<sub>i</sub> = expr<sub>i</sub>(μ) or error.</p>

<p>ListEvalは、リスト要素の評価の結果として生じるエラーを保持します。</p>

</div>

<p>ListEvalの結果はエラーでありえますが、エラーはグループ化するために使用でき、エラー価値を含んでいるソリューションは射影の際に削除されることに注意してください。</p>

<p>バインドされていない式の評価がエラーであるとき、ListEval((unbound), μ) = (error)。</p>

<p>集約は、集約式の出力としてスカラー値を計算する関数です。これは、SELECT句、HAVING評価プロセス、およびORDER BY（必要な場合）で用いられます。集約は、集合関数を用いて、ソリューションのグループに対する集約された値を計算します。</p>

<div class="defn">

<p><b><a name="defn_algAggregation" id="defn_algAggregation">定義: Aggregation</a></b></p>

<p><i>exprlist</i>を式または*のリストとし、<i>func</i>を集合関数とし、<i>scalarvals</i>をクエリの集約から渡された部分関数の集合（恐らく空）とし、{ key<sub>1</sub>→Ω<sub>1</sub>, ..., key<sub>m</sub>→Ω<sub>m</sub>}を、グループ化のステップによって生成されるキーからソリューション・シーケンスへの部分関数の多重集合とします。</p>

<p>集約は、与えられた多重集合に集合関数funcを適用し、キーおよびそのキーに対するソリューションのパーティションごとに、1つの値を生成します。</p>

<p>Aggregation(exprlist, func, scalarvals, { key<sub>1</sub>→Ω<sub>1</sub>, ..., key<sub>m</sub>→Ω<sub>m</sub> } )<br>
&nbsp;&nbsp;&nbsp;= { (key, F(Ω)) | key → Ω in { key<sub>1</sub>→Ω<sub>1</sub>, ..., key<sub>m</sub>→Ω<sub>m</sub> } }</p>

<p>where<br>
&nbsp;&nbsp;M(Ω) = { ListEval(exprlist, μ) | μ in Ω }<br>
&nbsp;&nbsp;F(Ω) = func(M(Ω), scalarvals), for non-DISTINCT<br>
&nbsp;&nbsp;F(Ω) = func(Distinct(M(Ω)), scalarvals), for DISTINCT</p>

<p><b>特例:</b> <code>COUNT</code>を<code>*</code>という式と共に用いた場合、Fの値は、グループ・ソリューション・シーケンスである、<code>card[Ω]</code>になるか、<code>DISTINCT</code>キーワードが存在する場合には<code>card[Distinct(Ω)]</code>のカーディナリティーになるでしょう。</p>

</div>

<p><i>scalarvals</i>は、基礎となる集合機能に値を渡し、グルーピングの仕組みを迂回するために用いられます。例えば、<code>GROUP_CONCAT(?x ; separator="|")</code>という集約式には、{ "separator" → "|" }というscalarvals引数があります。</p>

<p>すべての集約は、その引数リストの最初のトークンとして<code>DISTINCT</code>キーワードを持つことができます。このキーワードが存在すれば、funcに対する最初の引数はDistinct(M)です。</p>

<p>例</p>

<p>次の値を持つソリューション多重集合(Ω)の場合、</p>

<table>
  <tr>
    <td>ソリューション</td>
    <td>?x</td>
    <td>?y</td>
    <td>?z</td>
  </tr>
  <tr>
    <td>μ<sub>1</sub>
</td>
    <td>1</td>
    <td>2</td>
    <td>3</td>
  </tr>  <tr>
    <td>μ<sub>2</sub>
</td>
    <td>1</td>
    <td>3</td>
    <td>4</td>
  </tr>
  <tr>
    <td>μ<sub>3</sub>
</td>
    <td>2</td>
    <td>5</td>
    <td>6</td>
  </tr>
</table>

<p>そして、クエリ式SELECT (ex:agg(?y, ?z) AS ?agg) WHERE { ?x ?y ?z } GROUP BY ?xです。</p>

<p>G = Group((?x), Ω) = { ( (1), { μ<sub>1</sub>, μ<sub>2</sub> } ), ( (2), { μ<sub>3</sub> } ) }を生成します。</p>

<p>したがって、Aggregation((?y, ?z), ex:agg, {}, G) =<br>
      { ((1), eg:agg({(2, 3), (3, 4)}, {})), ((2), eg:agg({(5, 6)}, {})) }です。</p>

<div class="defn">

<p><b>定義: AggregateJoin</b></p>

<p>S<sub>1</sub>, ..., S<sub>n</sub>を集合のリストとします。その場合、個々の集合であるS<sub>i</sub>は、集約によって生成される際に、値マップに対する（集約された）キーを含んでいます。</p>

<p>Let K = { key | key in dom(S<sub>j</sub>) for some 1 &lt;= j &lt;= n } be the set of keys, then<br>
AggregateJoin(S<sub>1</sub>, ..., S<sub>n</sub>) = { agg<sub>1</sub>→val<sub>1</sub>, ..., agg<sub>n</sub>→val<sub>n</sub> | key in K and key→val<sub>i</sub> in S<sub>i</sub> for each 1 &lt;= i &lt;= n }</p>

</div>

<p>Flattenは、リストの多重集合を1つの多重集合に平坦化する（collapse）ために使用される関数です。したがって、例えば、{ (1, 2), (3, 4) }は、{ 1, 2, 3, 4 }になります。</p>

<div class="defn">

<p><b>定義: Flatten</b></p>

<p>Flatten(M)関数は、M {(L<sub>1</sub>, L<sub>2</sub>, ...), ...}というリストの多重集合を取り、{ x | L in M and x in L }という多重集合を返します。</p>

</div>
<div class="div4">

<h5>
<a name="setFunctions" id="setFunctions"></a>18.5.1.1 集合関数</h5>

<p>SPARQL集約の基礎となる集合関数は、すべて共通する符号を持っています。それは、SetFunc(M)、または、Mがリストの多重集合である場合はSetFunc(M, scalarvals)で、scalarvalsは、SPARQL文法の集約のために( ... ; key=value )構文によって集合関数に間接的に渡される1つ以上のスカラー値です。SPARQLクエリ1.1に組み込み済みの集約によってサポートされているこれを用いる唯一の方法は、<code>GROUP_CONCAT</code>で、<code>GROUP_CONCAT(?x ; separator=", ")</code>のように用います。</p>

<p>「集合関数」という名称が多少歴史的であることに注意してください ― 集合関数に対する引数は、実際に多重集合です。この名称は、SQL集合関数との共通性を持たせるために保持されており、多重集合でも機能します。</p>

<p>このドキュメントで定義している集合関数は、Count、Sum、Min、Max、Avg、GroupConcat、Sampleです ― <code>COUNT</code>、<code>SUM</code>、<code>MIN</code>、<code>MAX</code>、<code>AVG</code>、<code>GROUP_CONCAT</code>、<code>SAMPLE</code>という集約に対応しています。定義は、以下の項にあります。システムは、ローカルの拡張でこの集合を拡張し、同じ記法を関数とキャストに用いることを選択できます。区切り文字である;を用いていない場合には、パーサは、集約が用いられているクエリにエラーがあるか否かかを判断できるようになる前に、あるIRIが関数、キャストまたは集約を参照しているか否かを知る必要があるということに注意してください。</p>

</div>
<div class="div4">

<h5>
<a name="defn_aggCount" id="defn_aggCount"></a>18.5.1.2 Count</h5>

<p>Countは、与えられた式がバインドを持つ数と、集約グループ内の非エラー値を数えるSPARQL集合関数です。</p>

<div class="defn">

<p><b>定義: Count</b></p>xsd:integer   Count(multiset M)<p>N = Flatten(M)</p>

<p>remove error elements from N</p>

<p>Count(M) = card[N]</p>

</div>
</div>
<div class="div4">

<h5>
<a name="defn_aggSum" id="defn_aggSum"></a>18.5.1.3 Sum</h5>

<p>Sumは、集約グループ内の値を合計して得られる値を返すSPARQL集合関数です。op:numeric-add関数により型昇格が生じ、推移的に適用され（下記の定義を参照）、したがって、?xが1 (integer)、2.0e0 (float)、および3.0 (decimal)という値を持っている集約グループ内のSUM(?x)の値は、6.0 (float)になるでしょう。</p>

<div class="defn">

<p><b>定義: Sum</b></p>numeric   Sum(multiset M)

<p>Sum集合関数は、構文内の<code>SUM</code>集約に使われます。</p>

<p>Sum(M) = Sum(ToList(Flatten(M))).</p>

<p>Sum(S) = op:numeric-add(S<sub>1</sub>, Sum(S<sub>2..n</sub>)) when card[S] &gt; 1<br>
    Sum(S) = op:numeric-add(S<sub>1</sub>, 0) when card[S] = 1<br>
    Sum(S) = "0"^^xsd:integer when card[S] = 0</p>

<p>In this way, Sum({1, 2, 3}) = op:numeric-add(1, op:numeric-add(2, op:numeric-add(3, 0))).</p>

</div>
</div>
<div class="div4">

<h5>
<a name="defn_aggAvg" id="defn_aggAvg"></a>18.5.1.4 Avg</h5>

<p><a name="defn_algAvg" id="defn_algAvg"></a>Avg集合関数は、グループの平均値を計算します。それは、SumとCountの用語で定義されます。</p>

<div class="defn">

<p><b>定義: Avg</b></p>numeric   Avg(multiset M)<p>Avg(M) = "0"^^xsd:integer, where Count(M) = 0</p>

<p>Avg(M) = Sum(M) / Count(M), where Count(M) &gt; 0</p>

</div>

<p>例えば、Avg({1, 2, 3}) = Sum({1, 2, 3})/Count({1, 2, 3}) = 6/3 = 2です。</p>

</div>
<div class="div4">

<h5>
<a name="defn_aggMin" id="defn_aggMin"></a>18.5.1.5 Min</h5>

<p>Minは、個々のグループの最小値を返すSPARQL集合関数です。</p>

<p>これは、SPARQL ORDER BYの順序付け定義を利用し、それによって、任意に型付きの式に順序付けが可能になります。</p>

<div class="defn">

<p><b>定義: Min</b></p>term   Min(multiset M)<p>Min(M) = Min(ToList(Flatten(M)))</p>

<p>Min({}) = error.</p>

<p>引数として渡された値の平坦化された多重集合は、シーケンスSに変換され、このシーケンスは、<code>ORDER BY ASC</code>句に基づいて順序付けられます。</p>

<p>Min(S) = S<sub>0</sub></p>

</div>
</div>
<div class="div4">

<h5>
<a name="defn_aggMax" id="defn_aggMax"></a>18.5.1.6 Max</h5>

<p>Maxは、個々のグループの最大値を返すSPARQL集合関数です。</p>

<p>これは、SPARQL ORDER BYの順序付け定義を利用し、それによって、任意に型付きの式に順序付けが可能になります。</p>

<div class="defn">

<p><b>定義: Max</b></p>term   Max(multiset M)<p>Max(M) = Max(ToList(Flatten(M)))</p>

<p>Max({}) = error.</p>

<p>引数として渡された値の多重集合は、シーケンスSに変換され、このシーケンスは、<code>ORDER BY DESC</code>句に基づいて順序付けられます。</p>

<p>Max(S) = S<sub>0</sub></p>

</div>
</div>
<div class="div4">

<h5>
<a name="defn_aggGroupConcat" id="defn_aggGroupConcat"></a>18.5.1.7 GroupConcat</h5>

<p>GroupConcatは、グループの式の値にまたがって文字列の連結を行なう集合関数です。文字列の順序は定められていません。連結で用いられる区切り文字は、スカラー引数のSEPARATORが用いられるかもしれません。</p>

<div class="defn">

<p><b>定義: GroupConcat</b></p>literal   GroupConcat(multiset M)<p>「区切り文字」のスカラー引数がGROUP_CONCATに存在していない場合は、UnicodeのコードポイントU+0020である「空白」文字とみなされます。</p>

<p>値の多重集合である、引数として渡されるMはシーケンスSに変換されます。</p>

<p>GroupConcat(M, scalarvals) = GroupConcat(Flatten(M), scalarvals("separator"))</p>

<p>GroupConcat(S, sep) = "", where <span style="font-size: 140%">|</span>S<span style="font-size: 140%">|</span> = 0</p>

<p>GroupConcat(S, sep) = CONCAT("", S<sub>0</sub>), where <span style="font-size: 140%">|</span>S<span style="font-size: 140%">|</span> = 1</p>

<p>GroupConcat(S, sep) = CONCAT(S<sub>0</sub>, sep, GroupConcat(S<sub>1..n-1</sub>, sep)), where <span style="font-size: 140%">|</span>S<span style="font-size: 140%">|</span> &gt; 1</p>

</div>

<p>例えば、GroupConcat({"a", "b", "c"}, {"separator" → "."}) = "a.b.c"です。</p>

</div>
<div class="div4">

<h5>
<a name="defn_aggSample" id="defn_aggSample"></a>18.5.1.8 Sample</h5>

<p>Sampleは、渡された多重集合から任意の値を返す集合関数です。</p>

<div class="defn">

<p><b>定義: Sample</b></p>RDFTerm   Sample(multiset M)<p>Sample(M) = v, where v in Flatten(M)</p>

<p>Sample({}) = error</p>

</div>

<p>例えば、Sample({"a", "b", "c"})の場合、「a」、「b」と「c」はすべて有効な返り値です。与えられた入力に対してSample()が確定的である必要はないことに注意してください。唯一の制限は、入力多重集合に出力値が存在していなければならないということです。</p>

</div>
</div>
</div>
<div class="div2">

<h3>
<a name="sparqlAlgebraEval" id="sparqlAlgebraEval"></a>18.6 評価セマンティクス</h3>

<p>我々は、eval(D(G), algebra expression)を、アクティブ・グラフGを持つデータセットDに関する代数式の評価であると定義しています。アクティブ・グラフは、最初はデフォルト・グラフです。</p>

<pre class="box">D : データセット
D(G) : アクティブ・グラフGを持つデータセットD（パターンがマッチするもの）
D[i] : データセットDにIRI iを持つグラフ
P, P1, P2 : グラフ・パターン
L : ソリューション・シーケンス
F : 式</pre>
<div class="defn">
<b>定義: <a id="defn_evalBasicGraphPattern" name="defn_evalBasicGraphPattern">基本グラフ・パターンの評価</a></b>

<pre class="code">eval(D(G), BGP) = multiset of solution mappings</pre>

<p><a href="#BasicGraphPattern">基本グラフ・パターン</a>の項を参照してください。</p>

</div>
<div class="defn">
<b>定義: <a id="defn_evalPropertyPathPattern" name="defn_evalPropertyPathPattern">プロパティー・パス・パターンの評価</a></b>

<pre class="code">eval(D(G), Path(X, path, Y)) = multiset of solution mappings</pre>

<p><a href="#defn_PropertyPathExpr">プロパティー・パス式</a>の項を参照してください。</p>

</div>
<div class="defn">
<b>定義: <a id="defn_evalFilter" name="defn_evalFilter">Filterの評価</a></b>

<pre class="code">eval(D(G), Filter(F, P)) = Filter(F, eval(D(G),P), D(G))</pre>
</div>

<p>「substitute」は、<code>exists</code>に置換された<a href="#func-filter-exists"><code>EXISTS</code>と<code>NOT EXISTS</code></a>の形式の評価をサポートするフィルタ関数です。</p>

<div class="defn">

<p><b>定義: <a name="defn_substitute" id="defn_substitute">Substitute</a></b></p>

<p>μをソリューション・マッピングとします。</p>

<blockquote>
	    <p>substitute(<i>pattern</i>, μ) = the pattern formed by replacing every 
	    occurrence of a variable v in <i>pattern</i> by μ(v) for each v in dom(μ)</p>
	  </blockquote>
</div>
<div class="defn">

<p><b>定義: <a name="defn_evalExists" id="defn_evalExists">Existsの評価</a></b></p>

<p>μをフィルタとグラフ・パターンPに対する現在のソリューション・マッピングとします。</p>

<blockquote>
	    The value exists(P), given D(G) is true if and only if eval(D(G), substitute(P, μ)) is a non-empty sequence.
	  </blockquote>
</div>
<div class="defn">
<b>定義: <a id="defn_evalJoin" name="defn_evalJoin">Joinの評価</a></b>

<pre class="code">eval(D(G), Join(P1, P2)) = Join(eval(D(G), P1), eval(D(G), P2))</pre>
</div>
<div class="defn">
<b>定義: <a id="defn_evalLeftJoin" name="defn_evalLeftJoin">LeftJoinの評価</a></b>

<pre class="code">eval(D(G), LeftJoin(P1, P2, F)) = LeftJoin(eval(D(G), P1), eval(D(G), P2), F)</pre>
</div>
<div class="defn">
<b>定義: <a id="defn_evalUnion" name="defn_evalUnion">Unionの評価</a></b>

<pre class="code">eval(D(G), Union(P1,P2)) = Union(eval(D(G), P1), eval(D(G), P2))</pre>
</div>
<div class="defn">
<b>定義: <a id="defn_evalGraph" name="defn_evalGraph">Graphの評価</a></b>

<pre class="code">if IRI is a graph name in D
eval(D(G), Graph(IRI,P)) = eval(D(D[IRI]), P)</pre>

<pre class="code">if IRI is not a graph name in D
eval(D(G), Graph(IRI,P)) = the empty multiset</pre>

<pre class="code">eval(D(G), Graph(var,P)) =
     Let R be the empty multiset
     foreach IRI i in D
        R := Union(R, Join( eval(D(D[i]), P) , Ω(?var-&gt;i) )
     the result is R</pre>
</div>

<p>グラフの評価は、SPARQL代数和集合演算子を使用します。ソリューション・マッピングのカーディナリティーは、それぞれのjoinの操作における、そのソリューション・マッピングのカーディナリティーの合計です。</p>

<div class="defn">
<p><b><a name="defn_evalGroup" id="defn_evalGroup">定義: Groupの評価</a></b></p>

<p>eval(D(G), Group(exprlist, P)) = Group(exprlist, eval(D(G), P))</p>

</div>
<div class="defn">

<p><b><a name="defn_evalAggregation" id="defn_evalAggregation">定義: Aggregationの評価</a></b></p>

<p>eval(D(G), Aggregation(exprlist, func, scalarvals, P)) = Aggregation(exprlist, func, scalarvals, eval(D(G), P))</p>

</div>
<div class="defn">

<p><b><a name="defn_evalAggregateJoin" id="defn_evalAggregateJoin">定義: AggregateJoinの評価</a></b></p>

<p>eval(D(G), AggregateJoin(A<sub>1</sub>, ..., A<sub>n</sub>)) = AggregateJoin(eval(D(G), A<sub>1</sub>), ..., eval(D(G), A<sub>n</sub>))</p>

</div>

<p>eval(D(G), A<sub>i</sub>)がエラーであれば、無視されることに注意してください。</p>

<div class="defn">
<b>定義: <a id="defn_evalExtend" name="defn_evalExtend">Extendの評価</a></b>

<pre class="code">eval(D(G), Extend(P, var, expr)) = Extend(eval(D(G), P), var, expr)</pre>
</div>
<div class="defn">
<b>定義: <a id="defn_evalList" name="defn_evalList">ToListの評価</a></b>

<pre class="code">eval(D(G), ToList(P)) = ToList(eval(D(G), P))</pre>
</div>
<div class="defn">
<b>定義: <a id="defn_evalDistinct" name="defn_evalDistinct">Distinctの評価</a></b>
<pre class="code">eval(D(G), Distinct(L)) = Distinct(eval(D(G), L))</pre>
</div>
<div class="defn">
<b>定義: <a id="defn_evalReduced" name="defn_evalReduced">Reducedの評価</a></b>

<pre class="code">eval(D(G), Reduced(L)) = Reduced(eval(D(G), L))</pre>
</div>
<div class="defn">
<b>定義: <a id="defn_evalProject" name="defn_evalProject">Projectの評価</a></b>

<pre class="code">eval(D(G), Project(L, vars)) = Project(eval(D(G), L), vars)</pre>
</div>
<div class="defn">
<b>定義: <a id="defn_evalOrderBy" name="defn_evalOrderBy">OrderByの評価</a></b>

<pre class="code">eval(D(G), OrderBy(L, condition)) = OrderBy(eval(D(G), L), condition)</pre>
</div>
<div class="defn">
<b>定義: <a id="defn_evalToMultiSet" name="defn_evalToMultiSet">ToMultiSetの評価</a></b>

<pre class="code">eval(D(G), ToMultiSet(L)) = ToMultiSet(eval(D), M))</pre>
</div>
<div class="defn">
<b>定義: <a id="defn_evalSlice" name="defn_evalSlice">Sliceの評価</a></b>

<pre class="code">eval(D(G), Slice(L, start, length)) = Slice(eval(D(G), L), start, length)</pre>
</div>
</div>
<div class="div2">

<h3>
<a name="sparqlBGPExtend" id="sparqlBGPExtend"></a>18.7 SPARQL基本グラフ・マッチングの拡張</h3>

<p>SPARQLの全体的な設計は、基本グラフ・パターンにマッチングした条件を書き直すことによって、シンプルな含意ではなく、より精緻な形式の含意を想定したクエリに使用できます。1つの一般的な形式でそのような条件を記述し、それをすべての形式の含意に適用して不必要または不適切な重複を最適に排除することは、未解決の研究課題であるため、このドキュメントは、そのようなソリューションが満たすべき必要条件を提示するのみです。これらは、それぞれの具体的な事例に対する完全な定義に拡張する必要があるでしょう。</p>

<p>基本グラフ・パターンは、RDFグラフがRDFトリプルに対して行うトリプルのパターンと同じ関係にあり、同じ用語の多くをそれらに適用できます。特に、トリプル（M(s), M(p), M(o)）が2番目のパターンにある場合に限りトリプル（s, p, o）が最初のパターンに存在するような、空白ノードを空白ノードにマッピングし、変数、リテラル、およびIRIをそれら自身にマッピングするトリプル・パターンの用語間に全単射Mがある場合、2つの基本グラフ・パターンはが<i>同等</i>であると述べられます。この定義は、変数名を同等なパターン全体で保持することによって、RDFグラフの同等性に対し、それを基本グラフ・パターンに拡張します。</p>

<p><i>含意レジーム</i>（entailment regime）は、次の仕様を定めます。</p>

<ol>
  <li>レジームに対する<i>整形式</i>と呼ばれるRDFグラフのサブセット</li>
  <li>整形式のグラフと整形式のグラフのサブセットの間の<i>含意</i>関係</li>
</ol>

<p>様々な含意レジームのクエリに関する詳細な定義は、<a href="www.w3.org/TR/sparql11-entailment/">SPARQL 1.1含意レジーム</a>にあります。</p>

<p>いくつかの含意レジームは、いくつかのRDFグラフを、矛盾すると分類することができます。例えば、次のRDFグラフは、</p>

<pre class="data">_:x rdf:type xsd:string .
_:x rdf:type xsd:decimal .</pre>

<p>DがXSDデータ型を含んでいる場合、D矛盾です。矛盾したグラフへのクエリの効果は、この仕様ではカバーしていませんが、特定のSPARQLの拡張で指定しなければなりません。</p>

<p>結果として生じるソリューションの多重集合が、RDFグラフ同等の違は無視して、一意に決定されるような、条件を満たす任意の基本グラフ・パターンBGP、任意のRDFグラフG、および任意の評価に対し、含意レジームEは、基本グラフ・パターン評価の条件を提供しなければなりません。EをEval-E(G, BGP)とともに用いたGに対するBGPの評価に基づくソリューションの多重集合を示します。<br>
含意レジームは、さらに次の条件を満たさなければなりません。</p>

<ol>
  <li>任意のe整合のアクティブ・グラフAGの場合、含意レジームEは、AGとe等価な<a href="#BGPsparqlBNodes">スコーピング・グラフ</a>SGを一意に指定します。</li>

  <li>Eの整形式のグラフの集合は、Eval-E(SG、BGP)の、任意の基本グラフ・パターンBGP、スコーピング・グラフSG、およびソリューション・マッピングμに対し、グラフμ(BGP)がEの整形式であるように指定されます。</li>
  <li>任意の基本グラフ・パターンBGPとスコーピング・グラフSGの場合、Eval-E(SG, BGP)のμ<sub>1</sub>, ..., μ<sub>n</sub>とBGP<sub>1</sub>, ..., BGP<sub>n</sub>は、すべてBGPと同等である基本グラフ・パターンであるけれども、互いに、または、SGと空白ノードを共有していなければ、次のとおりです。
          <blockquote>
            <p>SG E-entails (SG union μ<sub>1</sub>(BGP<sub>1</sub>) union ... 
            union μ<sub>n</sub>(BGP<sub>n</sub>))</p>
          </blockquote>

<p>RDFがいくらでも重複を許すため、これらの条件は、ありえる答えの集合を完全に決定するわけではありません。さらに、したがって、下記が当てはまらなければなりません。</p>

</li>
  <li>含意レジームは、レジームに応じて、自明な無限のソリューション多重集合を適切に防止する条件を提供すべきです。</li>
</ol>
<div class="div3">

<h4>
<a name="sparqlBGPExtend-notes" id="sparqlBGPExtend-notes"></a>18.7.1 注意</h4>

<p>(a) SGは、しばしばAGと同等のグラフになるでしょうが、これをE-同等（E-equivalence）に制限すると、例えばセマンティックな重複の排除などのいくつかの形式の正規化をクエリの実行前にソース・ドキュメントに適用することが可能になります。</p>

<p>(b) 条件3の構築は、空白ノードがSGで出現する方法と内部的に整合性があるような方法で、ソリューション・マッピングによって導入された任意の空白ノードが確実に用いられるようになります。これにより、答えの集合の中の1つ以上の答えで、そのように識別された空白ノードが本当にSGにおいて同じであるときにのみ、空白ノード識別子が確実に生じます。拡張が空白ノードへのバインディングを許さない場合、この条件は以下の条件に簡略化できます。</p>

<blockquote>
<p>SG E-entails μ(BGP) for each solution mapping μ.</p>
</blockquote>

<p>(c) これらの条件は、SGがAGまたはBGPと空白ノードを共有しないという要件をSPARQLに課しません。特に、これによって、SGが実際にAGになることが可能になります。これにより、空白ノード識別子がクエリとソース・ドキュメントの間や複数のクエリにまたがって意味を保有するクエリ・プロトコルが可能になります。しかし、そのようなプロトコルは、現在のSPARQLプロトコル仕様ではサポートされていません。</p>

<p>(d) 条件1～3のみが答えにおける必要条件であるため、条件4では、正当な答えの集合を様々な方法で制限しうるケースが許されます。</p>

<p>(e) これらの条件は、BGPの空白ノードにおけるインスタンス・マッピングを明示的に参照しません。いくつかの含意レジームに関しては、1つのインスタンス・マッピングの存在によって、空白ノードの存在を表す解釈を完全に得ることができるわけではありません。これらの条件は、このようなレジームがクエリ・パターンの空白ノードに「完全に存在する」読込みを与えることを許します。</p>

<p>SGにおけるSPARQL条件が、AGにグラフ同等（graph-equivalent）であるけれども、AGやBGPと空白ノードを共有しないという（最初の条件を満たす）ものである場合、Eがシンプルな含意であるケースのこれらの条件をSPARQLが満たすということを示すと分かりやすいです。唯一の重要な条件は(3)です。</p>

<p>すべてのソリューション・マッピングμ<sub>i</sub>に対し、基本グラフ・パターンマッチングの定義により、P<sub>i</sub>がμ<sub>i</sub>とσ<sub>i</sub>からなるパターン・インスタンス・マッピングである場合に、P<sub>i</sub>(BGP<sub>i</sub>)がSGのサブグラフであるようなRDFインスタンス・マッピングσ<sub>i</sub>があります。BGP<sub>i</sub>とSGが共通の空白ノードを持たないため、σ<sub>i</sub>とμ<sub>i</sub>の範囲にはBGP<sub>i</sub>の空白ノードは含まれません。したがって、ソリューション・マッピングμ<sub>i</sub>とP<sub>i</sub>のRDFインスタンス・マッピングσ<sub>i</sub>は交換され、したがって、P<sub>i</sub>(BGP<sub>i</sub>) = σ<sub>i</sub>(μ<sub>i</sub>(BGP<sub>i</sub>))です。したがって、次のとおりです。</p>

<p>P<sub>1</sub>(BGP<sub>1</sub>) union ... union P<sub>n</sub>(BGP<sub>n</sub>)
          <br>= σ<sub>1</sub>(μ<sub>1</sub>(BGP<sub>1</sub>)) union ... union 
          σ<sub>n</sub>(μ<sub>n</sub>(BGP<sub>n</sub>))
          <br>= [ σ<sub>1</sub> + ... + σ<sub>n</sub>]( 
          μ<sub>1</sub>(BGP<sub>1</sub>) union ... union 
          μ<sub>n</sub>(BGP<sub>n</sub>) )</p>

<p>これは、σ<sub>i</sub> RDFインスタンス・マッピングの定義域がすべて互いに排他的であるためです。これらがSGから排他的であるためでもあります。</p>

<p>SG union [ σ<sub>1</sub> + ... + σ<sub>n</sub>]( 
          μ<sub>1</sub>(BGP<sub>1</sub>) union ... union μ<sub>n</sub>(BGP<sub>n</sub>) )
          <br>= [ σ<sub>1</sub> + ... + σ<sub>n</sub>](SG union 
          μ<sub>1</sub>(BGP<sub>1</sub>) union ... union μ<sub>n</sub>(BGP<sub>n</sub>) )</p>

<p>すなわち、</p>

<p>SG union μ<sub>1</sub>(BGP<sub>1</sub>) union ... union 
          μ<sub>n</sub>(BGP<sub>n</sub>)</p>

<p>は、SGのサブグラフであるインスタンスを持っており、そのため、<a href="www.w3.org/TR/rdf-mt/#interplemmaprf">RDF補間定理</a>[<a href="#RDF-MT">RDF-MT</a>]によるSGによって簡単に含意されます。</p>

</div>
</div>
</div>
<div class="div1">

<h2>
<a name="grammar" id="grammar"></a>19 SPARQL文法</h2>

<p>SPARQL文法はSPARQLクエリと<a href="www.w3.org/TR/sparql11-update/">SPARQL更新</a>の両方をカバーします。</p>

<div class="div2">

<h3>
<a name="queryString" id="queryString"></a>19.1 SPARQLリクエスト文字列</h3>

<p><a name="defn_SPARQLRequestString" id="defn_SPARQLRequestString">SPARQLリクエスト文字列</a>は、SPARQLクエリ文字列あるいはSPARQL更新文字列で、次の文法によって定義された言語のUnicode文字列（6.1項[<a href="#CHARMOD">CHARMOD</a>]文字列の概念を参照）です。</p>

<p><a href="#rQueryUnit">QueryUnit</a>生成規則での<a name="defn_SPARQLQueryString" id="defn_SPARQLQueryString">SPARQLクエリ文字列</a>の開始</p>

<p><a href="#rUpdateUnit">UpdateUnit</a>生成規則での<a name="defn_SPARQLUpdateString" id="defn_SPARQLUpdateString">SPARQL更新文字列</a>の開始</p>

<p>Unicodeの将来のバージョンとの互換性のため、この文字列中の文字には、この文書の発表時点には割り当てられていないUnicodeコード・ポイントが含まれているかもしれません（<a class="inform" href="www.unicode.org/reports/tr31/tr31-5.html">識別子とパターン構文</a>[<a href="#UNIID">UNIID</a>]の4項 パターン構文を参照）。除外されている文字クラス（例えば、<code>[^&lt;&gt;'{}|^`]</code>）を持つ生成規則の場合、文字は<code>#x0 - #x10FFFF</code>の範囲から除外されています。</p>

</div>
<div class="div2">

<h3>
<a name="codepointEscape" id="codepointEscape"></a>19.2 コードポイント・エスケープ・シーケンス</h3>

<p>SPARQLクエリ文字列は、以下のEBNFで定義された文法によって分析する前に、コードポイント・エスケープ・シーケンス用に処理されます。SPARQLクエリ文字列用のコードポイント・エスケープ・シーケンスは、以下の通りです。</p>

<a name="table68" id="table68"></a>

<table summary="Codepoint escapes">
<colgroup span="1"><col width="40%" span="1"></colgroup>
  <tr>
    <th class="major">エスケープ</th>
    <th class="major">Unicodeコードポイント</th>
  </tr>
  <tr>
    <td>
<span class="token">'\u'</span> <a href="#HEX">HEX</a>
    <a href="#HEX">HEX</a> <a href="#HEX">HEX</a> <a href="#HEX">HEX</a>
</td>
    <td>コード化された16進の値に対応する包括的な範囲U+0～U+FFFFのUnicodeコード・ポイント。</td>
  </tr>
  <tr>
    <td>
<span class="token">'\U'</span> <a href="#HEX">HEX</a>
    <a href="#HEX">HEX</a> <a href="#HEX">HEX</a> <a href="#HEX">HEX</a>
    <a href="#HEX">HEX</a> <a href="#HEX">HEX</a> <a href="#HEX">HEX</a>
    <a href="#HEX">HEX</a>
</td>
    <td>コード化された16進の値に対応する包括的な範囲U+0～U+10FFFFのUnicodeコード・ポイント。</td>
  </tr>
</table>

<p>ここでは、<a href="#HEX">HEX</a>は16進の文字です。</p>

<blockquote>
  <p><code><a name="HEX" id="HEX">HEX</a> ::= [0-9] | [A-F] | [a-f]</code></p>
</blockquote>

<p>例:</p>

<pre class="query untested">&lt;abéxy&gt;        # Codepoint 00E9 is Latin small e with acute - e
α:a            # Codepoint x03B1 is Greek small alpha - α
a:b            # a:b -- codepoint x3A is colon</pre>

<p>コードポイント・エスケープ・シーケンスは、クエリ文字列のどこにでも出現できます。これらは、文法規則に基づいた分析の前に処理され、したがって、接頭辞付き名前をマーク付けする「<code>:</code>」のような、文法中で重要性を持つコードポイントに置き換えられることがあります。</p>

<p>これらのエスケープ・シーケンスは、以下の文法に含まれていません。その時点で文法上正当な文字列のエスケープ・シーケンスのみが示されるかもしれません。例えば、変数「<code>?x y</code>」は、正当ではありません（<code> </code>はスペースであり、変数名では許されていない）。</p>

</div>
<div class="div2">

<h3>
<a name="whitespace" id="whitespace"></a>19.3 空白</h3>

<p>空白（生成規則<code><a href="#rWS">WS</a></code>）は2つの終端記号を区切るために用いられ、そうでなければ、1つの終端記号として（誤）認識されます。下記の大文字の規則名は、空白が重要である場合を示します。これらは、SPARQLパーサを構築するための可能な端末の選択を形成します。文字列において空白は重要です。そうでない場合には、トークンの間では空白は無視されます。</p>

<p>例えば、</p>

<blockquote>
<p><code>?a&lt;?b&amp;&amp;?c&gt;?d</code></p>
</blockquote>

<p>は、トークン・シーケンスの変数「<code>?a</code>」、IRI「<code>&lt;?b&amp;&amp;?c&gt;</code>」、変数「<code>?d</code>」であり、「<code>&lt;</code>」（小なり）および「<code>&gt;</code>」（大なり）を用いた2つの式を結合した演算子「<code>&amp;&amp;</code>」を含んだ式ではありません。</p>

</div>
<div class="div2">

<h3>
<a name="grammarComments" id="grammarComments"></a>19.4 コメント</h3>

<p>SPARQLクエリにおけるコメントは、IRI中または文字列中以外では、「<code>#</code>」の形式を取り、これは、行末（文字列<code>0x0D</code>または<code>0x0A</code>でマーク付けされる）まで続くか、コメント・マーカーの後に行末がなければファイルの終りまで続きます。コメントは空白として扱われます。</p>

</div>
<div class="div2">

<h3>
<a name="iriRefs" id="iriRefs"></a>19.5 IRI参照</h3>

<p><code><a href="#rIRIREF">IRIREF</a></code>生成規則および<code><a href="#rPrefixedName">PrefixedName</a></code>（接頭辞拡張の後の）生成規則でマッチングされたテキストは、エスケープ処理の後に、RFC 3987 [<a href="#rfc3987">RFC3987</a>]の2.2項「IRI参照およびIRIのためのABNF」のIRI参照の一般的な構文に適合していなければなりません。例えば、<code><a href="#rIRIREF">IRIREF</a></code> <code>&lt;abc#def&gt;</code>は、SPARQLクエリ文字列で出現可能ですが、<code><a href="#rIRIREF">IRIREF</a></code> <code>&lt;abc##def&gt;</code>は出現できません。</p>

<p>キーワード<span class="token">BASE</span>で宣言された基底IRIは、絶対IRIでなければなりません。キーワード<span class="token">PREFIX</span>で宣言された接頭辞は、同じクエリ中で再宣言できません。<span class="token">BASE</span>と<span class="token">PREFIX</span>の記述に関しては、4.1.1項、<a href="#QSynIRI">IRI用語の構文</a>を参照してください。</p>

</div>
<div class="div2">
<h3>
<a name="grammarBNodes" id="grammarBNodes"></a>19.6 空白ノードと空白ノード・ラベル</h3>

<p>空白ノードは、次の中では使用できません。</p>

<p><a href="www.w3.org/TR/sparql11-update/#terminology">SPARQL更新リクエスト</a>内の</p>

<ul>
<li><code><a href="#rDeleteWhere">DELETE WHERE</a></code></li>
  <li><code><a href="#rDeleteWhere">DELETE DATA</a></code></li>
  <li>a <code><a href="#rDeleteClause">DeleteClause</a></code>
</li>
</ul>

<p>空白ノード・ラベルのスコープは、それが発生する<a href="#defn_SPARQLRequestString">SPARQLリクエスト文字列</a>です。リクエスト文字列中の同じ空白ノード・ラベルを様々に用いても、同じブランクのノードを指します。リクエストごとに新しい空白ノードが生成されます。空白ノードは、リクエストにまたがるラベルによって参照することはできません。</p>

<p>同じ空白ノード・ラベルは、次の中では使用できません。</p>

<ul>
  <li>1つのSPARQLクエリ内の2つの基本グラフ・パターン</li>
  <li>1つのSPARQL更新リクエスト内の2つの<code><a href="#rModify">WHERE</a></code>句</li>
  <li>1つのSPARQL更新リクエスト内の2つの<code><a href="#rInsertData">INSERT DATA</a></code>操作</li>
</ul>

<p><a href="www.w3.org/TR/sparql11-update/">SPARQL更新</a>リクエスト内の異なる<a href="#rQuadPattern">QuadPattern</a>句に同じ空白ノード・ラベルが生じる可能性があることに注意してください。</p>

</div>
<div class="div2">

<h3>
<a name="grammarEscapes" id="grammarEscapes"></a>19.7 文字列中のエスケープ・シーケンス</h3>

<p><a href="#codepointEscape">コードポイント・エスケープ・シーケンス</a>に加え、下記は、任意の<code><a href="#rString">string</a></code>生成規則（例えば、<code><a href="#rSTRING_LITERAL1">STRING_LITERAL1</a></code>、<code><a href="#rSTRING_LITERAL2">STRING_LITERAL2</a></code>、<code><a href="#rSTRING_LITERAL_LONG1">STRING_LITERAL_LONG1</a></code>、<code><a href="#rSTRING_LITERAL_LONG2">STRING_LITERAL_LONG2</a></code>）のエスケープ・シーケンスを行います。</p>

<table summary="String escapes">
<colgroup span="1"><col width="40%" span="1"></colgroup>
  <tr>
    <th class="major">エスケープ</th>
    <th class="major">Unicodeコードポイント</th>
  </tr>
  <tr>
    <td><span class="token">'\t'</span></td>
    <td>U+0009（タブ）</td>
  </tr>
  <tr>
    <td><span class="token">'\n'</span></td>
    <td>U+000A（改行）</td>
  </tr>
  <tr>
    <td><span class="token">'\r'</span></td>
    <td>U+000D（復帰）</td>
  </tr>
  <tr>
    <td><span class="token">'\b'</span></td>
    <td>U+0008（バックスペース）</td>
  </tr>
  <tr>
    <td><span class="token">'\f'</span></td>
    <td>U+000C（改ページ）</td>
  </tr>
  <tr>
    <td><span class="token">'\"'</span></td>
    <td>U+0022（引用符、二重引用符）</td>
  </tr>
  <tr>
    <td><span class="token">"\'"</span></td>
    <td>U+0027（アポストロフィ、一重引用符）</td>
  </tr>
  <tr>
    <td><span class="token">'\\'</span></td>
    <td>U+005C（逆斜線）</td>
  </tr>
</table>


<p>例:</p>

<pre class="query untested">"abc\n"
"xy\rz"
'xy\tz'</pre>
</div>
<div class="div2">

<h3>
<a name="sparqlGrammar" id="sparqlGrammar"></a>19.8 文法</h3>

<p>文法で用いられるEBNF表記法は、XML（Extensible Markup Language）1.1[<a href="#XML11">XML11</a>]の6項の<a class="norm" href="www.w3.org/TR/2004/REC-xml11-20040204/#sec-notation">表記法</a>で定義されています。</p>

<p>注意:</p>

<ol>
  <li>キーワードは、TurtleとN3に沿ってIRI <code>rdf:type</code>の代わりに用いられるキーワード「<code>a</code>」を除き、大文字・小文字を区別しない方法でマッチします（完全形では、<code><a href="www.w3.org/1999/02/22-rdf-syntax-ns#type">http://www.w3.org/1999/02/22-rdf-syntax-ns#type</a></code>）。</li>
  <li>エスケープ・シーケンスは、大文字・小文字を区別します。</li>
  <li>入力をトークン化し、文法規則を選ぶ時には、最も長いマッチが選ばれます。</li>
  <li>大文字化された名前を持つ規則が終端記号として用いられるとき、SPARQL文法はLL(1)です。</li>
  <li>文法へのエントリー・ポイントは、SPARQLクエリ用の<code>QueryUnit</code>と、SPARQL更新リクエスト用のUpdateUnitの2つあります。</li>
  <li>符号付きの数字では、符号と数字の間には空白は許されません。<code><a href="#rAdditiveExpression">AdditiveExpression</a></code>文法規則は、符号付きの数字が後続する式の2つのケースをカバーすることで、これを可能にします。これらにより、必要に応じて、符号のない数の加算または減算が生じます。</li>
  <li>
<code>INSERT DATA</code>、<code>DELETE DATA</code>、<code>DELETE WHERE</code>というトークンでは、空白はその単語間にいくつでも認められています。シングル･スペースのバージョンは、明瞭さのために文法で用いられます。</li>
  <li>
<code><a href="#rQuadData">QuadData</a></code>と<code><a href="#rQuadPattern">QuadPattern</a></code>の両方の規則は、<code><a href="#rQuads">Quads</a></code>の規則を用います。<a href="#rInsertData"><code>INSERT DATA</code></a>および<a href="#rDeleteData"><code>DELETE DATA</code></a>で用いられる<code><a href="#rQuadData">QuadData</a></code>という規則は、クアッド・パターンにおいて変数を認めてはなりません。</li>
  <li>空白ノード構文は、<code><a href="#rDeleteWhere">DELETE WHERE</a></code>（<code>DELETE</code>用の<code><a href="#rDeleteClause">DeleteClause</a></code>）でも、<a href="#rDeleteData"><code>DELETE DATA</code></a>でも認められていません。</li>
  <li>空白ノード・ラベルの使用を制限するための規則は、<a href="#grammarBNodes">19.6項</a>で示します。</li>
  <li>
<code>VALUES</code>ブロックの変数リスト内の変数の数は、<code>DataBlock</code>の関連する値の各リストの数と同じでなければなりません。</li>
  <li>
<code>SELECT</code>句で<code>AS</code>によって導入された変数は、既に<a href="#variableScope">範囲内</a>にあってはなりません。</li>
  <li>
<code>BIND</code>句で割り当てられている変数は、<code><a href="#rGroupGraphPattern">GroupGraphPattern</a></code>内の直前の<code><a href="#rTriplesBlock">TriplesBlock</a></code>内で既に使用されていてはなりません。</li>
  <li>集約関数は、<a href="#rAggregate">集約用の組み込みキーワード</a>またはカスタムの集約のうちのいずれかでありえ、これは構文的に<a href="#rFunctionCall">関数呼び出し</a>です。集約関数は、<a href="#rSelectClause">SELECT</a>、<a href="#rHavingClause">HAVING</a>と<a href="#rOrderClause">ORDER BY</a>句でのみ使用できます。</li>
  <li>カスタムの集約関数のみが<a href="#rFunctionCall">関数呼び出し</a>において<tt>DISTINCT</tt>キーワードを用います。</li>
  </ol>
<div class="grammarTable">

<table>
<tbody>
  <tr valign="baseline">
    <td><code>[1]&nbsp;&nbsp;</code></td>
    <td><code><a id="rQueryUnit" name="rQueryUnit">QueryUnit</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rQuery">Query</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[2]&nbsp;&nbsp;</code></td>
    <td><code><a id="rQuery" name="rQuery">Query</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rPrologue">Prologue</a><br>( <a href="#rSelectQuery">SelectQuery</a> | <a href="#rConstructQuery">ConstructQuery</a> | <a href="#rDescribeQuery">DescribeQuery</a> | <a href="#rAskQuery">AskQuery</a> )<br><a href="#rValuesClause">ValuesClause</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[3]&nbsp;&nbsp;</code></td>
    <td><code><a id="rUpdateUnit" name="rUpdateUnit">UpdateUnit</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rUpdate">Update</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[4]&nbsp;&nbsp;</code></td>
    <td><code><a id="rPrologue" name="rPrologue">Prologue</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code>( <a href="#rBaseDecl">BaseDecl</a> | <a href="#rPrefixDecl">PrefixDecl</a> )*</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[5]&nbsp;&nbsp;</code></td>
    <td><code><a id="rBaseDecl" name="rBaseDecl">BaseDecl</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'BASE'</span> <a href="#rIRIREF">IRIREF</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[6]&nbsp;&nbsp;</code></td>
    <td><code><a id="rPrefixDecl" name="rPrefixDecl">PrefixDecl</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'PREFIX'</span> <a href="#rPNAME_NS">PNAME_NS</a> <a href="#rIRIREF">IRIREF</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[7]&nbsp;&nbsp;</code></td>
    <td><code><a id="rSelectQuery" name="rSelectQuery">SelectQuery</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rSelectClause">SelectClause</a> <a href="#rDatasetClause">DatasetClause</a>* <a href="#rWhereClause">WhereClause</a> <a href="#rSolutionModifier">SolutionModifier</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[8]&nbsp;&nbsp;</code></td>
    <td><code><a id="rSubSelect" name="rSubSelect">SubSelect</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rSelectClause">SelectClause</a> <a href="#rWhereClause">WhereClause</a> <a href="#rSolutionModifier">SolutionModifier</a> <a href="#rValuesClause">ValuesClause</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[9]&nbsp;&nbsp;</code></td>
    <td><code><a id="rSelectClause" name="rSelectClause">SelectClause</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'SELECT'</span> ( <span class="token">'DISTINCT'</span> | <span class="token">'REDUCED'</span> )? ( ( <a href="#rVar">Var</a> | ( <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">'AS'</span> <a href="#rVar">Var</a> <span class="token">')'</span> ) )+ | <span class="token">'*'</span> )</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[10]&nbsp;&nbsp;</code></td>
    <td><code><a id="rConstructQuery" name="rConstructQuery">ConstructQuery</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'CONSTRUCT'</span> ( <a href="#rConstructTemplate">ConstructTemplate</a> <a href="#rDatasetClause">DatasetClause</a>* <a href="#rWhereClause">WhereClause</a> <a href="#rSolutionModifier">SolutionModifier</a> | <a href="#rDatasetClause">DatasetClause</a>* <span class="token">'WHERE'</span> <span class="token">'{'</span> <a href="#rTriplesTemplate">TriplesTemplate</a>? <span class="token">'}'</span> <a href="#rSolutionModifier">SolutionModifier</a> )</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[11]&nbsp;&nbsp;</code></td>
    <td><code><a id="rDescribeQuery" name="rDescribeQuery">DescribeQuery</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'DESCRIBE'</span> ( <a href="#rVarOrIri">VarOrIri</a>+ | <span class="token">'*'</span> ) <a href="#rDatasetClause">DatasetClause</a>* <a href="#rWhereClause">WhereClause</a>? <a href="#rSolutionModifier">SolutionModifier</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[12]&nbsp;&nbsp;</code></td>
    <td><code><a id="rAskQuery" name="rAskQuery">AskQuery</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'ASK'</span> <a href="#rDatasetClause">DatasetClause</a>* <a href="#rWhereClause">WhereClause</a> <a href="#rSolutionModifier">SolutionModifier</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[13]&nbsp;&nbsp;</code></td>
    <td><code><a id="rDatasetClause" name="rDatasetClause">DatasetClause</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'FROM'</span> ( <a href="#rDefaultGraphClause">DefaultGraphClause</a> | <a href="#rNamedGraphClause">NamedGraphClause</a> )</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[14]&nbsp;&nbsp;</code></td>
    <td><code><a id="rDefaultGraphClause" name="rDefaultGraphClause">DefaultGraphClause</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rSourceSelector">SourceSelector</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[15]&nbsp;&nbsp;</code></td>
    <td><code><a id="rNamedGraphClause" name="rNamedGraphClause">NamedGraphClause</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'NAMED'</span> <a href="#rSourceSelector">SourceSelector</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[16]&nbsp;&nbsp;</code></td>
    <td><code><a id="rSourceSelector" name="rSourceSelector">SourceSelector</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#riri">iri</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[17]&nbsp;&nbsp;</code></td>
    <td><code><a id="rWhereClause" name="rWhereClause">WhereClause</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'WHERE'</span>? <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[18]&nbsp;&nbsp;</code></td>
    <td><code><a id="rSolutionModifier" name="rSolutionModifier">SolutionModifier</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rGroupClause">GroupClause</a>? <a href="#rHavingClause">HavingClause</a>? <a href="#rOrderClause">OrderClause</a>? <a href="#rLimitOffsetClauses">LimitOffsetClauses</a>?</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[19]&nbsp;&nbsp;</code></td>
    <td><code><a id="rGroupClause" name="rGroupClause">GroupClause</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'GROUP'</span> <span class="token">'BY'</span> <a href="#rGroupCondition">GroupCondition</a>+</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[20]&nbsp;&nbsp;</code></td>
    <td><code><a id="rGroupCondition" name="rGroupCondition">GroupCondition</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rBuiltInCall">BuiltInCall</a> | <a href="#rFunctionCall">FunctionCall</a> | <span class="token">'('</span> <a href="#rExpression">Expression</a> ( <span class="token">'AS'</span> <a href="#rVar">Var</a> )? <span class="token">')'</span> | <a href="#rVar">Var</a> </code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[21]&nbsp;&nbsp;</code></td>
    <td><code><a id="rHavingClause" name="rHavingClause">HavingClause</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'HAVING'</span> <a href="#rHavingCondition">HavingCondition</a>+</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[22]&nbsp;&nbsp;</code></td>
    <td><code><a id="rHavingCondition" name="rHavingCondition">HavingCondition</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rConstraint">Constraint</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[23]&nbsp;&nbsp;</code></td>
    <td><code><a id="rOrderClause" name="rOrderClause">OrderClause</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'ORDER'</span> <span class="token">'BY'</span> <a href="#rOrderCondition">OrderCondition</a>+</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[24]&nbsp;&nbsp;</code></td>
    <td><code><a id="rOrderCondition" name="rOrderCondition">OrderCondition</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code>   ( ( <span class="token">'ASC'</span> | <span class="token">'DESC'</span> ) <a href="#rBrackettedExpression">BrackettedExpression</a> )<br>| ( <a href="#rConstraint">Constraint</a> | <a href="#rVar">Var</a> ) </code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[25]&nbsp;&nbsp;</code></td>
    <td><code><a id="rLimitOffsetClauses" name="rLimitOffsetClauses">LimitOffsetClauses</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rLimitClause">LimitClause</a> <a href="#rOffsetClause">OffsetClause</a>? | <a href="#rOffsetClause">OffsetClause</a> <a href="#rLimitClause">LimitClause</a>? </code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[26]&nbsp;&nbsp;</code></td>
    <td><code><a id="rLimitClause" name="rLimitClause">LimitClause</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'LIMIT'</span> <a href="#rINTEGER">INTEGER</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[27]&nbsp;&nbsp;</code></td>
    <td><code><a id="rOffsetClause" name="rOffsetClause">OffsetClause</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'OFFSET'</span> <a href="#rINTEGER">INTEGER</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[28]&nbsp;&nbsp;</code></td>
    <td><code><a id="rValuesClause" name="rValuesClause">ValuesClause</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code>( <span class="token">'VALUES'</span> <a href="#rDataBlock">DataBlock</a> )?</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[29]&nbsp;&nbsp;</code></td>
    <td><code><a id="rUpdate" name="rUpdate">Update</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rPrologue">Prologue</a> ( <a href="#rUpdate1">Update1</a> ( <span class="token">';'</span> <a href="#rUpdate">Update</a> )? )?</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[30]&nbsp;&nbsp;</code></td>
    <td><code><a id="rUpdate1" name="rUpdate1">Update1</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rLoad">Load</a> | <a href="#rClear">Clear</a> | <a href="#rDrop">Drop</a> | <a href="#rAdd">Add</a> | <a href="#rMove">Move</a> | <a href="#rCopy">Copy</a> | <a href="#rCreate">Create</a> | <a href="#rInsertData">InsertData</a> | <a href="#rDeleteData">DeleteData</a> | <a href="#rDeleteWhere">DeleteWhere</a> | <a href="#rModify">Modify</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[31]&nbsp;&nbsp;</code></td>
    <td><code><a id="rLoad" name="rLoad">Load</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'LOAD'</span> <span class="token">'SILENT'</span>? <a href="#riri">iri</a> ( <span class="token">'INTO'</span> <a href="#rGraphRef">GraphRef</a> )?</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[32]&nbsp;&nbsp;</code></td>
    <td><code><a id="rClear" name="rClear">Clear</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'CLEAR'</span> <span class="token">'SILENT'</span>? <a href="#rGraphRefAll">GraphRefAll</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[33]&nbsp;&nbsp;</code></td>
    <td><code><a id="rDrop" name="rDrop">Drop</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'DROP'</span> <span class="token">'SILENT'</span>? <a href="#rGraphRefAll">GraphRefAll</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[34]&nbsp;&nbsp;</code></td>
    <td><code><a id="rCreate" name="rCreate">Create</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'CREATE'</span> <span class="token">'SILENT'</span>? <a href="#rGraphRef">GraphRef</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[35]&nbsp;&nbsp;</code></td>
    <td><code><a id="rAdd" name="rAdd">Add</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'ADD'</span> <span class="token">'SILENT'</span>? <a href="#rGraphOrDefault">GraphOrDefault</a> <span class="token">'TO'</span> <a href="#rGraphOrDefault">GraphOrDefault</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[36]&nbsp;&nbsp;</code></td>
    <td><code><a id="rMove" name="rMove">Move</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'MOVE'</span> <span class="token">'SILENT'</span>? <a href="#rGraphOrDefault">GraphOrDefault</a> <span class="token">'TO'</span> <a href="#rGraphOrDefault">GraphOrDefault</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[37]&nbsp;&nbsp;</code></td>
    <td><code><a id="rCopy" name="rCopy">Copy</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'COPY'</span> <span class="token">'SILENT'</span>? <a href="#rGraphOrDefault">GraphOrDefault</a> <span class="token">'TO'</span> <a href="#rGraphOrDefault">GraphOrDefault</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[38]&nbsp;&nbsp;</code></td>
    <td><code><a id="rInsertData" name="rInsertData">InsertData</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'INSERT DATA'</span> <a href="#rQuadData">QuadData</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[39]&nbsp;&nbsp;</code></td>
    <td><code><a id="rDeleteData" name="rDeleteData">DeleteData</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'DELETE DATA'</span> <a href="#rQuadData">QuadData</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[40]&nbsp;&nbsp;</code></td>
    <td><code><a id="rDeleteWhere" name="rDeleteWhere">DeleteWhere</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'DELETE WHERE'</span> <a href="#rQuadPattern">QuadPattern</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[41]&nbsp;&nbsp;</code></td>
    <td><code><a id="rModify" name="rModify">Modify</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code>( <span class="token">'WITH'</span> <a href="#riri">iri</a> )? ( <a href="#rDeleteClause">DeleteClause</a> <a href="#rInsertClause">InsertClause</a>? | <a href="#rInsertClause">InsertClause</a> ) <a href="#rUsingClause">UsingClause</a>* <span class="token">'WHERE'</span> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[42]&nbsp;&nbsp;</code></td>
    <td><code><a id="rDeleteClause" name="rDeleteClause">DeleteClause</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'DELETE'</span> <a href="#rQuadPattern">QuadPattern</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[43]&nbsp;&nbsp;</code></td>
    <td><code><a id="rInsertClause" name="rInsertClause">InsertClause</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'INSERT'</span> <a href="#rQuadPattern">QuadPattern</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[44]&nbsp;&nbsp;</code></td>
    <td><code><a id="rUsingClause" name="rUsingClause">UsingClause</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'USING'</span> ( <a href="#riri">iri</a> | <span class="token">'NAMED'</span> <a href="#riri">iri</a> )</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[45]&nbsp;&nbsp;</code></td>
    <td><code><a id="rGraphOrDefault" name="rGraphOrDefault">GraphOrDefault</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'DEFAULT'</span> | <span class="token">'GRAPH'</span>? <a href="#riri">iri</a> </code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[46]&nbsp;&nbsp;</code></td>
    <td><code><a id="rGraphRef" name="rGraphRef">GraphRef</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'GRAPH'</span> <a href="#riri">iri</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[47]&nbsp;&nbsp;</code></td>
    <td><code><a id="rGraphRefAll" name="rGraphRefAll">GraphRefAll</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rGraphRef">GraphRef</a> | <span class="token">'DEFAULT'</span> | <span class="token">'NAMED'</span> | <span class="token">'ALL'</span></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[48]&nbsp;&nbsp;</code></td>
    <td><code><a id="rQuadPattern" name="rQuadPattern">QuadPattern</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'{'</span> <a href="#rQuads">Quads</a> <span class="token">'}'</span></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[49]&nbsp;&nbsp;</code></td>
    <td><code><a id="rQuadData" name="rQuadData">QuadData</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'{'</span> <a href="#rQuads">Quads</a> <span class="token">'}'</span></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[50]&nbsp;&nbsp;</code></td>
    <td><code><a id="rQuads" name="rQuads">Quads</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rTriplesTemplate">TriplesTemplate</a>? ( <a href="#rQuadsNotTriples">QuadsNotTriples</a> <span class="token">'.'</span>? <a href="#rTriplesTemplate">TriplesTemplate</a>? )*</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[51]&nbsp;&nbsp;</code></td>
    <td><code><a id="rQuadsNotTriples" name="rQuadsNotTriples">QuadsNotTriples</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'GRAPH'</span> <a href="#rVarOrIri">VarOrIri</a> <span class="token">'{'</span> <a href="#rTriplesTemplate">TriplesTemplate</a>? <span class="token">'}'</span></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[52]&nbsp;&nbsp;</code></td>
    <td><code><a id="rTriplesTemplate" name="rTriplesTemplate">TriplesTemplate</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rTriplesSameSubject">TriplesSameSubject</a> ( <span class="token">'.'</span> <a href="#rTriplesTemplate">TriplesTemplate</a>? )?</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[53]&nbsp;&nbsp;</code></td>
    <td><code><a id="rGroupGraphPattern" name="rGroupGraphPattern">GroupGraphPattern</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'{'</span> ( <a href="#rSubSelect">SubSelect</a> | <a href="#rGroupGraphPatternSub">GroupGraphPatternSub</a> ) <span class="token">'}'</span></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[54]&nbsp;&nbsp;</code></td>
    <td><code><a id="rGroupGraphPatternSub" name="rGroupGraphPatternSub">GroupGraphPatternSub</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rTriplesBlock">TriplesBlock</a>? ( <a href="#rGraphPatternNotTriples">GraphPatternNotTriples</a> <span class="token">'.'</span>? <a href="#rTriplesBlock">TriplesBlock</a>? )*</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[55]&nbsp;&nbsp;</code></td>
    <td><code><a id="rTriplesBlock" name="rTriplesBlock">TriplesBlock</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rTriplesSameSubjectPath">TriplesSameSubjectPath</a> ( <span class="token">'.'</span> <a href="#rTriplesBlock">TriplesBlock</a>? )?</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[56]&nbsp;&nbsp;</code></td>
    <td><code><a id="rGraphPatternNotTriples" name="rGraphPatternNotTriples">GraphPatternNotTriples</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</a> | <a href="#rOptionalGraphPattern">OptionalGraphPattern</a> | <a href="#rMinusGraphPattern">MinusGraphPattern</a> | <a href="#rGraphGraphPattern">GraphGraphPattern</a> | <a href="#rServiceGraphPattern">ServiceGraphPattern</a> | <a href="#rFilter">Filter</a> | <a href="#rBind">Bind</a> | <a href="#rInlineData">InlineData</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[57]&nbsp;&nbsp;</code></td>
    <td><code><a id="rOptionalGraphPattern" name="rOptionalGraphPattern">OptionalGraphPattern</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'OPTIONAL'</span> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[58]&nbsp;&nbsp;</code></td>
    <td><code><a id="rGraphGraphPattern" name="rGraphGraphPattern">GraphGraphPattern</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'GRAPH'</span> <a href="#rVarOrIri">VarOrIri</a> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[59]&nbsp;&nbsp;</code></td>
    <td><code><a id="rServiceGraphPattern" name="rServiceGraphPattern">ServiceGraphPattern</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'SERVICE'</span> <span class="token">'SILENT'</span>? <a href="#rVarOrIri">VarOrIri</a> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[60]&nbsp;&nbsp;</code></td>
    <td><code><a id="rBind" name="rBind">Bind</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'BIND'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">'AS'</span> <a href="#rVar">Var</a> <span class="token">')'</span></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[61]&nbsp;&nbsp;</code></td>
    <td><code><a id="rInlineData" name="rInlineData">InlineData</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'VALUES'</span> <a href="#rDataBlock">DataBlock</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[62]&nbsp;&nbsp;</code></td>
    <td><code><a id="rDataBlock" name="rDataBlock">DataBlock</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rInlineDataOneVar">InlineDataOneVar</a> | <a href="#rInlineDataFull">InlineDataFull</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[63]&nbsp;&nbsp;</code></td>
    <td><code><a id="rInlineDataOneVar" name="rInlineDataOneVar">InlineDataOneVar</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rVar">Var</a> <span class="token">'{'</span> <a href="#rDataBlockValue">DataBlockValue</a>* <span class="token">'}'</span></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[64]&nbsp;&nbsp;</code></td>
    <td><code><a id="rInlineDataFull" name="rInlineDataFull">InlineDataFull</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code>( <a href="#rNIL">NIL</a> | <span class="token">'('</span> <a href="#rVar">Var</a>* <span class="token">')'</span> ) <span class="token">'{'</span> ( <span class="token">'('</span> <a href="#rDataBlockValue">DataBlockValue</a>* <span class="token">')'</span> | <a href="#rNIL">NIL</a> )* <span class="token">'}'</span></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[65]&nbsp;&nbsp;</code></td>
    <td><code><a id="rDataBlockValue" name="rDataBlockValue">DataBlockValue</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#riri">iri</a> |	<a href="#rRDFLiteral">RDFLiteral</a> |	<a href="#rNumericLiteral">NumericLiteral</a> |	<a href="#rBooleanLiteral">BooleanLiteral</a> |	<span class="token">'UNDEF'</span></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[66]&nbsp;&nbsp;</code></td>
    <td><code><a id="rMinusGraphPattern" name="rMinusGraphPattern">MinusGraphPattern</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'MINUS'</span> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[67]&nbsp;&nbsp;</code></td>
    <td><code><a id="rGroupOrUnionGraphPattern" name="rGroupOrUnionGraphPattern">GroupOrUnionGraphPattern</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rGroupGraphPattern">GroupGraphPattern</a> ( <span class="token">'UNION'</span> <a href="#rGroupGraphPattern">GroupGraphPattern</a> )*</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[68]&nbsp;&nbsp;</code></td>
    <td><code><a id="rFilter" name="rFilter">Filter</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'FILTER'</span> <a href="#rConstraint">Constraint</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[69]&nbsp;&nbsp;</code></td>
    <td><code><a id="rConstraint" name="rConstraint">Constraint</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rBrackettedExpression">BrackettedExpression</a> | <a href="#rBuiltInCall">BuiltInCall</a> | <a href="#rFunctionCall">FunctionCall</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[70]&nbsp;&nbsp;</code></td>
    <td><code><a id="rFunctionCall" name="rFunctionCall">FunctionCall</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#riri">iri</a> <a href="#rArgList">ArgList</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[71]&nbsp;&nbsp;</code></td>
    <td><code><a id="rArgList" name="rArgList">ArgList</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rNIL">NIL</a> | <span class="token">'('</span> <span class="token">'DISTINCT'</span>? <a href="#rExpression">Expression</a> ( <span class="token">','</span> <a href="#rExpression">Expression</a> )* <span class="token">')'</span> </code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[72]&nbsp;&nbsp;</code></td>
    <td><code><a id="rExpressionList" name="rExpressionList">ExpressionList</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rNIL">NIL</a> | <span class="token">'('</span> <a href="#rExpression">Expression</a> ( <span class="token">','</span> <a href="#rExpression">Expression</a> )* <span class="token">')'</span> </code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[73]&nbsp;&nbsp;</code></td>
    <td><code><a id="rConstructTemplate" name="rConstructTemplate">ConstructTemplate</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'{'</span> <a href="#rConstructTriples">ConstructTriples</a>? <span class="token">'}'</span></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[74]&nbsp;&nbsp;</code></td>
    <td><code><a id="rConstructTriples" name="rConstructTriples">ConstructTriples</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rTriplesSameSubject">TriplesSameSubject</a> ( <span class="token">'.'</span> <a href="#rConstructTriples">ConstructTriples</a>? )?</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[75]&nbsp;&nbsp;</code></td>
    <td><code><a id="rTriplesSameSubject" name="rTriplesSameSubject">TriplesSameSubject</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rVarOrTerm">VarOrTerm</a> <a href="#rPropertyListNotEmpty">PropertyListNotEmpty</a> |	<a href="#rTriplesNode">TriplesNode</a> <a href="#rPropertyList">PropertyList</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[76]&nbsp;&nbsp;</code></td>
    <td><code><a id="rPropertyList" name="rPropertyList">PropertyList</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rPropertyListNotEmpty">PropertyListNotEmpty</a>?</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[77]&nbsp;&nbsp;</code></td>
    <td><code><a id="rPropertyListNotEmpty" name="rPropertyListNotEmpty">PropertyListNotEmpty</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rVerb">Verb</a> <a href="#rObjectList">ObjectList</a> ( <span class="token">';'</span> ( <a href="#rVerb">Verb</a> <a href="#rObjectList">ObjectList</a> )? )*</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[78]&nbsp;&nbsp;</code></td>
    <td><code><a id="rVerb" name="rVerb">Verb</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rVarOrIri">VarOrIri</a> | <span class="token">'a'</span></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[79]&nbsp;&nbsp;</code></td>
    <td><code><a id="rObjectList" name="rObjectList">ObjectList</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rObject">Object</a> ( <span class="token">','</span> <a href="#rObject">Object</a> )*</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[80]&nbsp;&nbsp;</code></td>
    <td><code><a id="rObject" name="rObject">Object</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rGraphNode">GraphNode</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[81]&nbsp;&nbsp;</code></td>
    <td><code><a id="rTriplesSameSubjectPath" name="rTriplesSameSubjectPath">TriplesSameSubjectPath</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rVarOrTerm">VarOrTerm</a> <a href="#rPropertyListPathNotEmpty">PropertyListPathNotEmpty</a> |	<a href="#rTriplesNodePath">TriplesNodePath</a> <a href="#rPropertyListPath">PropertyListPath</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[82]&nbsp;&nbsp;</code></td>
    <td><code><a id="rPropertyListPath" name="rPropertyListPath">PropertyListPath</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rPropertyListPathNotEmpty">PropertyListPathNotEmpty</a>?</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[83]&nbsp;&nbsp;</code></td>
    <td><code><a id="rPropertyListPathNotEmpty" name="rPropertyListPathNotEmpty">PropertyListPathNotEmpty</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code>( <a href="#rVerbPath">VerbPath</a> | <a href="#rVerbSimple">VerbSimple</a> ) <a href="#rObjectListPath">ObjectListPath</a> ( <span class="token">';'</span> ( ( <a href="#rVerbPath">VerbPath</a> | <a href="#rVerbSimple">VerbSimple</a> ) <a href="#rObjectList">ObjectList</a> )? )*</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[84]&nbsp;&nbsp;</code></td>
    <td><code><a id="rVerbPath" name="rVerbPath">VerbPath</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rPath">Path</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[85]&nbsp;&nbsp;</code></td>
    <td><code><a id="rVerbSimple" name="rVerbSimple">VerbSimple</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rVar">Var</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[86]&nbsp;&nbsp;</code></td>
    <td><code><a id="rObjectListPath" name="rObjectListPath">ObjectListPath</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rObjectPath">ObjectPath</a> ( <span class="token">','</span> <a href="#rObjectPath">ObjectPath</a> )*</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[87]&nbsp;&nbsp;</code></td>
    <td><code><a id="rObjectPath" name="rObjectPath">ObjectPath</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rGraphNodePath">GraphNodePath</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[88]&nbsp;&nbsp;</code></td>
    <td><code><a id="rPath" name="rPath">Path</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rPathAlternative">PathAlternative</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[89]&nbsp;&nbsp;</code></td>
    <td><code><a id="rPathAlternative" name="rPathAlternative">PathAlternative</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rPathSequence">PathSequence</a> ( <span class="token">'|'</span> <a href="#rPathSequence">PathSequence</a> )*</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[90]&nbsp;&nbsp;</code></td>
    <td><code><a id="rPathSequence" name="rPathSequence">PathSequence</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rPathEltOrInverse">PathEltOrInverse</a> ( <span class="token">'/'</span> <a href="#rPathEltOrInverse">PathEltOrInverse</a> )*</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[91]&nbsp;&nbsp;</code></td>
    <td><code><a id="rPathElt" name="rPathElt">PathElt</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rPathPrimary">PathPrimary</a> <a href="#rPathMod">PathMod</a>?</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[92]&nbsp;&nbsp;</code></td>
    <td><code><a id="rPathEltOrInverse" name="rPathEltOrInverse">PathEltOrInverse</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rPathElt">PathElt</a> | <span class="token">'^'</span> <a href="#rPathElt">PathElt</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[93]&nbsp;&nbsp;</code></td>
    <td><code><a id="rPathMod" name="rPathMod">PathMod</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'?'</span> | <span class="token">'*'</span> | <span class="token">'+'</span></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[94]&nbsp;&nbsp;</code></td>
    <td><code><a id="rPathPrimary" name="rPathPrimary">PathPrimary</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#riri">iri</a> | <span class="token">'a'</span> | <span class="token">'!'</span> <a href="#rPathNegatedPropertySet">PathNegatedPropertySet</a> | <span class="token">'('</span> <a href="#rPath">Path</a> <span class="token">')'</span> </code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[95]&nbsp;&nbsp;</code></td>
    <td><code><a id="rPathNegatedPropertySet" name="rPathNegatedPropertySet">PathNegatedPropertySet</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rPathOneInPropertySet">PathOneInPropertySet</a> | <span class="token">'('</span> ( <a href="#rPathOneInPropertySet">PathOneInPropertySet</a> ( <span class="token">'|'</span> <a href="#rPathOneInPropertySet">PathOneInPropertySet</a> )* )? <span class="token">')'</span> </code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[96]&nbsp;&nbsp;</code></td>
    <td><code><a id="rPathOneInPropertySet" name="rPathOneInPropertySet">PathOneInPropertySet</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#riri">iri</a> | <span class="token">'a'</span> | <span class="token">'^'</span> ( <a href="#riri">iri</a> | <span class="token">'a'</span> ) </code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[97]&nbsp;&nbsp;</code></td>
    <td><code><a id="rInteger" name="rInteger">Integer</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rINTEGER">INTEGER</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[98]&nbsp;&nbsp;</code></td>
    <td><code><a id="rTriplesNode" name="rTriplesNode">TriplesNode</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rCollection">Collection</a> |	<a href="#rBlankNodePropertyList">BlankNodePropertyList</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[99]&nbsp;&nbsp;</code></td>
    <td><code><a id="rBlankNodePropertyList" name="rBlankNodePropertyList">BlankNodePropertyList</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'['</span> <a href="#rPropertyListNotEmpty">PropertyListNotEmpty</a> <span class="token">']'</span></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[100]&nbsp;&nbsp;</code></td>
    <td><code><a id="rTriplesNodePath" name="rTriplesNodePath">TriplesNodePath</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rCollectionPath">CollectionPath</a> |	<a href="#rBlankNodePropertyListPath">BlankNodePropertyListPath</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[101]&nbsp;&nbsp;</code></td>
    <td><code><a id="rBlankNodePropertyListPath" name="rBlankNodePropertyListPath">BlankNodePropertyListPath</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'['</span> <a href="#rPropertyListPathNotEmpty">PropertyListPathNotEmpty</a> <span class="token">']'</span></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[102]&nbsp;&nbsp;</code></td>
    <td><code><a id="rCollection" name="rCollection">Collection</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'('</span> <a href="#rGraphNode">GraphNode</a>+ <span class="token">')'</span></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[103]&nbsp;&nbsp;</code></td>
    <td><code><a id="rCollectionPath" name="rCollectionPath">CollectionPath</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'('</span> <a href="#rGraphNodePath">GraphNodePath</a>+ <span class="token">')'</span></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[104]&nbsp;&nbsp;</code></td>
    <td><code><a id="rGraphNode" name="rGraphNode">GraphNode</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rVarOrTerm">VarOrTerm</a> |	<a href="#rTriplesNode">TriplesNode</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[105]&nbsp;&nbsp;</code></td>
    <td><code><a id="rGraphNodePath" name="rGraphNodePath">GraphNodePath</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rVarOrTerm">VarOrTerm</a> |	<a href="#rTriplesNodePath">TriplesNodePath</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[106]&nbsp;&nbsp;</code></td>
    <td><code><a id="rVarOrTerm" name="rVarOrTerm">VarOrTerm</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rVar">Var</a> | <a href="#rGraphTerm">GraphTerm</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[107]&nbsp;&nbsp;</code></td>
    <td><code><a id="rVarOrIri" name="rVarOrIri">VarOrIri</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rVar">Var</a> | <a href="#riri">iri</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[108]&nbsp;&nbsp;</code></td>
    <td><code><a id="rVar" name="rVar">Var</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rVAR1">VAR1</a> | <a href="#rVAR2">VAR2</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[109]&nbsp;&nbsp;</code></td>
    <td><code><a id="rGraphTerm" name="rGraphTerm">GraphTerm</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#riri">iri</a> |	<a href="#rRDFLiteral">RDFLiteral</a> |	<a href="#rNumericLiteral">NumericLiteral</a> |	<a href="#rBooleanLiteral">BooleanLiteral</a> |	<a href="#rBlankNode">BlankNode</a> |	<a href="#rNIL">NIL</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[110]&nbsp;&nbsp;</code></td>
    <td><code><a id="rExpression" name="rExpression">Expression</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rConditionalOrExpression">ConditionalOrExpression</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[111]&nbsp;&nbsp;</code></td>
    <td><code><a id="rConditionalOrExpression" name="rConditionalOrExpression">ConditionalOrExpression</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rConditionalAndExpression">ConditionalAndExpression</a> ( <span class="token">'||'</span> <a href="#rConditionalAndExpression">ConditionalAndExpression</a> )*</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[112]&nbsp;&nbsp;</code></td>
    <td><code><a id="rConditionalAndExpression" name="rConditionalAndExpression">ConditionalAndExpression</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rValueLogical">ValueLogical</a> ( <span class="token">'&amp;&amp;'</span> <a href="#rValueLogical">ValueLogical</a> )*</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[113]&nbsp;&nbsp;</code></td>
    <td><code><a id="rValueLogical" name="rValueLogical">ValueLogical</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rRelationalExpression">RelationalExpression</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[114]&nbsp;&nbsp;</code></td>
    <td><code><a id="rRelationalExpression" name="rRelationalExpression">RelationalExpression</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rNumericExpression">NumericExpression</a> ( <span class="token">'='</span> <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'!='</span> <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'&lt;'</span> <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'&gt;'</span> <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'&lt;='</span> <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'&gt;='</span> <a href="#rNumericExpression">NumericExpression</a> | <span class="token">'IN'</span> <a href="#rExpressionList">ExpressionList</a> | <span class="token">'NOT'</span> <span class="token">'IN'</span> <a href="#rExpressionList">ExpressionList</a> )?</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[115]&nbsp;&nbsp;</code></td>
    <td><code><a id="rNumericExpression" name="rNumericExpression">NumericExpression</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rAdditiveExpression">AdditiveExpression</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[116]&nbsp;&nbsp;</code></td>
    <td><code><a id="rAdditiveExpression" name="rAdditiveExpression">AdditiveExpression</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rMultiplicativeExpression">MultiplicativeExpression</a> ( <span class="token">'+'</span> <a href="#rMultiplicativeExpression">MultiplicativeExpression</a> | <span class="token">'-'</span> <a href="#rMultiplicativeExpression">MultiplicativeExpression</a> | ( <a href="#rNumericLiteralPositive">NumericLiteralPositive</a> | <a href="#rNumericLiteralNegative">NumericLiteralNegative</a> ) ( ( <span class="token">'*'</span> <a href="#rUnaryExpression">UnaryExpression</a> ) | ( <span class="token">'/'</span> <a href="#rUnaryExpression">UnaryExpression</a> ) )* )*</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[117]&nbsp;&nbsp;</code></td>
    <td><code><a id="rMultiplicativeExpression" name="rMultiplicativeExpression">MultiplicativeExpression</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rUnaryExpression">UnaryExpression</a> ( <span class="token">'*'</span> <a href="#rUnaryExpression">UnaryExpression</a> | <span class="token">'/'</span> <a href="#rUnaryExpression">UnaryExpression</a> )*</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[118]&nbsp;&nbsp;</code></td>
    <td><code><a id="rUnaryExpression" name="rUnaryExpression">UnaryExpression</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code>??<span class="token">'!'</span> <a href="#rPrimaryExpression">PrimaryExpression</a> <br>|	<span class="token">'+'</span> <a href="#rPrimaryExpression">PrimaryExpression</a> <br>|	<span class="token">'-'</span> <a href="#rPrimaryExpression">PrimaryExpression</a> <br>|	<a href="#rPrimaryExpression">PrimaryExpression</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[119]&nbsp;&nbsp;</code></td>
    <td><code><a id="rPrimaryExpression" name="rPrimaryExpression">PrimaryExpression</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rBrackettedExpression">BrackettedExpression</a> | <a href="#rBuiltInCall">BuiltInCall</a> | <a href="#ririOrFunction">iriOrFunction</a> | <a href="#rRDFLiteral">RDFLiteral</a> | <a href="#rNumericLiteral">NumericLiteral</a> | <a href="#rBooleanLiteral">BooleanLiteral</a> | <a href="#rVar">Var</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[120]&nbsp;&nbsp;</code></td>
    <td><code><a id="rBrackettedExpression" name="rBrackettedExpression">BrackettedExpression</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[121]&nbsp;&nbsp;</code></td>
    <td><code><a id="rBuiltInCall" name="rBuiltInCall">BuiltInCall</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code>??<a href="#rAggregate">Aggregate</a> <br>
|	<span class="token">'STR'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'LANG'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'LANGMATCHES'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'DATATYPE'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'BOUND'</span> <span class="token">'('</span> <a href="#rVar">Var</a> <span class="token">')'</span> <br>
|	<span class="token">'IRI'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'URI'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'BNODE'</span> ( <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> | <a href="#rNIL">NIL</a> ) <br>
|	<span class="token">'RAND'</span> <a href="#rNIL">NIL</a> <br>
|	<span class="token">'ABS'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'CEIL'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'FLOOR'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'ROUND'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'CONCAT'</span> <a href="#rExpressionList">ExpressionList</a> <br>
|	<a href="#rSubstringExpression">SubstringExpression</a> <br>
|	<span class="token">'STRLEN'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<a href="#rStrReplaceExpression">StrReplaceExpression</a> <br>
|	<span class="token">'UCASE'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'LCASE'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'ENCODE_FOR_URI'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'CONTAINS'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'STRSTARTS'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'STRENDS'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'STRBEFORE'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'STRAFTER'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'YEAR'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'MONTH'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'DAY'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'HOURS'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'MINUTES'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'SECONDS'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'TIMEZONE'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'TZ'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'NOW'</span> <a href="#rNIL">NIL</a> <br>
|	<span class="token">'UUID'</span> <a href="#rNIL">NIL</a> <br>
|	<span class="token">'STRUUID'</span> <a href="#rNIL">NIL</a> <br>
|	<span class="token">'MD5'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'SHA1'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'SHA256'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'SHA384'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'SHA512'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'COALESCE'</span> <a href="#rExpressionList">ExpressionList</a> <br>
|	<span class="token">'IF'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'STRLANG'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'STRDT'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'sameTerm'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'isIRI'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'isURI'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'isBLANK'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'isLITERAL'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<span class="token">'isNUMERIC'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
|	<a href="#rRegexExpression">RegexExpression</a> <br>
|	<a href="#rExistsFunc">ExistsFunc</a> <br>
|	<a href="#rNotExistsFunc">NotExistsFunc</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[122]&nbsp;&nbsp;</code></td>
    <td><code><a id="rRegexExpression" name="rRegexExpression">RegexExpression</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'REGEX'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> ( <span class="token">','</span> <a href="#rExpression">Expression</a> )? <span class="token">')'</span></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[123]&nbsp;&nbsp;</code></td>
    <td><code><a id="rSubstringExpression" name="rSubstringExpression">SubstringExpression</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'SUBSTR'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> ( <span class="token">','</span> <a href="#rExpression">Expression</a> )? <span class="token">')'</span></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[124]&nbsp;&nbsp;</code></td>
    <td><code><a id="rStrReplaceExpression" name="rStrReplaceExpression">StrReplaceExpression</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'REPLACE'</span> <span class="token">'('</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> <span class="token">','</span> <a href="#rExpression">Expression</a> ( <span class="token">','</span> <a href="#rExpression">Expression</a> )? <span class="token">')'</span></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[125]&nbsp;&nbsp;</code></td>
    <td><code><a id="rExistsFunc" name="rExistsFunc">ExistsFunc</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'EXISTS'</span> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[126]&nbsp;&nbsp;</code></td>
    <td><code><a id="rNotExistsFunc" name="rNotExistsFunc">NotExistsFunc</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'NOT'</span> <span class="token">'EXISTS'</span> <a href="#rGroupGraphPattern">GroupGraphPattern</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[127]&nbsp;&nbsp;</code></td>
    <td><code><a id="rAggregate" name="rAggregate">Aggregate</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code>??<span class="token">'COUNT'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? ( <span class="token">'*'</span> | <a href="#rExpression">Expression</a> ) <span class="token">')'</span> <br>
| <span class="token">'SUM'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
| <span class="token">'MIN'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
| <span class="token">'MAX'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
| <span class="token">'AVG'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
| <span class="token">'SAMPLE'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? <a href="#rExpression">Expression</a> <span class="token">')'</span> <br>
| <span class="token">'GROUP_CONCAT'</span> <span class="token">'('</span> <span class="token">'DISTINCT'</span>? <a href="#rExpression">Expression</a> ( <span class="token">';'</span> <span class="token">'SEPARATOR'</span> <span class="token">'='</span> <a href="#rString">String</a> )? <span class="token">')'</span> </code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[128]&nbsp;&nbsp;</code></td>
    <td><code><a id="ririOrFunction" name="ririOrFunction">iriOrFunction</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#riri">iri</a> <a href="#rArgList">ArgList</a>?</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[129]&nbsp;&nbsp;</code></td>
    <td><code><a id="rRDFLiteral" name="rRDFLiteral">RDFLiteral</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rString">String</a> ( <a href="#rLANGTAG">LANGTAG</a> | ( <span class="token">'^^'</span> <a href="#riri">iri</a> ) )?</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[130]&nbsp;&nbsp;</code></td>
    <td><code><a id="rNumericLiteral" name="rNumericLiteral">NumericLiteral</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rNumericLiteralUnsigned">NumericLiteralUnsigned</a> | <a href="#rNumericLiteralPositive">NumericLiteralPositive</a> | <a href="#rNumericLiteralNegative">NumericLiteralNegative</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[131]&nbsp;&nbsp;</code></td>
    <td><code><a id="rNumericLiteralUnsigned" name="rNumericLiteralUnsigned">NumericLiteralUnsigned</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rINTEGER">INTEGER</a> |	<a href="#rDECIMAL">DECIMAL</a> |	<a href="#rDOUBLE">DOUBLE</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[132]&nbsp;&nbsp;</code></td>
    <td><code><a id="rNumericLiteralPositive" name="rNumericLiteralPositive">NumericLiteralPositive</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rINTEGER_POSITIVE">INTEGER_POSITIVE</a> |	<a href="#rDECIMAL_POSITIVE">DECIMAL_POSITIVE</a> |	<a href="#rDOUBLE_POSITIVE">DOUBLE_POSITIVE</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[133]&nbsp;&nbsp;</code></td>
    <td><code><a id="rNumericLiteralNegative" name="rNumericLiteralNegative">NumericLiteralNegative</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rINTEGER_NEGATIVE">INTEGER_NEGATIVE</a> |	<a href="#rDECIMAL_NEGATIVE">DECIMAL_NEGATIVE</a> |	<a href="#rDOUBLE_NEGATIVE">DOUBLE_NEGATIVE</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[134]&nbsp;&nbsp;</code></td>
    <td><code><a id="rBooleanLiteral" name="rBooleanLiteral">BooleanLiteral</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'true'</span> |	<span class="token">'false'</span></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[135]&nbsp;&nbsp;</code></td>
    <td><code><a id="rString" name="rString">String</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rSTRING_LITERAL1">STRING_LITERAL1</a> | <a href="#rSTRING_LITERAL2">STRING_LITERAL2</a> | <a href="#rSTRING_LITERAL_LONG1">STRING_LITERAL_LONG1</a> | <a href="#rSTRING_LITERAL_LONG2">STRING_LITERAL_LONG2</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[136]&nbsp;&nbsp;</code></td>
    <td><code><a id="riri" name="riri">iri</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rIRIREF">IRIREF</a> |	<a href="#rPrefixedName">PrefixedName</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[137]&nbsp;&nbsp;</code></td>
    <td><code><a id="rPrefixedName" name="rPrefixedName">PrefixedName</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rPNAME_LN">PNAME_LN</a> | <a href="#rPNAME_NS">PNAME_NS</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[138]&nbsp;&nbsp;</code></td>
    <td><code><a id="rBlankNode" name="rBlankNode">BlankNode</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rBLANK_NODE_LABEL">BLANK_NODE_LABEL</a> |	<a href="#rANON">ANON</a></code></td>
  </tr>
</tbody>
</table>

</div>

<p>終端記号の生成規則:</p>

<div class="grammarTable">

<table>
<tbody>
  <tr valign="baseline">
    <td><code>[139]&nbsp;&nbsp;</code></td>
    <td><code><a id="rIRIREF" name="rIRIREF">IRIREF</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'&lt;' ([^&lt;&gt;"{}|^`\]-[#x00-#x20])* '&gt;'</span></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[140]&nbsp;&nbsp;</code></td>
    <td><code><a id="rPNAME_NS" name="rPNAME_NS">PNAME_NS</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rPN_PREFIX">PN_PREFIX</a>? ':'</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[141]&nbsp;&nbsp;</code></td>
    <td><code><a id="rPNAME_LN" name="rPNAME_LN">PNAME_LN</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rPNAME_NS">PNAME_NS</a> <a href="#rPN_LOCAL">PN_LOCAL</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[142]&nbsp;&nbsp;</code></td>
    <td><code><a id="rBLANK_NODE_LABEL" name="rBLANK_NODE_LABEL">BLANK_NODE_LABEL</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code>'_:' ( <a href="#rPN_CHARS_U">PN_CHARS_U</a> | [0-9] ) ((<a href="#rPN_CHARS">PN_CHARS</a>|'.')* <a href="#rPN_CHARS">PN_CHARS</a>)?</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[143]&nbsp;&nbsp;</code></td>
    <td><code><a id="rVAR1" name="rVAR1">VAR1</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code>'?' <a href="#rVARNAME">VARNAME</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[144]&nbsp;&nbsp;</code></td>
    <td><code><a id="rVAR2" name="rVAR2">VAR2</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code>'$' <a href="#rVARNAME">VARNAME</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[145]&nbsp;&nbsp;</code></td>
    <td><code><a id="rLANGTAG" name="rLANGTAG">LANGTAG</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code>'@' [a-zA-Z]+ ('-' [a-zA-Z0-9]+)*</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[146]&nbsp;&nbsp;</code></td>
    <td><code><a id="rINTEGER" name="rINTEGER">INTEGER</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code>[0-9]+</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[147]&nbsp;&nbsp;</code></td>
    <td><code><a id="rDECIMAL" name="rDECIMAL">DECIMAL</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code>[0-9]* '.' [0-9]+</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[148]&nbsp;&nbsp;</code></td>
    <td><code><a id="rDOUBLE" name="rDOUBLE">DOUBLE</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code>[0-9]+ '.' [0-9]* <a href="#rEXPONENT">EXPONENT</a> | '.' ([0-9])+ <a href="#rEXPONENT">EXPONENT</a> | ([0-9])+ <a href="#rEXPONENT">EXPONENT</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[149]&nbsp;&nbsp;</code></td>
    <td><code><a id="rINTEGER_POSITIVE" name="rINTEGER_POSITIVE">INTEGER_POSITIVE</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'+'</span> <a href="#rINTEGER">INTEGER</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[150]&nbsp;&nbsp;</code></td>
    <td><code><a id="rDECIMAL_POSITIVE" name="rDECIMAL_POSITIVE">DECIMAL_POSITIVE</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'+'</span> <a href="#rDECIMAL">DECIMAL</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[151]&nbsp;&nbsp;</code></td>
    <td><code><a id="rDOUBLE_POSITIVE" name="rDOUBLE_POSITIVE">DOUBLE_POSITIVE</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'+'</span> <a href="#rDOUBLE">DOUBLE</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[152]&nbsp;&nbsp;</code></td>
    <td><code><a id="rINTEGER_NEGATIVE" name="rINTEGER_NEGATIVE">INTEGER_NEGATIVE</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'-'</span> <a href="#rINTEGER">INTEGER</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[153]&nbsp;&nbsp;</code></td>
    <td><code><a id="rDECIMAL_NEGATIVE" name="rDECIMAL_NEGATIVE">DECIMAL_NEGATIVE</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'-'</span> <a href="#rDECIMAL">DECIMAL</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[154]&nbsp;&nbsp;</code></td>
    <td><code><a id="rDOUBLE_NEGATIVE" name="rDOUBLE_NEGATIVE">DOUBLE_NEGATIVE</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><span class="token">'-'</span> <a href="#rDOUBLE">DOUBLE</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[155]&nbsp;&nbsp;</code></td>
    <td><code><a id="rEXPONENT" name="rEXPONENT">EXPONENT</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code>[eE] [+-]? [0-9]+</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[156]&nbsp;&nbsp;</code></td>
    <td><code><a id="rSTRING_LITERAL1" name="rSTRING_LITERAL1">STRING_LITERAL1</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code>"'" ( ([^#x27#x5C#xA#xD]) | <a href="#rECHAR">ECHAR</a> )* "'"</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[157]&nbsp;&nbsp;</code></td>
    <td><code><a id="rSTRING_LITERAL2" name="rSTRING_LITERAL2">STRING_LITERAL2</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code>'"' ( ([^#x22#x5C#xA#xD]) | <a href="#rECHAR">ECHAR</a> )* '"'</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[158]&nbsp;&nbsp;</code></td>
    <td><code><a id="rSTRING_LITERAL_LONG1" name="rSTRING_LITERAL_LONG1">STRING_LITERAL_LONG1</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code>"'''" ( ( "'" | "''" )? ( [^'\] | <a href="#rECHAR">ECHAR</a> ) )* "'''"</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[159]&nbsp;&nbsp;</code></td>
    <td><code><a id="rSTRING_LITERAL_LONG2" name="rSTRING_LITERAL_LONG2">STRING_LITERAL_LONG2</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code>'"""' ( ( '"' | '""' )? ( [^"\] | <a href="#rECHAR">ECHAR</a> ) )* '"""'</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[160]&nbsp;&nbsp;</code></td>
    <td><code><a id="rECHAR" name="rECHAR">ECHAR</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code>'\' [tbnrf\"']</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[161]&nbsp;&nbsp;</code></td>
    <td><code><a id="rNIL" name="rNIL">NIL</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code>'(' <a href="#rWS">WS</a>* ')'</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[162]&nbsp;&nbsp;</code></td>
    <td><code><a id="rWS" name="rWS">WS</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code>#x20 | #x9 | #xD | #xA</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[163]&nbsp;&nbsp;</code></td>    <td><code><a id="rANON" name="rANON">ANON</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code>'['  <a href="#rWS">WS</a>* ']'</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[164]&nbsp;&nbsp;</code></td>
    <td><code><a id="rPN_CHARS_BASE" name="rPN_CHARS_BASE">PN_CHARS_BASE</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code>[A-Z] | [a-z] | [#x00C0-#x00D6] | [#x00D8-#x00F6] | [#x00F8-#x02FF] | [#x0370-#x037D] | [#x037F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[165]&nbsp;&nbsp;</code></td>
    <td><code><a id="rPN_CHARS_U" name="rPN_CHARS_U">PN_CHARS_U</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rPN_CHARS_BASE">PN_CHARS_BASE</a> | '_'</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[166]&nbsp;&nbsp;</code></td>
    <td><code><a id="rVARNAME" name="rVARNAME">VARNAME</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code>( <a href="#rPN_CHARS_U">PN_CHARS_U</a>  | [0-9] ) ( <a href="#rPN_CHARS_U">PN_CHARS_U</a> | [0-9] | #x00B7 | [#x0300-#x036F] | [#x203F-#x2040] )*</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[167]&nbsp;&nbsp;</code></td>
    <td><code><a id="rPN_CHARS" name="rPN_CHARS">PN_CHARS</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rPN_CHARS_U">PN_CHARS_U</a> | '-' | [0-9] | #x00B7 | [#x0300-#x036F] | [#x203F-#x2040]</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[168]&nbsp;&nbsp;</code></td>
    <td><code><a id="rPN_PREFIX" name="rPN_PREFIX">PN_PREFIX</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rPN_CHARS_BASE">PN_CHARS_BASE</a> ((<a href="#rPN_CHARS">PN_CHARS</a>|'.')* <a href="#rPN_CHARS">PN_CHARS</a>)?</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[169]&nbsp;&nbsp;</code></td>
    <td><code><a id="rPN_LOCAL" name="rPN_LOCAL">PN_LOCAL</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code>(<a href="#rPN_CHARS_U">PN_CHARS_U</a> | ':' | [0-9] | <a href="#rPLX">PLX</a> ) ((<a href="#rPN_CHARS">PN_CHARS</a> | '.' | ':' | <a href="#rPLX">PLX</a>)* (<a href="#rPN_CHARS">PN_CHARS</a> | ':' | <a href="#rPLX">PLX</a>) )?</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[170]&nbsp;&nbsp;</code></td>
    <td><code><a id="rPLX" name="rPLX">PLX</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code><a href="#rPERCENT">PERCENT</a> | <a href="#rPN_LOCAL_ESC">PN_LOCAL_ESC</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[171]&nbsp;&nbsp;</code></td>
    <td><code><a id="rPERCENT" name="rPERCENT">PERCENT</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code>'%' <a href="#rHEX">HEX</a> <a href="#rHEX">HEX</a></code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[172]&nbsp;&nbsp;</code></td>
    <td><code><a id="rHEX" name="rHEX">HEX</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code>[0-9] | [A-F] | [a-f]</code></td>
  </tr>
  <tr valign="baseline">
    <td><code>[173]&nbsp;&nbsp;</code></td>
    <td><code><a id="rPN_LOCAL_ESC" name="rPN_LOCAL_ESC">PN_LOCAL_ESC</a></code></td>
    <td>&nbsp;&nbsp;::=&nbsp;&nbsp;</td>
    <td><code>'\' ( '_' | '~' | '.' | '-' | '!' | '$' | '&amp;' | "'" | '(' | ')' | '*' | '+' | ',' | ';' | '=' | '/' | '?' | '#' | '@' | '%' )</code></td>
  </tr>
</tbody>
</table>

</div>
</div>
</div>
<div class="div1">

<h2>
<a name="conformance" id="conformance"></a>20 適合性</h2>

<p><a href="#defn_SPARQLQueryString">SPARQLクエリ文字列</a>の適合性に関しては<a href="#grammar">19 SPARQL文法</a>の項を、クエリ結果の適合性に関しては<a href="#QueryForms">16 クエリ形式</a>の項を参照してください。application/sparql-queryメディア・タイプへの適合性に関しては<a href="#mediaType">22. インターネット・メディア・タイプ</a>を参照してください。</p>

<p>この仕様は、SPARQL 1.1プロトコル[<a href="#SPROT">SPROT</a>]、SPARQLクエリ結果XMLフォーマット[<a href="#SPARQL-XML-RESULTS">SPARQL XML Results</a>]、SPARQL 1.1クエリ結果JSONフォーマット[<a href="#SPARQL-JSON-RESULTS">SPARQL-JSON-Results</a>]、SPARQL 1.1クエリ結果CSVおよびTSVフォーマット[<a href="#SPARQL-CSV-TSV-RESULTS">SPARQL CSV and TSV Results</a>]との併用を意図しています。これらの適合性基準に関してはそれらの仕様を参照してください。</p>

<p>SPARQLプロトコルが、SPARQLクエリをSPARQLクエリ処理サービスに伝え、要求を行ったエンティティーにクエリ結果を返すための手段を記述しているということに注意してください。</p>

</div>
<div class="div1">

<h2>
<a name="security" id="security"></a>21 セキュリティに関する留意点（参考情報）</h2>

<p>FROM、FROM NAMED、またはGRAPHを用いたSPARQLクエリは、指定されたURIを逆参照するかもしれません。これは、サービスの拒否などの関連する副次的な問題と共に、ネットワーク、ディスクまたはCPU資源の追加使用を招くかもしれません。<a class="norm" href="www.ietf.org/rfc/rfc3986.txt">URI（Uniform Resource Identifier）:一般的構文</a>[<a href="#rfc3986">RFC3986</a>]の7項のセキュリティ問題について考察する必要があります。さらに、場合によっては、<code>file:</code> URIのコンテンツにアクセスし、処理し、結果として返すことができ、ローカル資源への予期しないアクセスが行われます</p>

<p>FROM NAMEDなど、SPARQLリクエストによって、SPARQLエンドポイントからのリクエストが追加で発行されるかもしれません。エンドポイントは潜在的に、組織のファイアウォールやDMZ内にあり、したがって、このようなクエリは、間接的な攻撃の原因となるかもしれません。</p>

<p>SPARQL言語は拡張を認めており、それには独自のセキュリティ上の影響があるでしょう。</p>

<p>複数のIRIが同じ外観を持っているかもしれません。異なるスクリプトの文字が同じに見えるかもしれません（キリル文字の「о」はラテン文字の「o」と同じに見えるかもしれません）。 結合文字が後続する文字は、別の文字と同じ視覚的表現を持っているかもしれません（結合アキュート・アクセントが後続するラテン小文字Eは、アキュート付きラテン小文字Eと同じ視覚的表現を持っています）。SPARQLのユーザは、注意してデータ中のIRIにマッチするIRIを持つクエリを構築しなければなりません。類似している文字のマッチングに関する詳細は、<a class="inform" href="www.unicode.org/reports/tr36/">Unicodeセキュリティに関する留意点</a>[<a href="#UNISEC">UNISEC</a>]および<a class="norm" href="www.ietf.org/rfc/rfc3987.txt">IRI（Internationalized Resource Identifiers）</a>[<a href="#rfc3987">RFC3987</a>]の8項にあります。</p>

</div>
<div class="div1">

<h2>
<a name="mediaType" id="mediaType"></a>22 インターネット・メディア・タイプ、ファイル拡張子、およびマッキントッシュ・ファイル・タイプ</h2>

<p>SPARQLクエリ言語のインターネット・メディア・タイプ/MIMEタイプは、「<tt>application/sparql-query</tt>」です。</p>

<p>sparqlクエリ・ファイルは、すべてのプラットホーム上で拡張子「.rq」（小文字）であることが推奨されます。</p>

<p>マッキントッシュHFSファイル・システム上に保存されたsparqlクエリ・ファイルには、ファイル・タイプ「TEXT」が付与されていることが推奨されます。</p>

<div class="mime">
<dl>
  <dt>タイプ名:</dt>
  <dd>application</dd>
  <dt>サブタイプ名:</dt>
  <dd>sparql-query</dd>
  <dt>必須パラメータ:</dt>
  <dd>なし</dd>
  <dt>任意のパラメータ:</dt>
  <dd>なし</dd>
  <dt>コード化に関する留意点:</dt>
  <dd>SPARQLクエリ言語の構文は、Unicode[<a href="#UNICODE">UNICODE</a>]のコード・ポイントで表されます。コード化は、常にUTF-8[<a href="#rfc3629">RFC3629</a>]です。</dd>
  <dd>Unicodeコード・ポイントは、Xが16進の[0-9A-F]である場合、\uXXXX（U+0～U+FFFF）または\UXXXXXXXX構文（U+10000以降）を用いて表現できます。 </dd>
  <dt>セキュリティに関する留意点:</dt>
  <dd>SPARQLクエリ付録C、<a href="#security">セキュリティに関する留意点</a>および<a class="norm" href="www.ietf.org/rfc/rfc3629.txt">RFC 3629</a>[<a href="#rfc3629">RFC3629</a>]の7項、セキュリティに関する留意点を参照してください。</dd>
  <dt>互換性に関する留意点:</dt>
  <dd>互換性の問題は知られていません。</dd>
  <dt>公開済み仕様書:</dt>
  <dd>この仕様書。</dd>
  <dt>このメディア・タイプを使用するアプリケーション:</dt>
  <dd>現時点でこのメディア・タイプを使用するアプリケーションは知られていません。</dd>
  <dt>追加情報:</dt>
  <dt>マジック・ナンバー:</dt>
  <dd>SPARQLクエリは、ドキュメントの冒頭付近に、文字列「PREFIX」（大文字・小文字を区別しない）を持つことができます。</dd>
  <dt>ファイル拡張子:</dt>
  <dd>「.rq」</dd>
  <dt>基底URI:</dt>
  <dd>SPARQL「BASE &lt;IRIref&gt;」用語は、現在の基底URIを、ドキュメントにおいて後ほど順次使用されるクエリ言語内の相対IRIrefに変更できます。</dd>
  <dt>マッキントッシュ・ファイル・タイプ・コード:</dt>
  <dd>「TEXT」</dd>
  <dt>詳細情報に関する連絡先:</dt>
  <dd>public-rdf-dawg-comments@w3.org</dd>
  <dt>意図する用途:</dt>
  <dd>汎用</dd>
  <dt>使用上の制限:</dt>
  <dd>なし</dd>
  <dt>著者／改版管理者:</dt>
  <dd>SPARQL 1.1仕様は、ワールド・ワイド・ウェブ・コンソーシアム（World Wide Web Consortium）のSPARQLワーキンググループ（SPARQL Working Group）の作業の成果です。W3Cは、これらの仕様の変更に対する管理権を有します。</dd>
	</dl>
</div>
</div>
</div>
<div class="back">
<div class="div1">

<h2>
<a name="sec-bibliography" id="sec-bibliography"></a>A 参考文献</h2>
<div class="div2">

<h3>
<a name="sec-normative-refs" id="sec-normative-refs"></a>A.1 規範的な参考文献</h3>

<dl class="bib">
  <dt><a name="CHARMOD" id="CHARMOD">[CHARMOD]</a></dt>
  <dd>
    <a href="www.w3.org/TR/2005/REC-charmod-20050215/">Character
      Model for the World Wide Web 1.0: Fundamentals</a>,
      R. Ishida, F. Yergeau, M. J. Durst, M. Wolf, T. Texin,
      Editors, W3C Recommendation, 15 February 2005,
      http://www.w3.org/TR/2005/REC-charmod-20050215/ . 
    <a href="www.w3.org/TR/charmod/" title="Latest version of Character Model for the World Wide Web 1.0: Fundamentals">Latest version</a> available at http://www.w3.org/TR/charmod/
      .</dd>

  <dt><a name="CONCEPTS" id="CONCEPTS">[CONCEPTS]</a></dt>
  <dd>
    <a href="www.w3.org/TR/2004/REC-rdf-concepts-20040210/">Resource
      Description Framework (RDF): Concepts and Abstract
      Syntax</a>, G. Klyne, J. J. Carroll, Editors, W3C
      Recommendation, 10 February 2004,
      http://www.w3.org/TR/2004/REC-rdf-concepts-20040210/ .
        <a href="www.w3.org/TR/rdf-concepts/" title="Latest version of Resource Description Framework (RDF): Concepts and Abstract Syntax">Latest version</a> available at
      http://www.w3.org/TR/rdf-concepts/ .</dd>
  <dt><a name="FUNCOP" id="FUNCOP">[FUNCOP]</a></dt>
  <dd>

    <a href="www.w3.org/TR/2007/REC-xpath-functions-20070123/">XQuery
      1.0 and XPath 2.0 Functions and Operators</a>, J.
      Melton, A. Malhotra, N. Walsh, Editors, W3C Recommendation,
      23 January 2007,
      http://www.w3.org/TR/2007/REC-xpath-functions-20070123/ .
        <a href="www.w3.org/TR/xpath-functions/" title="Latest version of XQuery 1.0 and XPath 2.0 Functions and Operators">Latest version</a> available at
      http://www.w3.org/TR/xpath-functions/ .</dd>
  <dt><a id="RDF-MT" name="RDF-MT">[RDF-MT]</a></dt>
  <dd>
    <a href="www.w3.org/TR/2004/REC-rdf-mt-20040210/">RDF
      Semantics</a>, P. Hayes, Editor, W3C Recommendation,
      10 February 2004,
      http://www.w3.org/TR/2004/REC-rdf-mt-20040210/ . 
    <a title="Latest version of RDF Semantics" href="www.w3.org/TR/rdf-mt/">Latest version</a> available
      at http://www.w3.org/TR/rdf-mt/ .</dd>

  <dt><a name="rfc3629" id="rfc3629">[RFC3629]</a></dt>
  <dd>RFC 3629 
    <a href="www.ietf.org/rfc/rfc3629.txt">UTF-8, a transformation
      format of ISO 10646</a>, F. Yergeau November 2003</dd>

  <dt><a name="rfc4647" id="rfc4647">[RFC4647]</a></dt>
  <dd>RFC 4647 <a href="www.ietf.org/rfc/rfc4647.txt">Matching of Language Tags</a>, A. Phillips, M. Davis September 2006</dd>

  <dt><a name="rfc3986" id="rfc3986">[RFC3986]</a></dt>
  <dd>RFC 3986 
    <a href="www.ietf.org/rfc/rfc3986.txt">Uniform Resource
      Identifier (URI): Generic Syntax</a>, T. Berners-Lee,
      R. Fielding, L. Masinter January 2005</dd>
  <dt><a name="rfc3987" id="rfc3987">[RFC3987]</a></dt>
  <dd>RFC 3987 <a href="www.ietf.org/rfc/rfc3987.txt">Internationalized Resource Identifiers (IRIs)</a>, 
      M. Durst , M. Suignard</dd>

  <dt><a name="UNICODE" id="UNICODE">[UNICODE]</a></dt>
  <dd>The Unicode Standard, Version 4. ISBN
      0-321-18578-1, as updated from time to time by the
      publication of new versions. The latest version of Unicode
      and additional information on versions of the standard and of
      the Unicode Character Database is available at 
    <a href="www.unicode.org/unicode/standard/versions/">http://www.unicode.org/unicode/standard/versions/</a>.</dd>
  <dt><a name="XML11" id="XML11">[XML11]</a></dt>
  <dd>
    <a href="www.w3.org/TR/2004/REC-xml11-20040204/">Extensible
      Markup Language (XML) 1.1</a>, J. Cowan, J. Paoli, E.
      Maler, C. M. Sperberg-McQueen, F. Yergeau, T. Bray, Editors,
      W3C Recommendation, 4 February 2004,
      http://www.w3.org/TR/2004/REC-xml11-20040204/ . 
    <a href="www.w3.org/TR/xml11/" title="Latest version of Extensible Markup Language (XML) 1.1">Latest
      version</a> available at http://www.w3.org/TR/xml11/ .</dd>

  <dt><a name="XPATH20" id="XPATH20">[XPATH20]</a></dt>
  <dd>
    <a href="www.w3.org/TR/2007/REC-xpath20-20070123/">XML Path
      Language (XPath) 2.0</a>, A. Berglund, S. Boag, D. Chamberlin, M. F. Fernandez, M. Kay, J. Robie, J. Simeon,
      Editors, W3C Recommendation, 23 January 2007,
      http://www.w3.org/TR/2007/REC-xpath20-20070123/ . 
    <a href="www.w3.org/TR/xpath20/" title="Latest version of XML Path Language (XPath) 2.0">Latest
      version</a> available at http://www.w3.org/TR/xpath20/ .</dd>
  <dt><a name="XQUERY" id="XQUERY">[XQUERY]</a></dt>
  <dd>

    <a href="www.w3.org/TR/2007/REC-xquery-20070123/">XQuery 1.0:
      An XML Query Language</a>, S. Boag, D. Chamberlin, M. F. Fernandez, D. Florescu, J. Robie, J. Simeon, Editors, W3C Recommendation, 23
      January 2007, http://www.w3.org/TR/2007/REC-xquery-20070123/.
        <a href="www.w3.org/TR/xquery/" title="Latest version of XQuery 1.0: An XML Query Language">Latest
      version</a> available at http://www.w3.org/TR/xquery/ . </dd>
  <dt><a name="XSDT" id="XSDT">[XSDT]</a></dt>
  <dd>
<a href="www.w3.org/TR/2004/REC-xmlschema-2-20041028/">XML
      Schema Part 2: Datatypes Second Edition</a>, P. V.
      Biron, A. Malhotra, Editors, W3C Recommendation, 28 October
      2004, http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/ .
      <a href="www.w3.org/TR/xmlschema-2/">Latest version</a> available at http://www.w3.org/TR/xmlschema-2/.<br>
      Updated 2012 by <a href="www.w3.org/TR/2012/REC-xmlschema11-2-20120405/">W3C
      XML Schema Definition Language (XSD) 1.1 Part 2: Datatypes</a>. 
      (<a href="www.w3.org/TR/xmlschema11-2/">Latest version</a> available at http://www.w3.org/TR/xmlschema11-2/).</dd>
  <dt><a name="BCP47" id="BCP47">[BCP47]</a></dt>
  <dd>
<a href="www.rfc-editor.org/rfc/bcp/bcp47.txt">Best Common Practice 47</a>, P. V. Biron, A. Malhotra, Editors, W3C Recommendation, 28 October 2004, http://www.rfc-editor.org/rfc/bcp/bcp47.txt .</dd>
</dl>
</div>
<div class="div2">

<h3>
<a name="sec-non-normative-refs" id="sec-non-normative-refs"></a>A.2 その他の参考文献</h3>

<dl class="bib">
  <dt><a name="CBD" id="CBD">[CBD]</a></dt>
  <dd>
<a href="www.w3.org/Submission/CBD/">CBD - Concise 
        Bounded Description</a>, Patrick Stickler, Nokia, W3C Member 
        Submission, 3 June 2005.</dd>
  <dt><a name="DC" id="DC">[DC]</a></dt>
  <dd>
<a href="www.dublincore.org/documents/dcmes-xml/">Expressing
      Simple Dublin Core in RDF/XML</a>
    <a href="dublincore.org/">Dublin Core Dublin Core Metadata
      Initiative</a> Recommendation 2002-07-31.</dd>
  <dt><a id="multiset" name="multiset">[Multiset]</a></dt>
  <dd>
<a href="en.wikipedia.org/w/index.php?title=Multiset&amp;oldid=163605900">Multiset</a>, Wikipedia, The Free Encyclopedia.
	Article as given on October 25, 2007 at http://en.wikipedia.org/w/index.php?title=Multiset&amp;oldid=163605900. The 
	<a href="en.wikipedia.org/wiki/Multiset">latest version</a> of this article is at http://en.wikipedia.org/wiki/Multiset.</dd>
  <dt><a name="SPARQL-XML-RESULTS" id="SPARQL-XML-RESULTS">[SPARQL XML Results]</a></dt>
  <dd>
<cite><a href="www.w3.org/TR/2013/REC-rdf-sparql-XMLres-20130321">SPARQL Query Results XML Format (Second Edition)</a></cite>, D. Beckett, J. Broekstra, Editors, W3C Recommendation, 21 March 2013, http://www.w3.org/TR/2013/REC-rdf-sparql-XMLres-20130321. <a href="www.w3.org/TR/rdf-sparql-XMLres/" title="Latest version of SPARQL Query Results XML Format (Second Edition)">Latest version</a> available at http://www.w3.org/TR/rdf-sparql-XMLres.</dd>
  <dt><a name="SPARQL-JSON-RESULTS" id="SPARQL-JSON-RESULTS">[SPARQL JSON Results]</a></dt>
  <dd>
<cite><a href="www.w3.org/TR/2013/REC-sparql11-results-json-20130321">SPARQL 1.1 Query Results JSON Format</a></cite>, A. Seaborne, Editor, W3C Recommendation, 21 March 2013, http://www.w3.org/TR/2013/REC-sparql11-results-json-20130321. <a href="www.w3.org/TR/sparql11-results-json/" title="Latest version of SPARQL 1.1 Query Results JSON Format">Latest version</a> available at http://www.w3.org/TR/sparql11-results-json.</dd>
  <dt><a name="SPARQL-CSV-TSV-RESULTS" id="SPARQL-CSV-TSV-RESULTS">[SPARQL CSV and TSV Result]</a></dt>
  <dd>
<cite><a href="www.w3.org/TR/2013/REC-sparql11-results-csv-tsv-20130321">SPARQL 1.1 Query Results CSV and TSV Formats</a></cite>, A. Seaborne, Editor, W3C Recommendation, 21 March 2013, http://www.w3.org/TR/2013/REC-sparql11-results-csv-tsv-20130321. <a href="www.w3.org/TR/sparql11-results-csv-tsv/" title="Latest version of SPARQL 1.1 Query Results CSV and TSV Formats">Latest version</a> available at http://www.w3.org/TR/sparql11-results-csv-tsv.</dd>
  <dt><a id="SPROT" name="SPROT">[SPROT]</a></dt>
  <dd>
<cite><a href="www.w3.org/TR/2013/REC-sparql11-protocol-20130321">SPARQL 1.1 Protocol</a></cite>, L. Feigenbaum, G. Williams, K. Clark, E. Torres, Editors, W3C Recommendation, 21 March 2013, http://www.w3.org/TR/2013/REC-sparql11-protocol-20130321. <a href="www.w3.org/TR/sparql11-protocol/" title="Latest version of SPARQL 1.1 Protocol">Latest version</a> available at http://www.w3.org/TR/sparql11-protocol.</dd>
  <dt><a name="TURTLE" id="TURTLE">[TURTLE]</a></dt>
  <dd>
<cite><a href="www.w3.org/TR/2013/CR-turtle-20130219/">Turtle:
Terse RDF Triple Language</a></cite>, E Prud'hommeaux, G Carothers, Editors, W3C Candidate Recommendation, 19 February 2013, http://www.w3.org/TR/2013/CR-turtle-20130219/. <a href="www.w3.org/TR/turtle/" title="Latest version of Turtle">Latest version</a> available at http://www.w3.org/TR/turtle/.</dd>
  <dt><a name="UCNR" id="UCNR">[UCNR]</a></dt>
  <dd>
<a href="www.w3.org/TR/2005/WD-rdf-dawg-uc-20050325/">RDF Data
      Access Use Cases and Requirements</a>, K. Clark,
      Editor, W3C Working Draft, 25 March 2005,
      http://www.w3.org/TR/2005/WD-rdf-dawg-uc-20050325/ . 
    <a href="www.w3.org/TR/rdf-dawg-uc/" title="Latest version of RDF Data Access Use Cases and Requirements">Latest version</a> available at
      http://www.w3.org/TR/rdf-dawg-uc/ .</dd>
  <dt><a name="UCNR2" id="UCNR2">[UCNR2]</a></dt>
  <dd>
<a href="www.w3.org/TR/2009/WD-sparql-features-20090702/">SPARQL New Features and Rationale</a>, 
        Kjetil Kjernsmo,  Alexandre Passant, Editors,
	W3C Working Draft, 2 July 2009,
	http://www.w3.org/TR/2009/WD-sparql-features-20090702/ .
    <a href="www.w3.org/TR/sparql-features/" title="Latest version of SPARQL New Features and Rationale">Latest version</a> available at http://www.w3.org/TR/sparql-features/ .</dd>
  <dt><a name="UNISEC" id="UNISEC">[UNISEC]</a></dt>
  <dd>
<a href="www.unicode.org/reports/tr36/">Unicode Security
      Considerations</a>, Mark Davis, Michel Suignard</dd>
  <dt><a id="VCARD" name="VCARD">[VCARD]</a></dt>
  <dd>
    <a href="www.w3.org/TR/2001/NOTE-vcard-rdf-20010222/">Representing vCard Objects in RDF/XML</a>,
    Renato Iannella,
    W3C Note,
    22 February 2001,
    http://www.w3.org/TR/2001/NOTE-vcard-rdf-20010222/ .
    <a href="www.w3.org/TR/vcard-rdf">Latest version</a> is available at <tt>http://www.w3.org/TR/vcard-rdf</tt> .
  </dd>
  <dt><a name="WEBARCH" id="WEBARCH">[WEBARCH]</a></dt>
  <dd>
<a href="www.w3.org/TR/2004/REC-webarch-20041215/">Architecture of the World Wide Web, Volume One</a>, 
    I. Jacobs, N. Walsh, Editors,
    W3C Recommendation,
    15 December 2004,
    http://www.w3.org/TR/2004/REC-webarch-20041215/ .
    <a href="www.w3.org/TR/webarch/">Latest version</a> is available at <tt>http://www.w3.org/TR/webarch/</tt> .</dd>
  <dt><a name="UNIID" id="UNIID">[UNIID]</a></dt>
  <dd>
<a href="www.unicode.org/reports/tr31/tr31-5.html">Identifier
      and Pattern Syntax 4.1.0</a>, Mark Davis, Unicode
      Standard Annex #31, 25 March 2005,
      http://www.unicode.org/reports/tr31/tr31-5.html . 
    <a href="www.unicode.org/reports/tr31/" title="Latest version of Identifier and Pattern Syntax">Latest
      version</a> available at <a href="www.unicode.org/reports/tr31/">http://www.unicode.org/reports/tr31/</a>
      .</dd>
</dl>

</div>
</div>
<div>

<h2 id="changelog">変更履歴</h2>

<h3 id="changes-since-pr">勧告案以後の変更履歴</h3>

<ul>
  <li>逆プロパティー・パスの例における誤りを修正</li>
</ul>

<h3 id="changes-since-lc">最終草案以後の変更履歴</h3>

<p>以下は最後の公開後に加えられた修正です。</p>

<ul>
  <li>文法: パス用の<tt>DISTINCT</tt>が文法中に残っていた - 削除した。</li>
  <li>以前の版（最初と2番目の最終草案）の元の文のとおりに<tt>BIND</tt>の置換を戻した。</li>
</ul>

<h3 id="changes-since-10">SPARQL 1.0以後</h3>

<p>SPARQL 1.1クエリの新しい機能は次のとおりです。</p>

<ul>
  <li><a title="Feature:Aggregates" href="#aggregates">集約</a></li>
  <li><a title="Feature:Subqueries" href="#subqueries">サブクエリ</a></li>
  <li><a title="Feature:Negation" href="#negation">否定</a></li>
  <li><a title="Feature:ProjectSelectExpressions" href="#selectExpressions">SELECT句の式</a></li>
  <li><a href="#propertypaths">プロパティー・パス</a></li>
  <li><a href="#assignment">割り当て</a></li>
  <li><a href="#constructWhere">CONSTRUCTの省略形</a></li>
  <li><a href="#SparqlOps">関数と演算子の拡張</a></li>
</ul>
</div>
</div>
</body>
</html>